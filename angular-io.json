{
   "Intrudoção":[
      "Um aplicativo Angular compreende uma árvore de componentes, na qual cada componente Angular tem uma finalidade e responsabilidade específicas."
   ],
   "Características e Benefícios":{
      "Plataforma Transversal": {
         "Apps Web Progressivos": "Use os recursos modernos da plataforma da Web para oferecer experiências semelhantes a aplicativos. Instalação de alto desempenho, offline e com zero etapas.",
         "Nativo": "Crie aplicativos móveis nativos com estratégias de Cordova, Ionic ou NativeScript.",
         "Desktop": "Crie aplicativos instalados na área de trabalho em Mac, Windows e Linux usando os mesmos métodos Angular que você aprendeu para a Web, além da capacidade de acessar APIs de SO nativas."
      },
      "Velocidade e Performance":{
         "Geração de Código": "O Angular transforma seus modelos em código altamente otimizado para as máquinas virtuais JavaScript atuais, oferecendo todos os benefícios do código escrito à mão com a produtividade de uma estrutura.",
         "Universal": "Sirva a primeira visualização do seu aplicativo em Node.js.®, .NET, PHP e outros servidores para renderização quase instantânea em apenas HTML e CSS. Também abre caminho para sites que otimizam para SEO.",
         "Divisão de Código": "Os aplicativos angulares são carregados rapidamente com o novo Roteador de componentes, que fornece divisão automática de código, para que os usuários carreguem apenas o código necessário para renderizar a exibição solicitada."
      },
      "Produtividade":{
         "Templates": "Os aplicativos Angular são carregados rapidamente com o novo Roteador de componentes, que fornece divisão automática de código, para que os usuários carreguem apenas o código necessário para renderizar a exibição solicitada.",
         "Angular CLI": "Ferramentas de linha de comando: comece a criar rapidamente, adicione componentes e testes e implante instantaneamente.",
         "IDEs": "Obtenha conclusão inteligente de código, erros instantâneos e outros comentários em editores e IDEs populares."
      },
      "Histório de Dev. Completa": {
         "Teste": "Com o 'Karma' para testes de unidade, você pode saber se quebrou todas as vezes que salvar. E o 'Protractor' faz com que seus testes de cenário sejam executados mais rapidamente e de maneira estável.",
         "Animação": "Crie coreografias complexas de alto desempenho e cronogramas de animação com muito pouco código através da API intuitiva da Angular.",
         "Acessibilidade": "Crie aplicativos acessíveis com componentes habilitados para ARIA, guias do desenvolvedor e infraestrutura de teste integrada do a11y."
      }
   },
   "Fundamentos": {
      "Conceitos":{
            "Conceitos Básicos":{
               "O que é": "Angular é uma plataforma e estrutura para criar aplicativos cliente de página única usando HTML e TypeScript. Angular é escrito em TypeScript.",
               "Arquitetura":{
                  "Contexto": "A arquitetura de um aplicativo Angular depende de certos conceitos fundamentais.",
                  "Conceitos":[
                     "Os blocos de construção básicos estão em NgModules, que fornecem um contexto de compilação para componentes.",
                     "Os NgModules coletam código relacionado em conjuntos funcionais;",
                     "Um aplicativo Angular é definido por um conjunto de NgModules.",
                     "Um aplicativo sempre possui pelo menos um módulo raiz que habilita a inicialização e, normalmente, possui muito mais módulos de recursos."
                  ]
               },
               "Componentes":{
                  "Conceito": "Definem áreas de responsabilidade na interface do usuário, ou na UI, que permitem reutilizar conjuntos de funcionalidades da UI.",
                  "Estrutura de um Componente": {
                     "Class": "Uma classe de componente que lida com dados e funcionalidade. Na seção anterior",
                     "Template": "Um modelo HTML que determina a interface do usuário.",
                     "Style": "Estilos específicos de componentes que definem a aparência."
                  },
                  "Informações Relevantes": [
                     "Os componentes definem visualizações, que são conjuntos de elementos de tela que o Angular pode escolher e modificar de acordo com a lógica e os dados do programa.",
                     "Os componentes usam serviços, que fornecem funcionalidades específicas não diretamente relacionadas às visualizações.",
                     "Os fornecedores de serviços podem ser injetados nos componentes como dependências, tornando seu código modular, reutilizável e eficiente.",
                     "Tanto os componentes quanto os serviços são simplesmente classes, com decoradores que marcam seu tipo e fornecem metadados que informam ao Angular como usá-los.",
                     "To da aplicação  Angular possui pelo menos um componente, o componente raiz que conecta uma hierarquia de componentes ao modelo de objeto de documento de página (DOM).",
                     "Cada componente define uma classe que contém dados e lógica da aplicação e está associada a um modelo HTML que define uma exibição a ser exibida em um ambiente de destino.",
                     "O decorador @Component() identifica a classe imediatamente abaixo dela como um componente e fornece o modelo e os metadados específicos do componente relacionados."
                  ]
               },
               "Metadados":[
                  "Os metadados para uma classe de componente o associam a um modelo que define uma exibição.",
                  "Um modelo combina HTML comum com diretivas Angular e marcação de ligação que permitem que o Angular modifique o HTML antes de renderizá-lo para exibição.",
                  "Os metadados para uma classe de serviço fornecem as informações que o Angular precisa para disponibilizá-lo aos componentes por meio de injeção de dependência (DI)."
               ],
               "Roteador":[
                  "Os componentes de um aplicativo geralmente definem muitas visualizações, organizadas hierarquicamente.",
                  "Angular fornece o serviço Roteador para ajudá-lo a definir os caminhos de navegação entre as visualizações.",
                  "O roteador fornece recursos sofisticados de navegação no navegador."
               ],
               "Módulos": [
                  "Os NgModules do Angular diferem e complementam os módulos JavaScript (ES2015).",
                  "Um NgModule declara um contexto de compilação para um conjunto de componentes dedicado a um domínio de aplicativo, um fluxo de trabalho ou um conjunto de recursos intimamente relacionado.",
                  "Um NgModule pode associar seus componentes a códigos relacionados, como serviços, para formar unidades funcionais",
                  "To da aplicação  Angular possui um módulo raiz, chamado AppModule, que fornece o mecanismo de inicialização que inicia o aplicativo.",
                  "Como os módulos JavaScript, o NgModules pode importar funcionalidades de outros NgModules e permitir que suas próprias funcionalidades sejam exportadas e usadas por outros NgModules.",
                  "Organizar seu código em módulos funcionais distintos ajuda no gerenciamento do desenvolvimento de aplicativos complexos e no design para reutilização.",
                  "A modularização  permite aproveitar o carregamento lento, ou seja, carregar módulos sob demanda, para minimizar a quantidade de código que precisa ser carregado na inicialização.",
                  "O HttpClientModule da Angular registra os provedores que seu aplicativo precisa para usar uma única instância do serviço HttpClient em todo o aplicativo."
               ],
               "Decoradores": [
                  "Decoradores são funções que modificam as classes JavaScript.",
                  "Angular define vários decoradores que anexam tipos específicos de metadados às classes, para que o sistema saiba o que essas classes significam e como devem funcionar."
               ],
               "Modelos":[
                  "A interpolação {{ }} permite renderizar o valor da propriedade como texto.",
                  "A ligação de propriedade [ ] permite usar o valor da propriedade em uma expressão de modelo.",
                  "A associação de eventos usa um conjunto de parênteses ( ) ao redor do evento.",
                  "Conceitos pertinentes a Templates, directives, and data binding",
                  "Um modelo combina HTML com marcação angular que pode modificar elementos HTML antes de serem exibidos.",
                  "As diretivas de modelo fornecem lógica de programa e a marcação de ligação conecta os dados da aplicação e o DOM.",
                  "As diretivas estruturais moldam ou remodelam a estrutura do DOM, geralmente adicionando, removendo e manipulando os elementos aos quais estão anexados - diretivas com um asterisco *, são diretivas estruturais.",
                  "A associação de eventos permite que seu aplicativo responda à entrada do usuário no ambiente de destino, atualizando os dados  da aplicação .",
                  "A associação de propriedades permite interpolar valores calculados a partir dos dados da aplicação para o HTML.",
                  "Antes de uma 'view'' ser exibida, o Angular avalia as diretivas e resolve a sintaxe de ligação no modelo para modificar os elementos HTML e o DOM, de acordo com os dados e a lógica do programa.",
                  "O Angular suporta ligação de dados bidirecional, o que significa que alterações no DOM, como opções do usuário, também são refletidas nos dados do programa.",
                  "Seus modelos podem usar 'pipes' para melhorar a experiência do usuário, transformando valores para exibição.",
                  "O Angular fornece 'pipes' predefinidos para transformações comuns, e você também pode definir seus próprios 'pipes'.",
                  "O async pipe retorna o valor mais recente de um fluxo de dados e continua a fazê-lo pela vida útil de um determinado componente - quando o Angular destrói esse componente, o canal assíncrono para automaticamente."
               ],
               "Injeção de Dependência":[
                  "Para dados ou lógica que não estão associados a uma exibição específica e que você deseja compartilhar entre componentes, você cria uma classe de serviço.",
                  "Uma definição de classe de serviço é imediatamente precedida pelo decorador @Injectable().",
                  "O decorador fornece os metadados que permitem que outros provedores sejam injetados como dependências em sua classe.",
                  "A injeção de dependência (DI) permite manter suas classes de componentes magras e eficientes, eles não buscam dados do servidor, validam a entrada do usuário ou fazem logon diretamente no console; eles delegam essas tarefas nos serviços."
               ],
               "Roteamento":[
                  "O ActivatedRoute é específico para cada componente roteado que o roteador angular carrega. Ele contém informações sobre a rota, seus parâmetros e dados adicionais associados à rota.",
                  "Ao injetar o ActivatedRoute, você está configurando o componente para usar um serviço.",
                  "O NgModule do roteador angular fornece um serviço que permite definir um caminho de navegação entre os diferentes estados da aplicação e exibir hierarquias no seu aplicativo, e ele é modelado nas convenções familiares de navegação do navegador.",
                  "O roteador mapeia caminhos semelhantes a URL para visualizações em vez de páginas, quando um usuário executa uma ação, como clicar em um link, que carregaria uma nova página no navegador, o roteador intercepta o comportamento do navegador e mostra ou oculta as hierarquias de exibição.",
                  "Se o roteador determinar que o estado atual da aplicação requer funcionalidade específica e o módulo que o define não foi carregado, o roteador poderá carregar preguiçosamente o módulo sob demanda.",
                  "Você pode definir regras de navegação, associando os caminhos de navegação aos seus componentes."
               ],
               "Resumo": "https://angular.io/generated/images/guide/architecture/overview2.png"
            },
            "Módulos":{
               "Informações Relevantes":[
                  "Os aplicativos Angular são modulares, sendo que o Angular possui seu próprio sistema de modularidade chamado NgModules.",
                  "NgModules são contêineres para um bloco de código coeso dedicado a um domínio de aplicativo, um fluxo de trabalho ou um conjunto de recursos intimamente relacionados.",
                  "Os NgModules podem conter componentes, provedores de serviços e outros arquivos de código cujo escopo é definido pelo NgModule que contém.",
                  "Os NgModules podem importar a funcionalidade exportada de outros NgModules e exportar a funcionalidade selecionada para uso por outros NgModules.",
                  "To da aplicação  Angular tem pelo menos uma classe NgModule, o módulo raiz, que é convencionalmente chamado AppModule e reside em um arquivo chamado app.module.ts. Você inicia seu aplicativo inicializando o NgModule raiz.",
                  "Um NgModule é definido por uma classe decorada com @NgModule(). O decorador @NgModule() é uma função que aceita um único objeto de metadados, cujas propriedades descrevem o módulo.",
                  "O sistema NgModule é diferente e não está relacionado ao sistema do módulo JavaScript (ES2015) para gerenciar coleções de objetos JavaScript. Estes são sistemas de módulos complementares que você pode usar juntos para escrever seus aplicativos."
               ],
               "Propriedades Importantes":{
                  "declarations": "Os componentes, diretivas e canais que pertencem a este NgModule.",
                  "exports": "O subconjunto de declarações que devem ser visíveis e utilizáveis ​​nos modelos de componentes de outros NgModules.",
                  "imports": "Outros módulos cujas classes exportadas são necessárias pelos modelos de componentes declarados neste NgModule.",
                  "providers": "Criadores de serviços com os quais este NgModule contribui para a coleção global de serviços; eles se tornam acessíveis em todas as partes  da aplicação . (Você também pode especificar provedores no nível do componente, o que geralmente é preferido.)",
                  "bootstrap": "A visualização principal  da aplicação , chamada componente raiz, que hospeda todas as outras visualizações  da aplicação . Somente o NgModule raiz deve definir a propriedade bootstrap."
               }
            },
            "Componentes":{
               "Informações Relevantes":[
                  "Um componente controla um pedaço de tela chamado 'view'.",
                  "Você define a lógica da aplicação de um componente - o que ele faz para suportar a exibição - dentro de uma classe. A classe interage com a exibição por meio de uma API de propriedades e métodos.",
                  "Os metadados de um componente informam ao Angular onde obter os principais componentes necessários para criar e apresentar o componente e sua visualização. Em particular, associa um modelo ao componente, diretamente com o código embutido ou por referência."
               ],
               "Template Syntax":[
                  "Um sintaxe de modelo se parece com HTML comum, exceto que também contém a sintaxe do modelo angular, que altera o HTML com base na lógica da aplicação e no estado dos dados da aplicação e do DOM.",
                  "Um modelo pode usar a ligação de dados para coordenar o aplicativo e os dados do DOM, canalizar para transformar os dados antes que eles sejam exibidos e diretrizes para aplicar a lógica da aplicação ao que é exibido."
               ],
               "Data Biding":[
                  "Angular suporta ligação de dados bidirecional, um mecanismo para coordenar as partes de um modelo com as partes de um componente. Adicione marcação de ligação ao HTML do modelo para informar ao Angular como conectar os dois lados.",
                  "Na ligação bidirecional, um valor de propriedade de dados flui para a caixa de entrada do componente, como na ligação de propriedade. As alterações do usuário também retornam ao componente, redefinindo a propriedade para o valor mais recente, como na ligação de eventos.",
                  "A ligação de dados desempenha um papel importante na comunicação entre um modelo e seu componente e também é importante na comunicação entre os componentes pai e filho.",
                  "Angular processa todas as ligações de dados uma vez para cada ciclo de eventos JavaScript, desde a raiz da árvore de componentes da aplicação até todos os componentes filhos."
               ],
               "Pipes": [
                  "Pipes permitem declarar transformações de valor de exibição no HTML do seu modelo.",
                  "Uma classe com o decorador @Pipe define uma função que transforma valores de entrada em valores de saída para exibição em uma 'view'.",
                  "Você pode encadear tubos, enviando a saída de uma função de tubo para ser transformada por outra função de tubo. Um canal também pode receber argumentos que controlam como ele realiza sua transformação. Por exemplo, você pode passar o formato desejado para o canal de datas."
               ],
               "Diretivas":[
                  "Angular templates are dynamic. When Angular renders them, it transforms the DOM according to the instructions given by directives. A directive is a class with a @Directive() decorator.",
                  "Um componente é tecnicamente uma diretiva. No entanto, os componentes são tão distintos e centrais para aplicativos Angular que Angular define o decorador @Component(), que estende o decorador @Directive() com recursos orientados a modelo.",
                  "Além dos componentes, existem outros dois tipos de diretivas: estrutural e atributo. Angular define várias diretivas de ambos os tipos e você pode definir suas próprias usando o decorador @Directive().",
                  "Os metadados de uma diretiva associam a classe decorada a um elemento seletor usado para inseri-lo no HTML. Nos modelos, as diretivas geralmente aparecem em uma tag de elemento como atributos, por nome ou como destino de uma atribuição ou ligação.",
                  "As diretivas estruturais alteram o layout adicionando, removendo e substituindo elementos no DOM.",
                  "As diretivas de atributo alteram a aparência ou o comportamento de um elemento existente. Nos modelos, eles se parecem com atributos HTML regulares, daí o nome."

               ],
               "Configurações Úteis":{
                  "selector": "Um seletor de CSS que informa ao Angular para criar e inserir uma instância desse componente sempre que encontrar a tag correspondente no HTML. Ex.: se no HTML conter a tag <app-test> </app-test>, o Angular inserirá uma instância da exibição TestComponent entre essas tags.",
                  "templateUrl": "O endereço relativo ao modelo HTML deste componente. Como alternativa, você pode fornecer o modelo HTML embutido, como o valor da propriedade do modelo. Este modelo define a visualização do host do componente.",
                  "providers": "Uma matriz de provedores de serviços que o componente requer."
               },
               "4 Formas de Data Binding": "https://angular.io/generated/images/guide/architecture/databinding.png"
            },
            "Serviço Injetável":{
               "Informações Relevantes":[
                  "Serviço é uma categoria ampla que abrange qualquer valor, função ou recurso que um aplicativo precise. Um serviço geralmente é uma classe com um objetivo estreito e bem definido. Deve fazer algo específico e fazê-lo bem.",
                  "Angular distingue componentes de serviços para aumentar a modularidade e a reutilização. Ao separar a funcionalidade relacionada à exibição de um componente de outros tipos de processamento, você pode tornar suas classes de componentes mais enxutas e eficientes.",
                  "Idealmente, o trabalho de um componente é permitir a experiência do usuário e nada mais. Um componente deve apresentar propriedades e métodos para ligação de dados, para mediar entre a visualização (renderizada pelo modelo) e a lógica da aplicação (que geralmente inclui alguma noção de modelo).",
                  "Um componente pode delegar determinadas tarefas aos serviços, como buscar dados do servidor, validar a entrada do usuário ou efetuar logon diretamente no console. Ao definir essas tarefas de processamento em uma classe de serviço injetável, você disponibiliza essas tarefas para qualquer componente.",
                  "Angular não aplica esses princípios, mas sim ajuda a seguir tais princípios, facilitando a fatoração da lógica da aplicação em serviços e disponibilizando esses serviços aos componentes por meio da injeção de dependência.",
                  "Para definir uma classe como um serviço no Angular, use o decorador @Injectable() para fornecer os metadados que permitem ao Angular injetá-lo em um componente como uma dependência.",
                  "O injetor é o mecanismo principal. Angular cria um injetor para todo o aplicativo durante o processo de inicialização e injetores adicionais, conforme necessário. Você não precisa criar injetores.",
                  "Um injetor cria dependências e mantém um contêiner de instâncias de dependência que reutiliza, se possível. Um provedor é um objeto que informa ao injetor como obter ou criar uma dependência.",
                  "Quando o Angular descobre que um componente depende de um serviço, ele primeiro verifica se o injetor possui alguma instância existente desse serviço. Se uma instância de serviço solicitada ainda não existir, o injetor fará uma usando o provedor registrado e a adicionará ao injetor antes de retornar o serviço à Angular.",
                  "Quando você fornece o serviço no nível raiz, o Angular cria uma instância única e compartilhada do HeroService e o injeta em qualquer classe que solicitar. O registro do provedor nos metadados @Injectable() também permite que o Angular otimize um aplicativo removendo o serviço da aplicação compilado, se ele não for usado.",
                  "Quando você registra um provedor com um NgModule específico, a mesma instância de um serviço está disponível para todos os componentes nesse NgModule. Para se registrar nesse nível, use a propriedade provider do decorador @NgModule().",
                  "Ao registrar um provedor no nível do componente, você obtém uma nova instância do serviço com cada nova instância desse componente."
               ]
            }
      },
      "Componentes e Modelos":{
         "Exibindo Dados": {
            "Informações Relevantes":[
               "Componentes angulares formam a estrutura de dados do seu aplicativo. O modelo HTML associado a um componente fornece os meios para exibir esses dados no contexto de uma página da web. Juntos, a classe e o modelo de um componente formam uma visualização dos dados  da aplicação .",
               "O processo de combinar valores de dados com sua representação na página é chamado de ligação de dados. Você exibe seus dados para um usuário (e coleta dados do usuário) vinculando controles no modelo HTML às propriedades de dados da classe de componente.",
               "Você pode adicionar lógica ao modelo incluindo diretivas, que informam ao Angular como modificar a página conforme ela é renderizada.",
               "Angular define uma linguagem de modelo que expande a notação HTML com sintaxe que permite definir vários tipos de ligação de dados e diretivas lógicas. Quando a página é renderizada, Angular interpreta a sintaxe do modelo para atualizar o HTML de acordo com sua lógica e estado atual dos dados."
            ]
         },
         "Sintaxe do Modelo":{
            "Introdução": [
               "O aplicativo Angular gerencia o que o usuário vê e pode fazer, conseguindo isso através da interação de uma instância de classe de componente (o componente) e seu modelo voltado para o usuário.",
               "Em Angular, o componente desempenha o papel do controlador, e o modelo (template) representa a visualização."
            ],
            "HTML como Modelo": "HTML é a linguagem do modelo Angular. Quase toda a sintaxe HTML é uma sintaxe de modelo válida. O elemento <script> é uma exceção notável; é proibido, eliminando o risco de ataques de injeção de script. Na prática, <script> é ignorado e um aviso aparece no console do navegador.",
            "Interpolação":[
               "A interpolação permite incorporar seqüências de caracteres calculadas no texto entre as tags de elemento HTML e nas atribuições de atributo. Expressões de modelo são o que você usa para calcular essas strings.",
               "Angular avalia todas as expressões entre chaves duplas, converte os resultados da expressão em seqüências de caracteres e as vincula a seqüências literais vizinhas. Por fim, atribui esse resultado interpolado composto a uma propriedade de elemento ou diretiva.",
               "A interpolação é uma sintaxe especial que o Angular converte em uma ligação de propriedade."    
            ],
            "Expressão de Modelo": "Uma expressão de modelo produz um valor e aparece dentro das chaves duplas, {{}}. Angular executa a expressão e a atribui a uma propriedade de um destino de ligação; o destino pode ser um elemento HTML, um componente ou uma diretiva.",
            "Contexto de Exmpressão":[
               "O contexto da expressão é geralmente a instância do componente.",
               "Uma expressão também pode se referir a propriedades do contexto do modelo, como uma variável de entrada do modelo.",
               "O contexto para termos em uma expressão é uma mistura das variáveis ​​do modelo, do objeto de contexto da diretiva (se houver) e dos membros do componente. Se você referenciar um nome que pertence a mais de um desses espaços para nome, o nome da variável do modelo terá precedência, seguido por um nome no contexto da diretiva e, por último, os nomes dos membros do componente."
            ],
            "Diretrizes de Expressão":{
               "Simplicidade": "Embora seja possível escrever expressões de modelo complexas, é uma melhor prática evitá-las. Um nome de propriedade ou chamada de método deve ser a norma, mas uma negação booleana ocasional,!, Está OK. Caso contrário, restrinja a lógica de aplicativo e de negócios ao componente, onde é mais fácil desenvolver e testar.",
               "Rápidas Execuções": [
                     "Angular executa expressões de modelo após cada ciclo de detecção de alterações. Os ciclos de detecção de alterações são acionados por muitas atividades assíncronas, como resoluções de promessas, resultados HTTP, eventos de timer, pressionamentos de teclas e movimentos do mouse.",
                     "As expressões devem terminar rapidamente ou a experiência do usuário pode se arrastar, especialmente em dispositivos mais lentos. Considere armazenar valores em cache quando o cálculo for caro."
               ],
               "Sem Efeitos Colaterais Visíveis": [
                     "Uma expressão de modelo não deve alterar nenhum estado de aplicativo que não seja o valor da propriedade de destino. Essa regra é essencial para a política de 'fluxo de dados unidirecional' do Angular.",
                     "Você nunca deve se preocupar que a leitura de um valor de componente possa alterar algum outro valor exibido.",
                     "A visualização deve ser estável ao longo de uma única passagem de renderização.",
                     "Uma expressão idempotente é ideal porque é livre de efeitos colaterais e melhora o desempenho da detecção de alterações do Angular.",
                     "Em termos do Angular, uma expressão idempotente sempre retorna exatamente a mesma coisa até que um de seus valores dependentes seja alterado.",
                     "Os valores dependentes não devem mudar durante uma única volta do loop de eventos.",
                     "Se uma expressão idempotente retornar uma sequência ou um número, ela retornará a mesma sequência ou número quando chamada duas vezes seguidas.",
                     "Se a expressão retornar um objeto, incluindo uma matriz, retornará a mesma referência de objeto quando chamada duas vezes seguidas."
               ],
               "Instruções de Modelo":[
                     "Uma instrução de modelo responde a um evento gerado por um destino de ligação, como um elemento, componente ou diretiva.",
                     "Uma declaração de modelo tem um efeito colateral. Esse é o objetivo de um evento. É assim que você atualiza o estado da aplicação a partir da ação do usuário.",
                     "Responder a eventos é o outro lado do 'fluxo de dados unidirecional' da Angular. Você é livre para alterar qualquer coisa, em qualquer lugar, durante essa reviravolta do evento.",
                     "Como expressões de modelo, as instruções de modelo usam uma linguagem que se parece com JavaScript. O analisador de instrução de modelo difere do analisador de expressão de modelo e suporta especificamente a atribuição básica (=) e as expressões de encadeamento com ';'."
               ],
               "Contexto da Declaração":[
                     "Assim como nas expressões, as instruções podem se referir apenas ao conteúdo do contexto da instrução, como um método de manipulação de eventos da instância do componente.",
                     "O contexto da instrução geralmente é a instância do componente, ou seja, metodo() em (click)='metodo()'' é um método do componente vinculado a dados.",
                     "O contexto da instrução também pode se referir às propriedades do próprio contexto do modelo.",
                     "Os nomes de contexto do modelo têm precedência sobre os nomes de contexto do componente."
               ],
               "Diretrizes de Declaração":[
                     "As instruções do modelo não podem se referir a nada no espaço para nome global.",
                     "Eles não podem se referir a janela ou documento.",
                     "Eles não podem chamar console.log ou Math.max.",
                     "Como nas expressões, evite escrever instruções de modelo complexas.",
                     "Uma chamada de método ou atribuição simples de propriedade deve ser a norma."
               ],
               "Sintaxe de Ligação":[
                     "A ligação de dados é um mecanismo para coordenar o que os usuários veem, especificamente com os valores dos dados  da aplicação .",
                     "Embora você possa enviar valores e extrair valores do HTML, o aplicativo é mais fácil de escrever, ler e manter se você entregar essas tarefas para uma estrutura de ligação. Você simplesmente declara ligações entre fontes de ligação, direciona elementos HTML e deixa a estrutura fazer o resto.",
                     "Os tipos de ligação que não sejam interpolação têm um nome de destino à esquerda do sinal de igual, cercado por pontuação, [] ou() ou precedido por um prefixo: bind-, on-, bindon-."
               ],
               "Atributo HTML vs. Propriedade DOM":[
                     "A distinção entre um atributo HTML e uma propriedade DOM é fundamental para entender como funciona a ligação Angular. ",
                     "Os atributos são definidos por HTML e as propriedades são acessadas a partir dos nós DOM (Document Object Model).",
                     "É importante lembrar que o atributo HTML e a propriedade DOM são coisas diferentes, mesmo quando eles têm o mesmo nome.", 
                     "No Angular, a única função dos atributos HTML é inicializar o elemento e o estado da diretiva.", 
                     "A ligação de modelo funciona com propriedades e eventos, não atributos.", 
                     "Quando você escreve uma ligação de dados, está lidando exclusivamente com as propriedades e eventos do DOM do objeto de destino.",
                     "Esta regra geral pode ajudá-lo a construir um modelo mental de atributos e propriedades DOM: Os atributos inicializam as propriedades DOM e, então, elas são concluídas. Os valores da propriedade podem mudar; valores de atributo não podem. Há uma exceção a esta regra. Os atributos podem ser alterados por setAttribute(), que reinicializa a propriedade DOM correspondente"
               ]
            }             
         }
      },
      "Formulários": {
         "Informações Relevantes":[
            "Angular fornece duas abordagens diferentes para lidar com a entrada do usuário por meio de formulários: reativo e orientado a modelo. Ambos capturam eventos de entrada do usuário a partir da visualização, validam a entrada do usuário, criam um modelo de formulário e um modelo de dados para atualizar e fornecem uma maneira de rastrear alterações",
            "Formulários reativos e controlados por modelo processam e gerenciam dados de formulário de maneira diferente. Cada um oferece vantagens diferentes.",
            "As formas reativas são mais robustas: são mais escaláveis, reutilizáveis ​​e testáveis. Se os formulários são uma parte essencial do seu aplicativo, ou você já está usando padrões reativos para criar seu aplicativo, use formulários reativos.",
            "Formulários controlados por modelo são úteis para adicionar um formulário simples a um aplicativo, como um formulário de inscrição na lista de e-mails. Eles são fáceis de adicionar a um aplicativo, mas não são dimensionados tão bem quanto em formas reativas. Se você possui requisitos e lógica de formulário muito básicos que podem ser gerenciados apenas no modelo, use formulários controlados por modelo"

         ],
         "Fluxo de Dados":[
            "Os formulários reativos e controlados por modelo seguem duas estratégias diferentes ao manipular a entrada de formulário.",
            "nas formas reativas, cada elemento do formulário na exibição é diretamente vinculado a um modelo de formulário (instância do FormControl). As atualizações da visualização para o modelo e do modelo para a visualização são síncronas e não dependem da interface do usuário renderizada.",
            "Nos formulários controlados por modelo, cada elemento do formulário está vinculado a uma diretiva que gerencia o modelo de formulário internamente."
         ],
         "Validação":[
            "O Angular fornece um conjunto de validadores internos, além da capacidade de criar validadores personalizados.",
            "Os formulários reativos definem validadores personalizados como funções que recebem um controle para validar.",
            "Os formulários controlados por modelo estão vinculados às diretivas de modelo e devem fornecer diretivas de validador personalizadas que agrupam as funções de validação."
         ],
         "Testes":[
            "O teste desempenha um papel importante em aplicativos complexos e uma estratégia de teste mais simples é útil ao validar se seus formulários funcionam corretamente.",
            "Formulários reativos e formulários controlados por modelo têm diferentes níveis de confiança na renderização da interface do usuário para executar asserções com base no controle de formulário e alterações no campo de formulário.",
            "Os formulários reativos fornecem uma estratégia de teste relativamente fácil, porque fornecem acesso síncrono ao formulário e aos modelos de dados e podem ser testados sem renderizar a interface do usuário. Nesses testes, status e dados são consultados e manipulados através do controle sem interagir com o ciclo de detecção de alterações.",
            "A gravação de testes com formulários orientados a modelos requer um conhecimento detalhado do processo de detecção de alterações e um entendimento de como as diretivas são executadas em cada ciclo para garantir que os elementos sejam consultados, testados ou alterados no momento correto."
         ],
         "Mutabilidade":{
            "Reativo":[
               "Os formulários reativos mantêm o modelo de dados puro, fornecendo-o como uma estrutura de dados imutável.",
               "Sempre que uma alteração é acionada no modelo de dados, a instância FormControl retorna um novo modelo de dados em vez de atualizar o modelo de dados existente.",
               "Permite rastrear alterações exclusivas no modelo de dados através da observação do controle.",
               "Fornece uma maneira de a detecção de alterações ser mais eficiente, porque ela só precisa atualizar as alterações exclusivas.",
               "Segue padrões reativos que se integram aos operadores observáveis ​​para transformar dados.",
               "Com formulários reativos, a instância FormControl sempre retorna um novo valor quando o valor do controle é atualizado."
               ],
            "Orientado a Modelos":[
               "Os formulários controlados por modelo dependem da mutabilidade com ligação de dados bidirecional para atualizar o modelo de dados no componente conforme as alterações são feitas no modelo.",
               "Como não há alterações exclusivas a serem rastreadas no modelo de dados ao usar a ligação de dados bidirecional, a detecção de alterações é menos eficiente na determinação de quando são necessárias atualizações.",
               "Com formulários controlados por modelo, a propriedade de cor favorita é sempre modificada para seu novo valor."
            ]
         },
         "Escalabilidade":[
            "Os formulários reativos fornecem acesso a APIs de baixo nível e acesso síncrono ao modelo de formulário, facilitando a criação de formulários em grande escala.",
            "Os formulários orientados a modelos concentram-se em cenários simples, não são tão reutilizáveis, abstraem as APIs de baixo nível e fornecem acesso assíncrono ao modelo de formulário.",
            "A abstração com formulários controlados por modelo também aparece no teste, onde o teste de formulários reativos requer menos configuração e nenhuma dependência do ciclo de detecção de alterações ao atualizar e validar o formulário e os modelos de dados durante o teste."
         ],
         "Considerações Relevantes":[
            "A escolha de uma estratégia começa com a compreensão dos pontos fortes e fracos das opções apresentadas.",
            "Acesso de API de baixo nível e modelo de formulário, previsibilidade, mutabilidade, estratégias diretas de validação e teste e escalabilidade são considerações importantes na escolha da infraestrutura que você usa para criar seus formulários no Angular.",
            "Os formulários controlados por modelo são semelhantes aos padrões no AngularJS, mas têm limitações, devido aos critérios de muitos aplicativos Angular modernos em grande escala.",
            "As formas reativas integram-se aos padrões reativos já presentes em outras áreas da arquitetura Angular e complementam bem esses requisitos."
         ]
      },
      "Observables & RxJS":{
         "Observables":{
            "Informações Relevantes":[
               "Observáveis ​​fornecem suporte para a passagem de mensagens entre partes do seu aplicativo. Eles são usados ​​com freqüência no Angular e são a técnica recomendada para manipulação de eventos, programação assíncrona e manipulação de vários valores.",
               "O 'observer pattern' é um padrão de design de software no qual um objeto, chamado de sujeito, mantém uma lista de seus dependentes, chamados observadores, e os notifica automaticamente sobre alterações de estado. Esse padrão é semelhante (mas não idêntico) ao padrão de design de 'publish/subscribe'.",
               "Observáveis ​​são declarativos - ou seja, você define uma função para publicar valores, mas ela não é executada até que um consumidor assine. O consumidor inscrito recebe notificações até que a função seja concluída ou até que eles cancelem a inscrição."
            ],
            "Uso Básico": "Como publicado, você cria uma instância Observable que define uma função de assinante. Essa é a função que é executada quando um consumidor chama o método subscribe(). A função de assinante define como obter ou gerar valores ou mensagens a serem publicadas.",
            "Subscrever": [
               "Uma instância Observable começa a publicar valores somente quando alguém se inscreve nela. Você se inscreve chamando o método subscribe() da instância, passando um objeto observador para receber as notificações.",
               "Como um termo geral, nos referimos aos dados publicados por um observável como um fluxo. Qualquer tipo de valor pode ser representado com um observável, e os valores são publicados como um fluxo."
            ],
            "Multicasting":[
               "Um observável típico cria uma nova execução independente para cada observador inscrito - quando um observador se inscreve, o observável liga um manipulador de eventos e entrega valores a esse observador - quando outra observador se inscreve, o observável liga um novo manipulador de eventos e entrega valores para esse segundo observador em uma execução separada.",
               "Às vezes, em vez de iniciar uma execução independente para cada assinante, se deseja que cada assinatura obtenha os mesmos valores - mesmo que os valores já tenham começado a ser emitidos.",
               "O Multicasting é a prática de transmitir para uma lista de vários assinantes em uma única execução.",
               "Com um multicast observável, você reutilza o primeiro ouvinte e envia valores para cada assinante."
            ],
            "Error":[
               "Como os observáveis ​​produzem valores de forma assíncrona, o try / catch não captura efetivamente os erros.",
               "Você lida com erros especificando um retorno de chamada de erro no observador.",
               "Produzir um erro também faz com que o observável limpe as assinaturas e pare de produzir valores. Um observável pode produzir valores (chamando o próximo retorno de chamada) ou pode ser concluído chamando o retorno de chamada completo ou de erro."
            ]
         },
         "Biblioteca RxJS":{
            "Informações Relevantes":[
               "A programação reativa é um paradigma de programação assíncrona relacionado aos fluxos de dados e à propagação da mudança (Wikipedia)",
               "O RxJS (Extensões Reativas para JavaScript) é uma biblioteca para programação reativa usando observáveis ​​que facilita a composição de código assíncrono ou baseado em retorno de chamada.",
               "O RxJS fornece uma implementação do tipo Observable, necessária até que o tipo se torne parte do idioma e até que os navegadores o suportem. A biblioteca também fornece funções utilitárias para criar e trabalhar com observáveis.",
               "Funções utilitárias podem ser usadas para: Convertendo código existente para operações assíncronas em observáveis; Iterando Através dos Valores em um Fluxo; Mapeando valores para diferentes tipos; Filtrando fluxos Compondo vários fluxos;"
            ],
            "Operadores":[
               "Operadores são funções que se baseiam na base observável para permitir manipulação sofisticada de coleções. Por exemplo, o RxJS define operadores como map(), filter(), concat() e flatMap(). Os operadores aceitam opções de configuração e retornam uma função que leva uma fonte observável. Ao executar esta função retornada, o operador observa os valores emitidos do observável de origem, os transforma e retorna um novo observável desses valores transformados.",
               "Você pode usar tubos para vincular operadores. Os tubos permitem combinar várias funções em uma única função. A função pipe() usa como argumento as funções que você deseja combinar e retorna uma nova função que, quando executada, executa as funções compostas em sequência.",
               "Um conjunto de operadores aplicados a um observável é uma receita, ou seja, um conjunto de instruções para produzir os valores nos quais você está interessado. Por si só, a receita não faz nada. Você precisa chamar subscribe() para produzir um resultado através da receita.",
               "Para aplicativos Angular, preferimos combinar operadores com tubos, em vez de encadear, embora o encadeamento é usado em muitos exemplos de RxJS."
            ],
            "Erros":[
               "Além do manipulador error() que você fornece na assinatura, o RxJS fornece o operador catchError que permite manipular erros conhecidos na receita observável.",
               "Suponha que você tenha um observável que faça uma solicitação de API e mapeie a resposta do servidor. Se o servidor retornar um erro ou o valor não existir, será produzido um erro. Se você capturar esse erro e fornecer um valor padrão, seu fluxo continuará processando valores em vez de gerar erros."
            ],
            "Retry":[
               "Enquanto o operador catchError fornece um caminho simples de recuperação, o operador de nova tentativa permite tentar novamente uma solicitação com falha. Use o operador de nova tentativa antes do operador catchError. Ele reinscreve a fonte original observável, que pode executar novamente a sequência completa de ações que resultaram no erro. Se isso incluir uma solicitação HTTP, ela tentará novamente.",
               "Não tente novamente as solicitações de autenticação, pois elas devem ser iniciadas apenas pela ação do usuário. Não queremos bloquear contas de usuário com solicitações de login repetidas que o usuário não iniciou."
            ],
            "Nomenclaturas":[
               "Como os aplicativos angulares são geralmente escritos em TypeScript, você normalmente sabe quando uma variável é observável. Embora a estrutura Angular não imponha uma convenção de nomenclatura para observáveis, você verá frequentemente observáveis ​​nomeados com um sinal '$'' à direita.",
               "Definir '$' como convenção pode ser útil ao varrer o código e procurar valores observáveis.",
               "Se você deseja que uma propriedade armazene o valor mais recente de um observável, pode ser conveniente simplesmente usar o mesmo nome com ou sem o '$'"
            ]
         },
         "Observables no Angular":{
            "Informações Relevantes":[
               "Angular usa observáveis ​​como uma interface para lidar com uma variedade de operações assíncronas comuns.",
               "Você pode definir eventos personalizados que enviam dados de saída observáveis ​​de um filho para um componente pai.",
               "O módulo HTTP usa observáveis ​​para lidar com solicitações e respostas AJAX.",
               "Os módulos Router e Forms usam observáveis ​​para ouvir e responder a eventos de entrada do usuário."
            ],
            "Transmissão de Dados":[
               "Angular fornece uma classe EventEmitter que é usada ao publicar valores de um componente por meio do decorador @Output().",
               "O EventEmitter estende de Subject RxJS, adicionando um método emit() para que ele possa enviar valores arbitrários.",
               "Quando emit() é chamado, o EventEmitter passa o valor emitido para o próximo método ) de qualquer observador inscrito."
            ],
            "HTTP":[
               "O HttpClient da Angular retorna observáveis ​​de chamadas de método HTTP.",
               "Observáveis ​​não alteram a resposta do servidor (como pode ocorrer através de chamadas encadeadas .then() sob promessas), em vez disso, você pode usar uma série de operadores para transformar valores conforme necessário.",
               "Solicitações HTTP são canceláveis ​​através do método unsubscribe().",
               "As solicitações podem ser configuradas para obter atualizações de eventos em andamento.",
               "Solicitações com falha podem ser repetidas facilmente."
            ],
            "Async Pipe": "O AsyncPipe assina um cumprimento ou promessa e retorna o valor mais recente que ele emitiu. Quando um novo valor é emitido, o tubo marca o componente a ser verificado quanto a alterações.",
            "Roteamento":[
               "Router.events fornece eventos como observáveis, use o operador filter() do RxJS para procurar eventos de interesse e se inscrever nele para tomar decisões com base na sequência de eventos no processo de navegação.",
               "O ActivatedRoute é um serviço de roteador injetado que utiliza observáveis ​​para obter informações sobre um caminho e parâmetros de rota."
            ],
            "Formulários Reativos": [
               "Os formulários reativos têm propriedades que usam observáveis ​​para monitorar os valores de controle do formulário. As propriedades FormControl valueChanges e statusChanges contêm observáveis ​​que geram eventos de alteração.",
               "A inscrição em uma propriedade observável de controle de formulário é uma maneira de acionar a lógica da aplicação dentro da classe de componentes."
            ]
         },
         "Observables vs Promisses":[
            "Observáveis ​​são declarativos; o cálculo não inicia até a assinatura. As promessas são executadas imediatamente na criação. Isso torna os observáveis ​​úteis para definir receitas que podem ser executadas sempre que você precisar do resultado.",
            "Observáveis ​​fornecem muitos valores. Promessas fornecem um. Isso torna os observáveis ​​úteis para obter vários valores ao longo do tempo.",
            "Observáveis ​​diferenciam entre encadeamento e assinatura. Promessas possuem apenas cláusulas .then(). Isso torna os observáveis ​​úteis para criar receitas de transformação complexas a serem usadas por outras partes do sistema, sem causar a execução do trabalho.",
            "Observáveis subscribe() é responsável por manipular erros. Promessas empurram erros para seus filhos. Isso torna os observáveis ​​úteis para o tratamento centralizado e previsível de erros.",
            "Observáveis ​​não são executados até que um consumidor assine. O subscribe() executa o comportamento definido uma vez e pode ser chamado novamente. Cada assinatura tem seu próprio cálculo. A nova assinatura causa recomputação de valores.",
            "As promessas são executadas imediatamente e apenas uma vez. O cálculo do resultado é iniciado quando a promessa é criada. Não há como reiniciar o trabalho. Todas as cláusulas (assinaturas) compartilham o mesmo cálculo.",
            "Observáveis ​​diferenciam entre funções de transformação, como um mapa e uma assinatura. Somente a assinatura ativa a função de assinante para começar a calcular os valores. As promessas não diferenciam entre as últimas cláusulas .then (equivalentes à assinatura) e as intermediárias .then cláusulas (equivalentes ao map).",
            "Assinaturas observáveis ​​são canceláveis. O cancelamento da inscrição remove o ouvinte de receber mais valores e notifica a função de assinante para cancelar o trabalho. Promessas não são canceláveis.",
            "Erros de execução observáveis ​​são entregues ao manipulador de erros do assinante e o assinante cancela automaticamente a assinatura do observável. Promisses empurram os erros para seus filhos."
         ]
      },
      "HttpClient":{
         "Informações Relevantes":[
            "A maioria dos aplicativos front-end se comunica com serviços de back-end pelo protocolo HTTP. Navegadores modernos suportam duas APIs diferentes para fazer solicitações HTTP: a interface XMLHttpRequest e a API fetch().",
            "O HttpClient em @angular/common / http oferece uma API HTTP do cliente simplificada para aplicativos Angular que repousa na interface XMLHttpRequest exposta pelos navegadores.",
            "Os benefícios adicionais do HttpClient incluem recursos de testabilidade, objetos de solicitação e resposta digitados, interceptação de solicitação e resposta, APIs observáveis ​​e tratamento de erros simplificado.",
            "É uma prática recomendada separar a apresentação dos dados do acesso a dados, encapsulando o acesso a dados em um serviço separado e delegando esse serviço no componente, mesmo em casos simples."
         ],
         "Observáveis ​​e Operadores":[
            "O RxJS é uma biblioteca para compor código assíncrono e baseado em retorno de chamada em um estilo funcional e reativo. Muitas APIs Angular, incluindo HttpClient, produzem e consomem Observáveis ​​RxJS.",
            "Embora você possa se familiarizar com o mínimo de conhecimento em RxJS, convém aumentar suas habilidades em RxJS ao longo do tempo para usar o HttpClient com eficiência.",
            "Um método HttpClient não inicia sua solicitação HTTP até você chamar subscribe() no observável retornado por esse método. Isso vale para todos os métodos HttpClient",
            "Todos os observáveis ​​retornados dos métodos HttpClient são congelados por padrão, a execução da solicitação HTTP é adiada, permitindo que você estenda o observável com operações adicionais, como tap e catchError antes que algo realmente aconteça.",
            "De fato, cada subscrever() inicia uma execução separada e independente do observável. A inscrição duas vezes resulta em duas solicitações HTTP."
         ],
         "Interceptadores":{
            "Informações Relevantes":[
               "Com a interceptação, você declara interceptores que inspecionam e transformam solicitações HTTP do seu aplicativo no servidor. Os mesmos interceptadores também podem inspecionar e transformar as respostas do servidor no caminho de volta ao aplicativo. Vários interceptadores formam uma cadeia de manipuladores de solicitações / respostas para frente e para trás.",
               "Os interceptadores podem executar uma variedade de tarefas implícitas, da autenticação ao log, de maneira rotineira e padrão, para cada solicitação / resposta HTTP.",
               "Sem interceptação, os desenvolvedores teriam que implementar essas tarefas explicitamente para cada chamada de método HttpClient.",
               "A maioria dos interceptadores inspeciona a solicitação no caminho e encaminha a solicitação (talvez alterada) para o método handle() do próximo objeto que implementa a interface HttpHandler.",
               "Como intercept(), o método handle() transforma uma solicitação HTTP em um Observable of HttpEvents, que inclui a resposta do servidor. O método intercept() pode inspecionar esse observável e alterá-lo antes de devolvê-lo ao chamador.",
               "O 'next' objeto representa o próximo interceptador na cadeia de interceptores. O 'next' final da cadeia é o manipulador de back-end HttpClient que envia a solicitação ao servidor e recebe a resposta do servidor.",
               "A maioria dos interceptores chama next.handle() para que a solicitação flua para o próximo interceptador e, eventualmente, para o manipulador de back-end. Um interceptador pode pular a chamada next.handle(), causar um curto-circuito na cadeia e retornar seu próprio Observable com uma resposta artificial do servidor.",
               "Como os interceptores são dependências (opcionais) do serviço HttpClient, você deve fornecê-los no mesmo injetor (ou pai do injetor) que fornece o HttpClient. Os interceptores fornecidos após o DI criar o HttpClient são ignorados."
            ],
            "Ordem dos Interceptadores":[
               "Angular aplica interceptores na ordem em que você os fornece. Se você fornecer interceptores A, então B e C, as solicitações fluirão em A-> B-> C e as respostas fluirão C-> B-> A.",
               "Você não pode alterar a ordem ou remover os interceptores posteriormente. Se você precisar habilitar e desabilitar um interceptor dinamicamente, precisará criar esse recurso no próprio interceptador.",
               "Embora os interceptores sejam capazes de alterar solicitações e respostas, as propriedades da instância HttpRequest e HttpResponse são somente leitura, tornando-as imutáveis."
            ],
            "Imutabilidade":[
               "Eles são imutáveis ​​por um bom motivo: o aplicativo pode repetir uma solicitação várias vezes antes de ser bem-sucedido, o que significa que a cadeia de interceptadores pode reprocessar a mesma solicitação várias vezes.",
               "Se um interceptador pudesse modificar o objeto de solicitação original, a operação tentada novamente seria iniciada a partir da solicitação modificada, e não do original. A imutabilidade garante que os interceptadores vejam a mesma solicitação para cada tentativa.",
               "O protetor de atribuição somente leitura não pode impedir atualizações profundas e, em particular, não pode impedir que você modifique uma propriedade de um objeto do corpo da solicitação. Se você deve alterar o corpo da solicitação, copie-o primeiro, altere a cópia, clone() a solicitação e defina o corpo do clone com o novo corpo",
               "Às vezes, você precisa limpar o corpo da solicitação em vez de substituí-lo. Se você definir o corpo da solicitação clonada como indefinido, o Angular assumirá que pretende deixar o corpo como está. Não é isso que você quer. Se você definir o corpo da solicitação clonada como nulo, o Angular saberá que você deseja limpar o corpo da solicitação."
            ],
            "Registro": "Como os interceptores podem processar a solicitação e a resposta juntos, eles podem fazer coisas como tempo e registrar uma operação HTTP inteira.",
            "Cache":[
               "Os interceptadores podem lidar com solicitações por si mesmos, sem encaminhar para next.handle().",
               "Você pode decidir armazenar em cache determinadas solicitações e respostas para melhorar o desempenho.",
               "Você pode delegar o armazenamento em cache a um interceptador sem perturbar os serviços de dados existentes."
            ],
            "Progresso de Eventos":[
               "Às vezes, os aplicativos transferem grandes quantidades de dados e essas transferências podem levar muito tempo, e os uploads de arquivos são um exemplo típico. Fornecer ao usuário feedback sobre o andamento dessas transferências, é uma ótima prática.",
               "Para fazer uma solicitação com os eventos de progresso ativados, é possível criar uma instância do HttpRequest com a opção reportProgress configurada como true para ativar o rastreamento de eventos de progresso.",
               "Todo evento de progresso aciona a detecção de alterações, portanto, somente ative-as se você realmente pretender relatar o progresso na interface do usuário. Ao usar HttpClient # request() com um método HTTP, configure com observe: 'events' para ver todos os eventos, incluindo o andamento das transferências."
            ],
            "Segurança: Proteção XSR": [
               "A falsificação de solicitação entre sites (XSRF ou CSRF) é uma técnica de ataque pela qual o invasor pode induzir um usuário autenticado a executar ações inconscientemente no seu site.",
               "O HttpClient suporta um mecanismo comum usado para impedir ataques XSRF.",
               "Ao executar solicitações HTTP, um interceptador lê um token de um cookie, por padrão, XSRF-TOKEN, e o define como um cabeçalho HTTP, X-XSRF-TOKEN. Como apenas o código executado em seu domínio pode ler o cookie, o back-end pode ter certeza de que a solicitação HTTP veio da aplicação cliente e não de um invasor.",
               "Por padrão, um interceptador envia esse cabeçalho em todas as solicitações mutantes (como POST) para URLs relativos, mas não em solicitações GET / HEAD ou em solicitações com uma URL absoluta.",
               "Seu servidor precisa definir um token em um cookie de sessão legível por JavaScript chamado XSRF-TOKEN no carregamento da página ou na primeira solicitação GET, de modo que, em solicitações subsequentes, o servidor pode verificar se o cookie corresponde ao cabeçalho HTTP X-XSRF-TOKEN e, portanto, verificar se apenas o código em execução no seu domínio pode ter enviado a solicitação.",
               "O token deve ser exclusivo para cada usuário e deve ser verificável pelo servidor; isso impede que o cliente crie seus próprios tokens.",
               "Definir o token como um resumo do cookie de autenticação do seu site como um extra, para aumentar a segurança."
            ]
         }   
      },
      "Injeção de Dependência":{
         "DI no Angular":{
            "Informações Relevantes": [
               "A injeção de dependência (DI) é um importante padrão de design de aplicativo. O Angular possui sua própria estrutura DI, que normalmente é usada no design de aplicativos Angular para aumentar sua eficiência e modularidade.",
               "Dependências são serviços ou objetos que uma classe precisa para desempenhar sua função. O DI é um padrão de codificação no qual uma classe solicita dependências de fontes externas, em vez de criá-las.",
               "No Angular, a estrutura DI fornece dependências declaradas para uma classe quando essa classe é instanciada.",
               "Os módulos filhos e os injetores de componentes são independentes entre si e criam suas próprias instâncias separadas dos serviços fornecidos.",
               "Quando o Angular destrói uma instância NgModule ou componente, também destrói as instâncias de serviço desse injetor e do injetor.",
               "Quando um componente ou serviço declara uma dependência, o construtor da classe assume essa dependência como parâmetro. Você pode dizer ao Angular que a dependência é opcional, anotando o parâmetro do construtor com @Optional()."
            ],
            "Injetores":[
               "Os injetores são herdados, o que significa que, se um determinado injetor não puder resolver uma dependência, ele solicitará ao injetor pai que a resolva. Um componente pode obter serviços de seu próprio injetor, dos injetores de seus ancestrais, do injetor do NgModule pai ou do injetor raiz.",
               "Você pode dizer ao Angular para injetar uma dependência no construtor de um componente, especificando um parâmetro do construtor com o tipo de dependência.",
               "Existe apenas um injetor de raiz para um aplicativo. Fornecer 'YourService' no nível raiz ou AppModule significa que ele é registrado com o injetor raiz.",
               "Graças à herança do injetor, você ainda pode injetar serviços de todo o aplicativo nesses componentes. O injetor de um componente é filho do injetor de seu componente pai e herda de todos os injetores ancestrais desde o injetor raiz  da aplicação . A Angular pode injetar um serviço prestado por qualquer injetor nessa linhagem.",
               "Ao configurar um injetor com um provedor, você o associa a um token DI. O injetor mantém um mapa de provedor de token interno que ele faz referência quando solicitado por uma dependência. O token é a chave do mapa."
            ],
            "Serviços":[
               "Os serviços são singletons no escopo de um injetor. Ou seja, existe no máximo uma instância de serviço em um determinado injetor.",
               "Há apenas uma instância de 'YourService' no aplicativo inteiro e todas as classes que injetam UserService obtêm essa instância de serviço, a menos que você configure outro provedor com um injetor filho."
            ]
         },
         "Injetores Hierárquicos":{
            "Informações Relevantes":[
               "Os injetores no Angular têm regras que você pode aproveitar para alcançar a visibilidade desejada dos injetáveis ​​em seus aplicativos. Ao entender essas regras, você pode determinar em qual NgModule, Componente ou Diretiva deve declarar um provedor.",
               "Existem duas hierarquias de injetores em Angular: Hierarquia ModuleInjector - é configurada usando uma anotação @NgModule() ou @Injectable(). Hierarquia ElementInjector - criada implicitamente em cada elemento DOM. Um ElementInjector está vazio por padrão, a menos que você o configure na propriedade provider em @Directive() ou @Component()."
            ],
            "ModuleInjector":[
               "O decorador @Injectable() identifica uma classe de serviço, e a propriedade 'providedIn' configura um ModuleInjector específico no 'root', que disponibiliza o serviço no ModuleInjector raiz.",
               "Existem mais dois injetores acima da raiz, um ModuleInjector adicional e NullInjecto.",
               "O método bootstrapModule() cria um injetor filho do injetor de plataforma que é configurado pelo AppModule. Este é o ModuleInjector raiz.",
               "O método platformBrowserDynamic() cria um injetor configurado por um PlatformModule, que contém dependências específicas da plataforma. Isso permite que vários aplicativos compartilhem uma configuração de plataforma.",
               "O próximo injetor pai na hierarquia é o NullInjector(), que é o topo da árvore. Se você foi tão longe na árvore que procura um serviço no NullInjector(), você receberá um erro, a menos que tenha usado @Optional() porque, no final das contas, tudo termina no NullInjector() e ele retorna um erro ou, no caso de @Optional(), nulo.",
               "O diagrama a seguir representa o relacionamento entre o ModuleInjector raiz e seus injetores-pai: https://angular.io/generated/images/guide/dependency-injection/injectors.svg",
               "Enquanto o nome root é um alias especial, outros ModuleInjectors não têm alias. Você tem a opção de criar ModuleInjectors sempre que um componente carregado dinamicamente é criado, como no roteador, que criará ModuleInjectors filho."
            ],
            "ElementInjector": [
               "Angular cria ElementInjectors implicitamente para cada elemento DOM.",
               "Fornecer um serviço no decorador @Component() usando seus provedores ou a propriedade viewProviders configura um ElementInjector.",
               "Quando você fornece serviços em um componente, esse serviço está disponível por meio do ElementInjector nessa instância do componente.",
               "Quando a instância do componente é destruída, o mesmo ocorre com a instância do serviço.",
               "Um componente é um tipo especial de diretiva, o que significa que, assim como @Directive() possui uma propriedade de provedores, @Component() também possui.",
               "Diretivas e Componentes podem configurar provedores usando a propriedade de provedores. Quando você configura um provedor para um componente ou diretiva usando a propriedade provider, esse provedor pertence ao ElementInjector desse componente ou diretiva. Componentes e diretivas no mesmo elemento compartilham um injetor.",
               "Ao resolver um token para um componente / diretiva, o Angular o resolve em duas fases: Contra a hierarquia do ElementInjector (seus pais) Contra a hierarquia do ModuleInjector (seus pais)",
               "Quando um componente declara uma dependência, o Angular tenta satisfazer essa dependência com seu próprio ElementInjector. Se o injetor do componente não tiver o provedor, ele passará a solicitação para o ElementInjector do componente pai, de modo que, as solicitações continuam sendo encaminhadas até que o Angular encontre um injetor que possa manipular a solicitação ou ficar sem os ElementInjectors ancestrais",
               "Se o Angular não encontrar o provedor em nenhum ElementInjectors, ele retornará ao elemento em que a solicitação se originou e procurará na hierarquia ModuleInjector. Se o Angular ainda não encontrar o provedor, ele gera um erro.",
               "Quando você fornece serviços na classe de componente, os serviços são visíveis na árvore ElementInjector em relação a onde e como você fornece esses serviços.",
               "Compreender a estrutura lógica subjacente do modelo Angular fornecerá uma base para configurar serviços e, por sua vez, controlar sua visibilidade."
            ],
            "Modificadores":[
               "O comportamento da resolução da Angular pode ser modificado com @Optional(), @Self(), @SkipSelf() e @Host(). Importe cada um deles de @angular/core e use cada um no construtor da classe de componentes ao injetar seu serviço.",
               "Os modificadores de resolução se enquadram em três categorias: O que fazer se o Angular não encontrar o que você está procurando, que é @Optional() - Por onde começar a procurar, é @SkipSelf() - Onde parar de procurar, @Host() e @Self().",
               "Por padrão, o Angular sempre inicia no Injetor atual e continua pesquisando até o fim. Os modificadores permitem alterar o local inicial (final) ou final.",
               "Opcional() permite que a Angular considere um serviço que você injeta como opcional. Dessa forma, se não puder ser resolvido em tempo de execução, o Angular simplesmente resolverá o serviço como nulo, em vez de gerar um erro.",
               "Use @Self() para que o Angular procure apenas no ElementInjector o componente ou a diretiva atual. Um bom caso de uso para @Self() é injetar um serviço, mas apenas se estiver disponível no elemento host atual. Para evitar erros nessa situação, combine @Self() com @Optional().",
               "@SkipSelf() é o oposto de @Self(). Com o @SkipSelf(), o Angular inicia a busca por um serviço no ElementInjector pai, em vez do atual.",
               "@Host() permite designar um componente como a última parada na árvore do injetor ao procurar fornecedores. Mesmo se houver uma instância de serviço mais adiante, o Angular não continuará procurando."
            ]
         },
         "Informações Extras": [
            "Um provedor de dependência configura um injetor com um token DI, que esse injetor usa para fornecer a versão concreta e em tempo de execução de um valor de dependência.",
            "O injetor depende da configuração do provedor para criar instâncias das dependências injetadas em componentes, diretivas, tubulações e outros serviços.",
            "Você deve configurar um injetor com um provedor ou ele não saberá como criar a dependência. A maneira mais óbvia de um injetor criar uma instância de uma classe de serviço é com a própria classe. Se você especificar a própria classe de serviço como o token do provedor, o comportamento padrão é o injetor instanciar essa classe com 'new'.",
            "Você pode configurar um injetor com um provedor alternativo, a fim de fornecer outro objeto que forneça a funcionalidade de registro necessária. Por exemplo: Você pode fornecer uma classe substituta. Você pode fornecer um objeto do tipo logger. Seu provedor pode chamar uma função de fábrica de registrador.",
            "A configuração do provedor expandido é um objeto literal com duas propriedades - a propriedade 'provider' tem o token que serve como a chave para localizar um valor de dependência e configurar o injetor - a segunda propriedade é um objeto de definição de provedor, que informa ao injetor como criar o valor da dependência. A chave de definição de provedor pode ser useClass, como no exemplo. Também pode ser useExisting, useValue ou useFactory. Cada uma dessas chaves fornece um tipo diferente de dependência.",
            "Um aplicativo Angular possui vários injetores, organizados em uma hierarquia de árvore que é paralela à árvore de componentes. Cada injetor cria uma instância singleton de uma dependência. Essa mesma instância é injetada onde quer que esse injetor forneça esse serviço. Um serviço específico pode ser fornecido e criado em qualquer nível da hierarquia do injetor, o que significa que pode haver várias instâncias de um serviço se ele for fornecido por vários injetores.",
            "Dependências fornecidas pelo injetor raiz podem ser injetadas em qualquer componente em qualquer lugar  da aplicação . Em alguns casos, convém restringir a disponibilidade do serviço a uma região específica  da aplicação . Por exemplo, convém permitir que os usuários optem explicitamente pelo uso de um serviço, em vez de permitir que o injetor raiz o forneça automaticamente."
         ]
      },
      "Roteamento e Navegação":{
         "Visão Geral":{
            "Navegador":[
               "O navegador é um modelo familiar de navegação de aplicativos.",
               "Digite um URL na barra de endereço e o navegador navegará para uma página correspondente.",
               "Clique nos links da página e o navegador navegará para uma nova página.",
               "Clique nos botões voltar e avançar do navegador e o navegador navega para trás e para frente no histórico de páginas que você viu."

            ],
            "Roteador Angular":[
               "O roteador angular ('o roteador') empresta esse modelo (representando o navegador).",
               "Ele pode interpretar um URL do navegador como uma instrução para navegar para uma visualização gerada pelo cliente.",
               "Ele pode passar parâmetros opcionais para o componente de visualização de suporte que ajuda a decidir qual conteúdo específico apresentar",
               "Você pode vincular o roteador aos links em uma página e ele navegará para a visualização apropriada do aplicativo quando o usuário clicar em um link.",
               "Você pode navegar imperativamente quando o usuário clica em um botão, seleciona em uma caixa suspensa ou em resposta a algum outro estímulo de qualquer fonte. E o roteador registra a atividade no diário de histórico do navegador para que os botões voltar e avançar também funcionem."
            ]
         },
         "Básico":{  
            "Introdução": "A maioria dos aplicativos de roteamento deve adicionar um elemento <base href='/'> ao index.html como o primeiro filho na tag <head> para informar ao roteador como compor URLs de navegação.",
            "Importação": "O roteador angular é um serviço opcional que apresenta uma exibição de componente específica para um determinado URL - bão faz parte do núcleo angular ... está no seu próprio pacote de biblioteca, @ angular/router ... importe o que você precisa dele como faria em qualquer outro pacote Angular.",
            "Configuração":[
               "Um aplicativo Angular roteado possui uma instância singleton do serviço Roteador: quando a URL do navegador muda, o roteador procura uma rota correspondente a partir da qual pode determinar o componente a ser exibido, e um roteador não tem rotas até você configurá-lo.",
               "A matriz de rotas 'const appRoutes: Routes = []' descreve como navegar. Passe-o para o método RouterModule.forRoot () nas importações de módulos para configurar o roteador.",
               "Cada rota mapeia um caminho de URL para um componente - não há barras principais no caminho. O roteador analisa e cria a URL final para você, permitindo o uso de caminhos relativos e absolutos ao navegar entre as visualizações do aplicativo.",
               "Utilizar dois pontos ':' é um token para um parâmetro de rota ... em uma URL configurada como '/component/:id' ao ser buscado '/component/1' o numero 1 é o valor do parâmetro id.",
               "A propriedade de 'data' é um local para armazenar dados arbitrários associados a essa rota específica. A propriedade data está acessível dentro de cada rota ativada. Use-o para armazenar itens como títulos de página, texto de trilha de navegação e outros dados estáticos somente leitura.",
               "Um caminho vazio representa o caminho padrão para o aplicativo, o lugar para ir quando o caminho na URL estiver vazio, como normalmente ocorre: 'https://www.seudominio.com.br/' ... não há nenhum caminho informado após a barra '/'.",
               "Dois asteriscos '**' é um curinga, e o roteador selecionará essa rota se o URL solicitado não corresponder a nenhum caminho para as rotas definidas anteriormente na configuração.",
               "A ordem das rotas na configuração é importante e isso ocorre por design - o roteador usa uma estratégia de vitórias de primeira correspondência ao combinar rotas, portanto, rotas mais específicas devem ser colocadas acima de rotas menos específicas.",
               "Em uma configuração padrão, as rotas com um caminho estático são listadas primeiro, seguidas por uma rota de caminho vazia, que corresponde à rota padrão, e a rota curinga vem por último porque corresponde a todos os URLs e deve ser selecionada apenas se nenhuma outra rota corresponder primeiro.",
               "Se você precisar ver quais eventos estão acontecendo durante o ciclo de vida da navegação, há a opção enableTracing como parte da configuração padrão do roteador.",
               "A proriedade enableTracing gera cada evento do roteador que ocorreu durante cada ciclo de vida da navegação no console do navegador e somente deve ser usada apenas para fins de depuração ... a definição ocorre passando true para a propriedade 'enableTracing' no objeto passado como o segundo argumento para o método RouterModule.forRoot()."
            ],
            "Saida de Componentes": "O RouterOutlet é uma diretiva da biblioteca de roteadores usada como um componente, ele atua como um espaço reservado que marca o ponto no modelo em que o roteador deve exibir os componentes através dessa diretiva.",
            "Ligação de Rotas": "As diretivas RouterLink nas tags de âncora dão ao roteador controle sobre esses elementos. Os caminhos de navegação são fixos, para que você possa atribuir uma string ao routerLink (uma ligação 'única').",
            "Links Ativos do Roteador":[
               "A diretiva RouterLinkActive alterna classes css para ligações RouterLink ativas com base no RouterState atual.",
               "Em cada tag de âncora, você vê uma ligação de propriedade à diretiva RouterLinkActive que se parece com routerLinkActive='...'",
               "Você define a diretiva RouterLinkActive como uma sequência de classes como [routerLinkActive]=\"['class1', class2']\" ou vincula-a a uma propriedade de componente que retorna essa sequência.",
               "Os links de rota ativos passam em cascata por cada nível da árvore de rotas, para que os links de roteador pai e filho possam estar ativos ao mesmo tempo.",
               "Para substituir o comportamento padrão de lnks de rota ativos, você pode vincular à ligação de entrada [routerLinkActiveOptions] com a expressão {exact: true} ... ao usar {exact: true}, um determinado RouterLink estará ativo apenas se o URL corresponder exatamente ao URL atual."
            ],
            "Estado do Roteador":[
               "Após o final de cada ciclo de vida de navegação bem-sucedido, o roteador cria uma árvore de objetos ActivatedRoute que compõem o estado atual do roteador.",
               "Você pode acessar o RouterState atual de qualquer lugar do aplicativo usando o serviço Router e a propriedade routerState.",
               "Cada ActivatedRoute no RouterState fornece métodos para percorrer a árvore de rotas para cima e para baixo para obter informações das rotas pai, filho e irmão."
            ],
            "Rota Ativada":{
               "Serviço": "O caminho e os parâmetros da rota estão disponíveis através de um serviço de roteador injetado chamado ActivatedRoute.",
               "Propriedades":{
                  "url": "Um Observável do (s) caminho (s) da rota, representado como uma matriz de seqüências de caracteres para cada parte do caminho da rota.",
                  "data": "Um Observable que contém o objeto de dados fornecido para a rota. Também contém quaisquer valores resolvidos do protetor de resolução.",
                  "paramMap": "Um Observável que contém um mapa dos parâmetros obrigatórios e opcionais específicos da rota. O mapa suporta a recuperação de valores únicos e múltiplos do mesmo parâmetro.",
                  "queryParamMap": "Um Observable que contém um mapa dos parâmetros de consulta disponíveis para todas as rotas. O mapa suporta a recuperação de valores únicos e múltiplos do parâmetro de consulta.",
                  "fragment": "Um Observável do fragmento de URL disponível para todas as rotas.",
                  "outlet": "O nome do RouterOutlet usado para renderizar a rota. Para uma tomada sem nome, o nome da tomada é primário.",
                  "routeConfig": "A configuração de rota usada para a rota que contém o caminho de origem.",
                  "parent": "O ActivatedRoute pai da rota quando esta rota é uma rota filho.",
                  "firstChild": "Contém o primeiro ActivatedRoute na lista de rotas filho desta rota.",
                  "children": "Contém todas as rotas secundárias ativadas na rota atual."
               }
            },
            "Eventos do Roteador":{
               "Propriedade": "Durante cada navegação, o roteador emite eventos de navegação através da propriedade Router.events ... esses eventos variam desde quando a navegação começa e termina em muitos pontos no meio do caminho.",
               "Eventos":{
                  "NavigationStart": "Um evento acionado quando a navegação é iniciada.",
                  "RouteConfigLoadStart": "Um evento disparado antes que o roteador preguiçosamente carregue uma configuração de rota.",
                  "RouteConfigLoadEnd": "Um evento acionado após o carregamento lento de uma rota.",
                  "RoutesRecognized": "Um evento disparado quando o roteador analisa a URL e as rotas são reconhecidas.",
                  "GuardsCheckStart": "Um evento disparado quando o roteador inicia a fase de roteamento dos guardas.",
                  "ChildActivationStart": "Um evento acionado quando o roteador começa a ativar os filhos de uma rota.",
                  "ActivationStart": "Um evento disparado quando o roteador começa a ativar uma rota.",
                  "GuardsCheckEnd": "Um evento disparado quando o roteador termina com êxito a fase de roteamento dos guardas.",
                  "ResolveStart": "Um evento acionado quando o roteador inicia a fase de resolução do roteamento.",
                  "ResolveEnd": "Um evento disparado quando o roteador termina com êxito a fase de resolução do roteamento.",
                  "ChildActivationEnd": "Um evento disparado quando o roteador termina de ativar os filhos de uma rota.",
                  "ActivationEnd": "Um evento disparado quando o roteador termina de ativar uma rota.",
                  "NavigationEnd": "Um evento acionado quando a navegação termina com sucesso.",
                  "NavigationCancel": "Um evento acionado quando a navegação é cancelada. Isso pode acontecer quando um Route Guard retorna false durante a navegação ou redireciona retornando um UrlTree.",
                  "NavigationError": "Um evento acionado quando a navegação falha devido a um erro inesperado.",
                  "Scroll": "Um evento que representa um evento de rolagem."
               }
            },
            "Sumário":{
               "Router": "Exibe o componente do aplicativo para a URL ativa. Gerencia a navegação de um componente para o próximo.",
               "RouterModule": "Um NgModule separado que fornece os provedores de serviços e diretrizes necessárias para navegar pelas exibições de aplicativos.",
               "Routes": "Define uma matriz de rotas, cada uma mapeando um caminho de URL para um componente.",
               "Route": "Define como o roteador deve navegar para um componente com base em um padrão de URL, a maioria das rotas consiste em um caminho e um tipo de componente.",
               "RouterOutlet": "A diretiva (<router-outlet>) que marca onde o roteador exibe uma exibição.",
               "RouterLink": "A diretiva para vincular um elemento HTML clicável a uma rota. Clicar em um elemento com uma diretiva routerLink vinculada a uma cadeia de caracteres ou a uma matriz de parâmetros de link aciona uma navegação.",
               "RouterLinkActive": "A diretiva para adicionar/remover classes de um elemento HTML quando um routerLink associado contido no elemento ou dentro dele se torna ativo/inativo.",
               "ActivatedRoute": "Um serviço que é fornecido a cada componente da rota que contém informações específicas da rota, como parâmetros de rota, dados estáticos, dados de resolução, parâmetros de consulta global e o fragmento global.",
               "RouterState": "O estado atual do roteador, incluindo uma árvore das rotas ativadas no momento, juntamente com métodos de conveniência para percorrer a árvore de rotas."
            }
         }
      },
      "Animações": {
         "Introdução":{
            "Informações Relevantes":[
               "O sistema de animação da Angular é baseado na funcionalidade CSS, o que significa que você pode animar qualquer propriedade que o navegador considere animador - isso inclui posições, tamanhos, transformações, cores, bordas e muito mais.",
               "Os principais módulos angulares para animações são @angular/animations e @angular/platform-browser - quando você cria um novo projeto usando a CLI, essas dependências são adicionadas automaticamente ao seu projeto."
            ],
            "Configuração":[
               "Para começar a adicionar animações angulares ao seu projeto, importe Importe o BrowserAnimationsModule, que apresenta os recursos de animação no seu módulo de aplicativo raiz Angular.",
               "Se você planeja usar funções específicas de animação em arquivos de componentes, importe essas funções de @angular/animations.",
               "No arquivo de componente, adicione uma propriedade de metadados chamada animações: no decorador @Component(). Você coloca o gatilho que define uma animação na propriedade de metadados das animações.",
               "Use a função state() da Angular para definir diferentes estados para chamar no final de cada transição. Essa função usa dois argumentos: um nome exclusivo, e uma função style() ... use a função style() para definir um conjunto de estilos para associar a um determinado nome de estado - observe que os atributos de estilo devem estar no camelCase."
            ],
            "Transições e Tempo":[
               "No Angular, você pode definir vários estilos sem nenhuma animação - no entanto, sem refinamentos adicionais, o botão se transforma instantaneamente sem desbotamento, retração ou outro indicador visível de que uma alteração está ocorrendo.",
               "Para tornar a alteração menos abrupta, precisamos definir uma transição de animação para especificar as alterações que ocorrem entre um estado e outro durante um período de tempo.",
               "A função transit() aceita dois argumentos: o primeiro argumento aceita uma expressão que define a direção entre dois estados de transição e o segundo argumento aceita uma ou uma série de etapas animate().",
               "Use a função animate() para definir a duração, o atraso e a flexibilização de uma transição e para designar a função de estilo para definir estilos enquanto as transições estão ocorrendo.",
               "Você também pode usar a função animate() para definir a função de keyframes() para animações de várias etapas."
            ],
            "Gatilho":[
               "Uma animação requer um gatilho, para que ele saiba quando iniciar.",
               "A função trigger() coleta os estados e transições e fornece um nome à animação, para que você possa anexá-la ao elemento acionador no modelo HTML.",
               "A função trigger() descreve o nome da propriedade a ser observada nas alterações - quando ocorre uma alteração, o gatilho inicia as ações incluídas em sua definição - essas ações podem ser transições ou outras funções.",
               "Dentro de cada chamada de função trigger(), um elemento pode estar apenas em um estado a qualquer momento. No entanto, é possível que vários gatilhos estejam ativos ao mesmo tempo."
            ],
            "Definição": "As animações são definidas nos metadados do componente que controla o elemento HTML a ser animado - coloque o código que define suas animações sob a propriedade animations: dentro do decorador @Component().",
            "Resumo da API":{
               "trigger()": "Inicia a animação e serve como um contêiner para todas as outras chamadas de função de animação ... o modelo HTML é vinculado ao triggerName ... use o primeiro argumento para declarar um nome de acionador exclusivo ... usa sintaxe de matriz.",
               "style()": "Define um ou mais estilos CSS para usar em animações, controla a aparência visual dos elementos HTML durante as animações. Usa sintaxe de objeto.",
               "state()": "Cria um conjunto nomeado de estilos CSS que deve ser aplicado na transição bem-sucedida para um determinado estado ... o estado pode ser referenciado pelo nome em outras funções de animação.",
               "animate()": "Especifica as informações de tempo para uma transição ... pode aplicar valores opcionais para atraso e flexibilização .. pode conter chamadas de style() dentro.",
               "transition()": "Define a sequência de animação entre dois estados nomeados ... usa sintaxe de matriz.",
               "keyframes()": "Permite uma alteração seqüencial entre estilos dentro de um intervalo de tempo especificado ... use dentro de animation() ... pode incluir várias chamadas de style() em cada quadro-chave() ... usa sintaxe de matriz.",
               "group()": "Especifica um grupo de etapas de animação (animações internas) a serem executadas em paralelo ... a animação continua apenas após a conclusão de todas as etapas internas da animação ... usado dentro da sequência() ou transição().",
               "query()": "Use para encontrar um ou mais elementos HTML internos no elemento atual.",
               "sequence()": "Especifica uma lista de etapas de animação executadas seqüencialmente, uma por uma.",
               "stagger()": "Seleciona a hora de início das animações para vários elementos.",
               "animation()": "Produz uma animação reutilizável que pode ser chamada de outro lugar quando usado junto com useAnimation().",
               "useAnimation()": "Ativa uma animação reutilizável ... usado com animação().",
               "animateChild()": "Permite que animações em componentes filhos sejam executadas no mesmo período do pai."
            }
         },
         "Transições e Gatilhos":{
            "Informações Relevantes":[
               "O suporte de animação da Angular se baseia em animações da Web, para que você possa animar qualquer propriedade que o navegador considere animador. Isso inclui posições, tamanhos, transformações, cores, bordas e muito mais. O W3C mantém uma lista de propriedades animáveis ​​em sua página Transições CSS.",
               "Em Angular, os estados de transição podem ser definidos explicitamente através da função state() ou usando os estados predefinidos * (curinga) e void (nulos).",
               "Você pode combinar estados curinga e estados nulos em uma transição para acionar animações que entram e saem da página: uma transição de * => nulo se aplica quando o elemento sai de uma visualização, independentemente do estado em que estava antes de sair - uma transição de void => * se aplica quando o elemento entra em uma visualização, independentemente do estado que ele assume ao entrar ... o estado curinga * corresponde a qualquer estado, incluindo nulo.",
               "Os alias ':enter' e ':leave' são correspondentes para  as transições 'void => *' e '* => void' ... esses aliases são usados ​​por várias funções de animação.",
               "É mais difícil segmentar um elemento que está entrando em uma visualização porque ainda não está no DOM ... portanto, use os aliases: enter e: leave para direcionar elementos HTML que são inseridos ou removidos de uma visualização.",
               "A transição :enter é executada quando qualquer exibição *ngIf ou *ngFor é colocada na página e :leave é executada quando essas exibições são removidas da página.",
               "A função transition() recebe valores adicionais de seletor, como ':incremento' e ':decremento' ...  use-os para iniciar uma transição quando um valor numérico aumentou ou diminuiu de valor.",
               "Um asterisco * ou curinga corresponde a qualquer estado de animação. Isso é útil para definir transições que se aplicam independentemente do estado inicial ou final do elemento HTML.",
               "Os estados curinga são melhores quando um elemento em um estado específico possui vários estados potenciais para os quais pode mudar.",
               "Use o curinga * com um estilo para dizer à animação para usar o valor atual do estilo e animar com isso. Curinga é um valor de fallback usado se o estado que está sendo animado não for declarado no gatilho.",
               "Você pode usar o estado nulo (void) para configurar transições para um elemento que está entrando ou saindo de uma página.",
               "Se você não fornecer uma unidade ao especificar uma dimensão, Angular assumirá uma unidade padrão de pixels ou px. Expressar 50 pixels como 50 é o mesmo que dizer '50px'."
            ],
            "Mutiplos Gatilhos":[
               "Você pode definir mais de um gatilho de animação para um componente.",
               "Você pode anexar gatilhos de animação a diferentes elementos, e os relacionamentos pai-filho entre os elementos afetam como e quando as animações são executadas.",
               "Sempre que uma animação é acionada em Angular, a animação pai sempre tem prioridade e as animações filho são bloqueadas.",
               "Para que uma animação filho seja executada, a animação pai deve consultar cada um dos elementos que contêm animações filho e permitir que as animações sejam executadas usando a função animateChild().",
               "Uma ligação de controle de animação especial chamada @.disabled pode ser colocada em um elemento HTML para desativar as animações nesse elemento, bem como quaisquer elementos aninhados. - quando verdadeira, a ligação @.disabled impede que todas as animações sejam renderizadas.",
               "Quando um elemento em um modelo HTML tem animações desativadas usando a ligação de host @.disabled, as animações também são desativadas em todos os elementos internos - você não pode desativar seletivamente várias animações em um único elemento.",
               "Animações filho seletivas ainda podem ser executadas em um pai desabilitado de uma das seguintes maneiras: uma animação pai pode usar a função query() para coletar elementos internos localizados em áreas desabilitadas do modelo HTML - uma sub-animação pode ser consultada por um pai e posteriormente animada com a função animateChild()."
            ],
            "Keyframes":[
               "A função keyframe() do Angular é semelhante aos quadros-chave em CSS. Os quadros-chave permitem várias mudanças de estilo em um único segmento de tempo.",
               "Os quadros-chave incluem um deslocamento que define o ponto na animação em que cada alteração de estilo ocorre.",
               "Deslocamentos são medidas relativas de zero a um, marcando o início e o final da animação, respectivamente, e devem ser aplicados a cada uma das etapas do quadro-chave, se usadas pelo menos uma vez.",
               "Definir deslocamentos para quadros-chave é opcional. Se você os omitir, as compensações espaçadas igualmente serão atribuídas automaticamente. Por exemplo, três quadros-chave sem deslocamentos predefinidos recebem deslocamentos de 0, 0,5 e 1.",
               "Você pode combinar quadros-chave com duração, atraso e facilidade em uma única animação.",
               "A função keyframes() no Angular permite especificar vários estilos intermediários em uma única transição, com um deslocamento opcional para definir o ponto na animação em que ocorre a alteração de cada estilo."
            ]
         },
         "Animações Complexas":{
            "Informações Relevantes":[
               "Angular também permite animar seqüências coordenadas, como uma grade inteira ou uma lista de elementos à medida que eles entram e saem de uma página. Você pode optar por executar várias animações em paralelo ou animações discretas sequencialmente, uma após a outra.",
               "As funções que controlam sequências complexas de animação são as seguintes: query() localiza um ou mais elementos HTML internos. stagger() aplica um atraso em cascata às animações para vários elementos. group() executa várias etapas de animação em paralelo. sequence() executa as etapas de animação uma após a outra."
            ],
            "Multiplas Animações": [
               "A função query() permite encontrar elementos internos no elemento que está sendo animado - essa função tem como alvo elementos HTML específicos dentro de um componente pai e aplica animações a cada elemento individualmente. O Angular manipula inteligentemente a instalação, desmontagem e limpeza, pois coordena os elementos na página.",
               "A função stagger() permite definir um intervalo de tempo entre cada item consultado que é animado e, assim, anima elementos com um atraso entre eles."
            ],
            "Animação Paralela":"Você também pode configurar animações que acontecem em paralelo - por exemplo, você pode animar duas propriedades CSS do mesmo elemento, mas usar uma função de atenuação diferente para cada uma - para isso, você pode usar a função group().",
            "Animação Sequencial": "As funções angulares para animar vários elementos começam com query() para encontrar elementos internos, por exemplo, reunindo todas as imagens em um <div>. As demais funções, stagger(), group() e sequence(), aplicam cascatas ou permitem controlar como várias etapas de animação são aplicadas.",
            "Sequencial vs Paralelo": "Uma segunda função chamada sequence() permite executar as mesmas animações uma após a outra. Dentro de sequence(), as etapas de animação consistem em chamadas de função style() ou animate()."
         },
         "Animações Reutilizáveis":[
            "A interface AnimationOptions nas animações angulares permite criar animações que podem ser reutilizadas em diferentes componentes.",
            "Para criar uma animação reutilizável, use o método animation() para definir uma animação em um arquivo .ts separado e declare essa definição de animação como uma variável de exportação const. Você pode importar e reutilizar essa animação em qualquer um dos componentes do seu aplicativo usando a API useAnimation()."
         ],
         "Animações de Rota": {
            "Informações Relevantes":[
               "O roteamento permite que os usuários naveguem entre diferentes rotas em um aplicativo. Quando um usuário navega de uma rota para outra, o roteador Angular mapeia o caminho da URL para um componente relevante e exibe sua exibição.",
               "Animar essa transição de rota pode melhorar bastante a experiência do usuário.",
               "O roteador Angular vem com funções de animação de alto nível que permitem animar as transições entre visualizações quando uma rota é alterada. Para produzir uma sequência de animação ao alternar entre rotas, é necessário definir sequências de animação aninhadas.",
               "Comece com o componente de nível superior que hospeda a visualização e aninhe animações adicionais nos componentes que hospedam as visualizações incorporadas."
            ],
            "Configuração":[
               "Para começar, configure um conjunto de rotas usando os métodos disponíveis na classe RouterModule.",
               "A configuração de rota informa ao roteador como navegar.",
               "Use o método RouterModule.forRoot para definir um conjunto de rotas.",
               "Importe esse RouterModule para a matriz de importações do módulo principal, AppModule.",
               "A propriedade data de cada rota define a principal configuração específica da animação associada a uma rota e seu valor é passado para AppComponent quando a rota é alterada - você também pode transmitir dados adicionais na configuração de rota consumida na animação.",
               "Depois de configurar as rotas, informe ao roteador Angular onde renderizar as visualizações quando corresponder a uma rota.",
               "AppComponent precisa definir um método que pode detectar quando uma exibição é alterada. O método atribui um valor de estado de animação ao acionador de animação (@routeAnimation) com base no valor da propriedade de dados de configuração da rota.",
               "Disponibilize a definição de animação no seu aplicativo adicionando a animação reutilizável aos metadados das animações do Componente."
            ],
            "Exemplo Prático": "https://angular.io/guide/route-animations"
         }
      },
      "NgZone": {
         "Informações Relevantes": [
            "Uma zona é um contexto de execução que persiste em tarefas assíncronas, você pode pensar nele como armazenamento local de thread para VMs JavaScript - o NgZone do Angular serve para detectar automaticamente alterações no componente para atualizar o HTML.",
            "A angular executa a detecção de alterações sempre que detecta que os dados podem ter sido alterados, e o resultado da detecção de alterações é que o DOM é atualizado com novos dados.",
            "Angular detecta as alterações de diferentes maneiras - para a inicialização do componente, as chamadas angulares alteram a detecção explicitamente - para operações assíncronas, o Angular usa uma zona para detectar alterações nos locais onde os dados poderiam ter sofrido uma mutação e executa a detecção de alterações automaticamente."
         ],
         "Base de Fundamentos": [
            "Você pode exibir dados vinculando controles em um modelo HTML às propriedades de um componente Angular.",
            "Você pode vincular eventos DOM a um método de um componente Angular. Nesses métodos, você também pode atualizar uma propriedade do componente Angular, que atualiza os dados correspondentes exibidos no modelo.",
            "Você também pode obter dados de um servidor através de uma solicitação HTTP.",
            "Você também pode atualizar os dados na função de retorno de chamada de uma macroTask, como setTimeout()",
            "Outras APIs assíncronas retornam um objeto Promise (como busca), para que a função de retorno de chamada then() também possa atualizar os dados.",
            "Além de addEventListener(), setTimeout() e Promise.then(), há outras operações que podem atualizar os dados de forma assíncrona. Alguns exemplos incluem WebSocket.onmessage() e Canvas.toBlob()."
         ],
         "Contexto de Execução": [
            "O contexto de zona persiste em operações assíncronas.",
            "Contexto de execução é um conceito abstrato que contém informações sobre o ambiente no código atual que está sendo executado.",
            "Uma região fornece um novo contexto de zona diferente do javascript:  por exemplo ... o 'this' de um callback não estar contido em outro método."
         ],
         "Zona":[
            "Uma zona fornece um contexto de execução que persiste em tarefas assíncronas.",
            "O Zone.js pode criar contextos que persistem em operações assíncronas, bem como fornecer ganchos de ciclo de vida para operações assíncronas.",
            "Todas as funções do Zone são fornecidas por uma biblioteca chamada Zone.js - essa biblioteca implementa esses recursos interceptando APIs assíncronas por meio de aplicação de patches monkey. O patch monkeys é uma técnica para adicionar ou modificar o comportamento padrão de uma função em tempo de execução sem alterar o código-fonte."
         ],
         "NgZone": [
            "Embora o Zone.js possa monitorar todos os estados das operações síncronas e assíncronas, a Angular também fornece um serviço chamado NgZone. Este serviço cria uma zona denominada angular para acionar automaticamente a detecção de alterações",
            "Ainda existem algumas APIs de terceiros que o Zone não manipula. Nesses casos, o serviço NgZone fornece um método run() que permite executar uma função dentro da zona angular - essa função e todas as operações assíncronas nessa função acionam a detecção de alterações automaticamente no momento correto.",
            "Por padrão, todas as operações assíncronas estão dentro da zona angular, o que aciona a detecção de alterações automaticamente.",
            "Quando você não deseja acionar a detecção de alterações, você pode usar outro método NgZone: runOutsideAngular().",
            "Para disponibilizar o Zone.js no Angular, você precisa importar o pacote zone.js - se você estiver usando a CLI Angular, esta etapa será realizada automaticamente e você verá a seguinte linha no src/polyfills.ts:",
            "Antes de importar o pacote zone.js, você pode definir configurações desejáveis e para fazer essas alterações, você precisa criar um arquivo zone-flags.ts, import zone-flags before you import zone.js in the polyfills.ts, importando-o antes de importar o zone.js no arquivo polyfills.ts.",
            "O Zone ajuda o Angular a saber quando acionar a detecção de alterações e permite que os desenvolvedores se concentrem no desenvolvimento de aplicativos.",
            "Por padrão, o Zone é carregado e funciona sem configuração adicional. No entanto, você não precisa necessariamente usar o Zone para fazer o Angular funcionar - em vez disso, você pode optar por ativar a detecção de alterações por conta própria."
         ]
      }  
   },
   "Configurações":{
      "Estrutura do Projeto":{
            "Informações Relevantes":[
               "Você desenvolve aplicativos no contexto de um espaço de trabalho Angular.",
               "Um espaço de trabalho contém os arquivos para um ou mais projetos.",
               "Um projeto é o conjunto de arquivos que compõem um aplicativo independente ou uma biblioteca compartilhável.",
               "Por padrão, ng new cria um aplicativo esqueleto inicial no nível raiz da área de trabalho, junto com seus testes de ponta a ponta.",
               "O esqueleto é para um aplicativo de boas-vindas simples, pronto para executar e fácil de modificar.",
               "O aplicativo no nível raiz tem o mesmo nome que a área de trabalho e os arquivos de origem residem na ./src/ subpasta da área de trabalho.",
               "Usuários iniciantes e intermediários são incentivados a usar o ng new para criar um espaço de trabalho separado para cada aplicativo.",
               "O Angular também suporta áreas de trabalho com vários projetos. Esse tipo de ambiente de desenvolvimento é adequado para usuários avançados que estão desenvolvendo bibliotecas compartilháveis ​​e para empresas que usam um estilo de desenvolvimento 'monorepo', com um repositório único e configuração global para todos os projetos Angular.",
               "Todos os projetos em um espaço de trabalho compartilham um contexto de configuração da CLI.",
               "O maior nível da área de trabalho contém arquivos de configuração para toda a área de trabalho, arquivos de configuração para o aplicativo no nível raiz e subpastas para os arquivos de origem e teste da aplicação no nível raiz.",
               "Por padrão, o comando 'new' da CLI gera um novo esqueleto de aplicativo em uma pasta ./src/ no nível superior da área de trabalho. Um aplicativo recém-gerado contém arquivos de origem para um módulo raiz, com um componente raiz e um modelo.",
               "Para uma área de trabalho de aplicativo único, a ./src/ subpasta da área de trabalho contém os arquivos de origem (lógica, dados e ativos  da aplicação ) para o aplicativo raiz - para uma área de trabalho com vários projetos, os projetos são adicionados na pasta ./projects/ que contêm uma subpasta ./project-name/src/ com a mesma estrutura.",
               "Arquivos no nível superior de ./src/ suportam os testes e executam sua aplicação, já as subpastas contêm o código da aplicação e configuração específica.",
               "Os arquivos de configuração específicos da aplicação para o aplicativo raiz residem no nível raiz do espaço de trabalho. Para uma área de trabalho com vários projetos, os arquivos de configuração específicos do projeto estão na raiz do projeto, em projects ./project-name/",
               "Os arquivos de configuração TypeScript específicos do projeto são herdados do tsconfig.json em todo o espaço de trabalho e os arquivos de configuração TSLint específicos do projeto são herdados do tslint.json em todo o espaço de trabalho.",
               "A pasta ./e2e/ no nível superior contém arquivos de origem para um conjunto de testes de ponta a ponta que correspondem ao aplicativo no nível raiz, junto com arquivos de configuração específicos de test - para uma área de trabalho de vários projetos, os testes de ponta a ponta específicos do aplicativo estão na raiz do projeto, em projects / nome do projeto / e2e /."
            ],
            "Workspace Configuration Files":{
               ".editorconfig": "Configuração para recursos pertinentes a editores de código.",
               ".gitignore": "Especifica arquivos intencionalmente não rastreados que o Git deve ignorar.",
               "README.md": "Documentação introdutória para o aplicativo raiz.",
               "angular.json": "Padrões de configuração da CLI para todos os projetos no espaço de trabalho, incluindo opções de configuração para ferramentas de compilação, serviços e teste que a CLI usa, como TSLint, Karma e Protractor.",
               "package.json": "Configura as dependências do pacote npm que estão disponíveis para todos os projetos no espaço de trabalho.",                
               "package-lock.json": "Fornece informações de versão para todos os pacotes instalados no node_modules pelo cliente npm.",
               "./src/": "Contempla os arquivos de origem para o projeto de aplicativo no nível raiz.",
               "./node_modules/": "Fornece pacotes npm para todo o espaço de trabalho. As dependências node_modules em todo o espaço de trabalho são visíveis para todos os projetos.",
               "tsconfig.json": "Contém a configuração padrão do TypeScript para projetos na área de trabalho.",
               "tslint.json": "Contém a configuração padrão do TSLint para projetos na área de trabalho."
            },
            "Source Config Files":{
               "./src/app/": "Contém os arquivos de componentes nos quais a lógica e os dados da aplicação estão definidos.",
               "./src/assets/" : "Contém arquivos de imagem e outros ativos a serem copiados como estão quando você cria seu aplicativo.",
               "./src/environments/": "Contém opções de configuração de compilação para ambientes de destino específicos. Por padrão, há um ambiente de desenvolvimento sem nome e um ambiente de produção ('prod'). Você pode definir configurações adicionais do ambiente de destino.",
               "./src/favicon.ico": "Um ícone a ser usado para este aplicativo na barra de favoritos.",
               "./src/index.html": "Aquivo HTML principal que é exibida quando alguém visita seu site, a CLI adiciona automaticamente todos os arquivos JavaScript e CSS ao criar seu aplicativo. Portanto, você normalmente não precisa adicionar nenhuma tag <script> ou <link> aqui manualmente.",
               "./src/main.ts": "Principal ponto de entrada para a sua aplicação, compila o aplicativo com o compilador JIT e inicializa o módulo raiz da aplicação (AppModule) para executar no navegador. Você também pode usar o compilador AOT sem alterar nenhum código anexando o sinalizador --aot aos comandos de compilação e exibição da CLI.",
               "./src/polyfills.ts": "Fornece scripts de polyfill para suporte a compatibilidade do Javascript em navegadores.",
               "./src/styles.sass": "Lista de arquivos CSS que fornecem estilos para um projeto, a extensão reflete o pré-processador de estilo que você configurou para o projeto.",
               "./src/test.ts": "Principal ponto de entrada para seus testes de unidade, com algumas configurações específicas do Angular. Você normalmente não precisa editar este arquivo."
            },
            "App-Specific Config Files":{
               "browserslist": "Configura o compartilhamento de navegadores de destino e versões do Node.js entre várias ferramentas de front-end.",
               "karma.conf.js": "Configura informações específicas do Karma da aplicação .",
               "tsconfig.app.json": "Configura informações específicas do TypeScript da aplicação, incluindo opções de compilador de modelo TypeScript e Angular.",
               "tsconfig.spec.json": "Configura informações dp TypeScript para os testes da aplicação.",
               "tslint.json": "Configura informações específicas do TSLint da aplicação."
            },
            "Appliation Files":{
               "./src/app/app.component.ts": "Define a lógica do componente raiz  da aplicação, chamado AppComponent, e a visualização associada a esse componente raiz se torna a raiz da hierarquia da visualização à medida que você adiciona componentes e serviços ao seu aplicativo.",
               "./src/app/app.component.html": "Define o modelo HTML associado ao AppComponent raiz.",
               "./src/app/app.module.ts": "Define o módulo raiz, chamado AppModule, que informa ao Angular como montar o aplicativo. Inicialmente declara apenas o AppComponent, a medida que você adiciona mais componentes ao aplicativo, eles devem ser declarados aqui.",
               "./src/app/app.component.spec.ts": "Define um teste de unidade para o AppComponent raiz.",
               "./src/app/app.component.css": "Define a folha de estilo CSS base para o AppComponent raiz."
            },
            "Library Source Files":{
               "../src/lib/": "Contém a lógica e os dados do seu projeto de biblioteca, um projeto de biblioteca pode conter componentes, serviços, módulos, diretivas e tubulações.",
               "../src/test.ts": "O principal ponto de entrada para seus testes de unidade, com algumas configurações específicas da biblioteca. Você normalmente não precisa editar este arquivo.",
               "../src/public-api.ts": "Especifica todos os arquivos que são exportados da sua biblioteca.",
               "../karma.conf.js": "Configuração de karma específica da biblioteca.",
               "../ng-package.json": "Arquivo de configuração usado pelo ng-packagr para construir sua biblioteca.",
               "../package.json": "Configura as dependências do pacote npm necessárias para esta biblioteca.",
               "../tsconfig.lib.json": "Configuração TypeScript específica da biblioteca, incluindo opções de compilador de modelo TypeScript e Angular.",
               "../tsconfig.spec.json": "Configuração TypeScript para os testes da biblioteca.",
               "../tslint.json": "Configuração TSLint específica da biblioteca."
            }
      },
      "Configuração da Workspace":{
            "Estrutura Geral JSON":{
               "Informações Relevantes":[
                  "O arquivo angular.json no nível raiz de um espaço de trabalho Angular fornece padrões de configuração específicos do projeto e para todo o espaço de trabalho para ferramentas de construção e desenvolvimento fornecidas pela CLI Angular. Os valores do caminho fornecidos na configuração são relativos à pasta da área de trabalho raiz.",
                  "No nível superior do angular.json, algumas propriedades configuram a área de trabalho e uma seção de projetos contém as opções de configuração restantes por projeto. Os padrões da CLI configurados no nível da área de trabalho podem ser substituídos pelos padrões configurados no nível do projeto e os padrões configurados no nível do projeto podem ser substituídos na linha de comandos.",
                  "Cada aplicativo adicional que você cria ng generate possui um projeto de teste de ponta a ponta correspondente, com sua própria seção de configuração. Quando você cria um projeto de biblioteca com ng generate library, o projeto de biblioteca também é adicionado à seção de projetos.",
                  ""
               ],
               "Propriedades de Configuração":{
                  "version": "Contém a versão do arquivo de configuração.",
                  "newProjectRoot": "Contempla o caminho onde novos projetos são criados, absoluto ou relativo à pasta da área de trabalho.",
                  "defaultProject": "Nome do projeto padrão a ser usado em comandos, onde não é fornecido como argumento. Quando você usa ng new para criar um novo aplicativo em um novo espaço de trabalho, esse aplicativo é o projeto padrão do espaço de trabalho até que seja alterado.",
                  "schematics": "Um conjunto de esquemas que personalizam os padrões da opção de subcomando ng generate para este espaço de trabalho. Consulte Esquemas de geração abaixo.",
                  "projects": "Contém uma subseção para cada projeto (biblioteca ou aplicativo) na área de trabalho, com as opções de configuração por projeto."
               },
               "Opções de Configuração do Projeto":{
                  "root": "A pasta raiz dos arquivos deste projeto, relativa à pasta da área de trabalho - vazio para o aplicativo inicial, que reside no nível superior da área de trabalho.",
                  "sourceRoot": "A pasta raiz dos arquivos de código do projeto.",
                  "projectType": "( Aplicativo ou Biblioteca ), sendo que um aplicativo pode ser executado independentemente em um navegador, enquanto uma biblioteca não.",
                  "prefix": "Uma sequência que o Angular acrescenta aos seletores gerados - pode ser personalizado para identificar um aplicativo ou área de recursos.",
                  "schematics": "Um conjunto de esquemas que personalizam os padrões da opção de subcomando ng generate para o projeto.",
                  "architect": "Configuração padrão para arquitetura 'build' alvo do projeto."
               },
               "Schematics":[
                  "Esquemas de geração angular são instruções para modificar um projeto adicionando arquivos ou modificando arquivos existentes.",
                  "Os esquemas individuais para os subcomandos de geração de CLI angular padrão são coletados no pacote @angular. Especifique o nome do esquema para um subcomando no formato schematic-package: schematic-name; por exemplo, o esquema para gerar um componente é @angular: component.",
                  "Os schemas JSON por padrão são usados ​​pela CLI para gerar projetos e partes de projetos são coletados no pacote @schematics/angular. O schemas descreve as opções disponíveis para a CLI para cada um dos subcomandos ng generate, como mostrado na saída --help.",
                  "Os campos fornecidos no esquema correspondem aos valores e padrões de argumentos permitidos para as opções de subcomando da CLI. Você pode atualizar seu arquivo de esquema da área de trabalho para definir um padrão diferente para uma opção de subcomando."
               ],
               "Architect":{
                  "Informações Relevantes":[
                        "O Architect é a ferramenta que a CLI usa para executar tarefas complexas, como compilação e execução de testes.",
                        "Architect é um shell que executa um construtor especificado para executar uma determinada tarefa, de acordo com uma configuração de destino.",
                        "Você pode definir e configurar novos construtores e destinos para estender a CLI.",
                        "Angular define construtores padrão para uso com comandos específicos da CLI ou com o comando geral ng run - os schemas JSON que definem as opções e os padrões para cada um desses construtores padrão são coletados no pacote @angular-devkit/build-angular.",
                        "A seção architect do angular.json contém um conjunto de destinos da arquitetura - muitos dos destinos correspondem aos comandos da CLI que os executam - alguns destinos predefinidos adicionais podem ser executados usando o comando ng run, e você pode definir seus próprios destinos.",
                        "Cada objeto de destino de construção especifica o construtor para esse destino, que é o pacote npm para a ferramenta que o Architect executa.",
                        "Cada destino possui uma seção de opções que configura as opções padrão para o destino e uma seção de configurações que nomeia e especifica configurações alternativas para o destino."
                  ],
                  "Destinos de Construção":{
                        "build": {
                           "Conceito": "Configura os padrões para as opções do comando ng build. Consulte Criar destino abaixo para obter mais informações.",
                           "Propriedades":{
                              "builder": "Contém o pacote npm para a ferramenta de construção da aplicação - o construtor padrão para um aplicativo (ng build myApp) é @ angular-devkit / build-angular: browser, que usa o empacotador de pacote webpack - observe que um construtor diferente é usado para construir uma biblioteca (ng build myLib).",
                              "options": "Esta seção contém opções de destino de construção padrão, usadas quando nenhuma configuração alternativa nomeada é especificada.",
                              "configurations": "Esta seção define e nomeia configurações alternativas para diferentes destinos pretendidos - ele contém uma seção para cada configuração nomeada, que define as opções padrão para o ambiente pretendido."
                           }
                        },
                        "serve": "Substitui os padrões de construção e fornece padrões de serviço adicionais para o comando ng serve. Além das opções disponíveis para o comando ng build, ele adiciona opções relacionadas à veiculação do aplicativo.",
                        "e2e": "Substitui os padrões de opção de construção para criar aplicativos de teste de ponta a ponta usando o comando ng e2e.",
                        "test": "Substitui os padrões de opção de compilação para compilações de teste e fornece padrões adicionais de execução de teste para o comando ng test.",
                        "lint": "Configura os padrões para as opções do comando ng lint, que executa a análise de código nos arquivos de origem do projeto. A ferramenta de linting padrão para Angular é TSLint.",
                        "extract-i18n": "Configura os padrões para as opções da ferramenta ng-xi18n usada pelo comando ng xi18n, que extrai as seqüências de mensagens marcadas do código-fonte e gera arquivos de tradução.",
                        "server": "Configura os padrões para a criação de um aplicativo Universal com renderização no servidor, usando o comando ng run <project>: server.",
                        "app-shell": "Configura os padrões para a criação de um shell de aplicativo para um aplicativo Web progressivo (PWA), usando o comando ng run <project>: app-shell."
                  },
                  "Build Alterinativo":[
                        "Por padrão, uma configuração de produção é definida e o comando ng build possui a opção --prod que é criada usando essa configuração.",
                        "A configuração de produção define padrões que otimizam o aplicativo de várias maneiras, como agrupar arquivos, minimizar o espaço em branco em excesso, remover comentários e código morto e reescrever o código para usar nomes curtos e enigmáticos ('minification').",
                        "Você pode definir e nomear configurações alternativas adicionais (como estágio, por exemplo) apropriadas ao seu processo de desenvolvimento.",
                        "As opções configuráveis ​​para uma compilação padrão ou direcionada geralmente correspondem às opções disponíveis para os comandos ng build, ng serve e ng test."
                  ]
               }
            }
      },
      "Dependências NPM":{
            "Informações Relevantes":[
               "O Angular Framework, o Angular CLI e os componentes usados ​​pelos aplicativos Angular são empacotados como pacotes npm e distribuídos pelo registro npm.",
               "É possível fazer o download e instalar esses pacotes npm usando o cliente CLI npm, que é instalado e executado como um aplicativo Node.js.",
               "Como alternativa, você pode usar o cliente yarn para baixar e instalar pacotes npm.",
               "O package.json está organizado em dois grupos de pacotes: (1) dependências são essenciais para a execução de aplicativos; (2) devDependencies são necessárias apenas para desenvolver aplicativos."
            ],
            "package.json":[
               "O npm e o yarn instalam os pacotes identificados em um arquivo package.json.",
               "O comando da CLI ng new cria um arquivo package.json quando cria o novo espaço de trabalho. Este package.json é usado por todos os projetos no espaço de trabalho, incluindo o projeto inicial do aplicativo criado pela CLI quando ele cria o espaço de trabalho.",
               "Inicialmente, o package.json inclui um conjunto inicial de pacotes, alguns dos quais são exigidos pelo Angular e outros que suportam cenários comuns de aplicativos. Você adiciona pacotes ao package.json à medida que seu aplicativo evolui, pondendo remove-los também."
            ],
            "Pacotes do Angular":{
               "@angular/animations": "A biblioteca de animações do Angular facilita a definição e a aplicação de efeitos de animação, como transições de página e lista.",
               "@angular/comum": "Os serviços, tubulações e diretrizes geralmente necessários, fornecidos pela equipe Angular. O HttpClientModule também está aqui, na subpasta @angular/common/http.",
               "@angular/compiler": "Compilador de modelos do Angular. Ele compreende modelos e pode convertê-los em código que faz com que o aplicativo seja executado e renderizado. Normalmente você não interage diretamente com o compilador; em vez disso, você o usa indiretamente via plataforma-dinâmica do navegador ao compilar o JIT no navegador.",
               "@angular/core": "Partes críticas do tempo de execução da estrutura necessárias para cada aplicativo. Inclui todos os decoradores de metadados, Componente, Diretiva, injeção de dependência e os ganchos do ciclo de vida do componente.",
               "@angular/forms": "Suporte para formulários orientados a modelos e reativos.",
               "@angular/platform‑browser": "Tudo relacionado ao DOM e ao navegador, especialmente as peças que ajudam a renderizar no DOM. Este pacote também inclui o método bootstrapModuleFactory() para aplicativos de auto-inicialização para compilações de produção que são pré-compiladas com o AOT.",
               "@angular/platform‑browser‑dynamic": "Inclui provedores e métodos para compilar e executar o aplicativo no cliente usando o compilador JIT.",
               "@angular/router": "O módulo roteador navega entre as páginas do aplicativo quando o URL do navegador é alterado. Para mais informações."
            },
            "Pacotes de Suporte":{
               "rxjs": "Muitas APIs do Angular retornam Observables - o RxJS é uma implementação da especificação proposta do Observables atualmente no comitê do TC39, que determina os padrões para a linguagem JavaScript.",
               "zone.js": "O Angular conta com o zone.js para executar os processos de detecção de alterações do Angular quando operações JavaScript nativas geram eventos. Zone.js é uma implementação de uma especificação atualmente perante o comitê do TC39 que determina padrões para a linguagem JavaScript.",
               "core.js": "Muitos navegadores não têm suporte nativo para alguns recursos nos mais recentes padrões HTML, recursos exigidos pelo Angular. Os polyfills podem emular os recursos ausentes. O guia Suporte ao navegador explica quais navegadores precisam de polyfills e como você pode adicioná-los. O core-js, preenche os recursos ausentes de vários navegadores populares."
            },
            "DevDependecies":{
               "@angular‑devkit/build-angular": "As ferramentas de construção do Angular.",
               "@angular/cli": "As ferramentas da CLI do Angular.",
               "@angular/compiler-cli": "O compilador do Angular, que é chamado pelos comandos ng build e ng serve da CLI Angular.",
               "@angular/language-service": "O serviço de linguagem Angular analisa modelos de componentes e fornece informações de tipo e erro que os editores compatíveis com TypeScript podem usar para melhorar a experiência do desenvolvedor. Por exemplo, consulte a extensão do serviço de idioma angular para o VS Code.",
               "@types/...": "Arquivos de definição TypeScript para bibliotecas de terceiros, como Jasmine e Node.js. codelyzer Um ponteiro para aplicativos Angular cujas regras estão em conformidade com o guia de estilo Angular.",
               "asmine/...": "Pacotes para suportar a biblioteca de testes Jasmine.",
               "karma/...": "Pacotes para apoiar o corredor de teste de karma.",
               "protractor": "Uma estrutura de ponta a ponta (e2e) para aplicativos angulares. Criado sobre o WebDriverJS.",
               "ts-node": "Ambiente de execução TypeScript do ts-node e REPL para Node.js.",
               "tslint": "Uma ferramenta   de análise estática que verifica o código TypeScript em busca de erros de legibilidade, manutenção e funcionalidade.",
               "typescript": "O servidor de linguagem TypeScript, incluindo o compilador tsc TypeScript."
            }
      }
   }
}
