{
  "Intrudoção": [
    "Um aplicativo Angular compreende uma árvore de componentes, na qual cada componente Angular tem uma finalidade e responsabilidade específicas."
  ],
  "Características e Benefícios": {
    "Plataforma Transversal": {
      "Apps Web Progressivos": "Use os recursos modernos da plataforma da Web para oferecer experiências semelhantes a aplicativos. Instalação de alto desempenho, offline e com zero etapas.",
      "Nativo": "Crie aplicativos móveis nativos com estratégias de Cordova, Ionic ou NativeScript.",
      "Desktop": "Crie aplicativos instalados na área de trabalho em Mac, Windows e Linux usando os mesmos métodos Angular que você aprendeu para a Web, além da capacidade de acessar APIs de SO nativas."
    },
    "Velocidade e Performance": {
      "Geração de Código": "O Angular transforma seus modelos em código altamente otimizado para as máquinas virtuais JavaScript atuais, oferecendo todos os benefícios do código escrito à mão com a produtividade de uma estrutura.",
      "Universal": "Sirva a primeira visualização do seu aplicativo em Node.js.®, .NET, PHP e outros servidores para renderização quase instantânea em apenas HTML e CSS. Também abre caminho para sites que otimizam para SEO.",
      "Divisão de Código": "Os aplicativos angulares são carregados rapidamente com o novo Roteador de componentes, que fornece divisão automática de código, para que os usuários carreguem apenas o código necessário para renderizar a exibição solicitada."
    },
    "Produtividade": {
      "Templates": "Os aplicativos Angular são carregados rapidamente com o novo Roteador de componentes, que fornece divisão automática de código, para que os usuários carreguem apenas o código necessário para renderizar a exibição solicitada.",
      "Angular CLI": "Ferramentas de linha de comando: comece a criar rapidamente, adicione componentes e testes e implante instantaneamente.",
      "IDEs": "Obtenha conclusão inteligente de código, erros instantâneos e outros comentários em editores e IDEs populares."
    },
    "Histório de Dev. Completa": {
      "Teste": "Com o 'Karma' para testes de unidade, você pode saber se quebrou todas as vezes que salvar. E o 'Protractor' faz com que seus testes de cenário sejam executados mais rapidamente e de maneira estável.",
      "Animação": "Crie coreografias complexas de alto desempenho e cronogramas de animação com muito pouco código através da API intuitiva da Angular.",
      "Acessibilidade": "Crie aplicativos acessíveis com componentes habilitados para ARIA, guias do desenvolvedor e infraestrutura de teste integrada do a11y."
    }
  },
  "Fundamentos": {
    "Conceitos": {
      "Conceitos Básicos": {
        "O que é": "Angular é uma plataforma e estrutura para criar aplicativos cliente de página única usando HTML e TypeScript. Angular é escrito em TypeScript.",
        "Arquitetura": {
          "Contexto": "A arquitetura de um aplicativo Angular depende de certos conceitos fundamentais.",
          "Conceitos": [
            "Os blocos de construção básicos estão em NgModules, que fornecem um contexto de compilação para componentes.",
            "Os NgModules coletam código relacionado em conjuntos funcionais;",
            "Um aplicativo Angular é definido por um conjunto de NgModules.",
            "Um aplicativo sempre possui pelo menos um módulo raiz que habilita a inicialização e, normalmente, possui muito mais módulos de recursos."
          ]
        },
        "Componentes": {
          "Conceito": "Definem áreas de responsabilidade na interface do usuário, ou na UI, que permitem reutilizar conjuntos de funcionalidades da UI.",
          "Estrutura de um Componente": {
            "Class": "Uma classe de componente que lida com dados e funcionalidade. Na seção anterior",
            "Template": "Um modelo HTML que determina a interface do usuário.",
            "Style": "Estilos específicos de componentes que definem a aparência."
          },
          "Informações Relevantes": [
            "Os componentes definem visualizações, que são conjuntos de elementos de tela que o Angular pode escolher e modificar de acordo com a lógica e os dados do programa.",
            "Os componentes usam serviços, que fornecem funcionalidades específicas não diretamente relacionadas às visualizações.",
            "Os fornecedores de serviços podem ser injetados nos componentes como dependências, tornando seu código modular, reutilizável e eficiente.",
            "Tanto os componentes quanto os serviços são simplesmente classes, com decoradores que marcam seu tipo e fornecem metadados que informam ao Angular como usá-los.",
            "To da aplicação  Angular possui pelo menos um componente, o componente raiz que conecta uma hierarquia de componentes ao modelo de objeto de documento de página (DOM).",
            "Cada componente define uma classe que contém dados e lógica da aplicação e está associada a um modelo HTML que define uma exibição a ser exibida em um ambiente de destino.",
            "O decorador @Component() identifica a classe imediatamente abaixo dela como um componente e fornece o modelo e os metadados específicos do componente relacionados."
          ]
        },
        "Metadados": [
          "Os metadados para uma classe de componente o associam a um modelo que define uma exibição.",
          "Um modelo combina HTML comum com diretivas Angular e marcação de ligação que permitem que o Angular modifique o HTML antes de renderizá-lo para exibição.",
          "Os metadados para uma classe de serviço fornecem as informações que o Angular precisa para disponibilizá-lo aos componentes por meio de injeção de dependência (DI)."
        ],
        "Roteador": [
          "Os componentes de um aplicativo geralmente definem muitas visualizações, organizadas hierarquicamente.",
          "Angular fornece o serviço Roteador para ajudá-lo a definir os caminhos de navegação entre as visualizações.",
          "O roteador fornece recursos sofisticados de navegação no navegador."
        ],
        "Módulos": [
          "Os NgModules do Angular diferem e complementam os módulos JavaScript (ES2015).",
          "Um NgModule declara um contexto de compilação para um conjunto de componentes dedicado a um domínio de aplicativo, um fluxo de trabalho ou um conjunto de recursos intimamente relacionado.",
          "Um NgModule pode associar seus componentes a códigos relacionados, como serviços, para formar unidades funcionais",
          "To da aplicação  Angular possui um módulo raiz, chamado AppModule, que fornece o mecanismo de inicialização que inicia o aplicativo.",
          "Como os módulos JavaScript, o NgModules pode importar funcionalidades de outros NgModules e permitir que suas próprias funcionalidades sejam exportadas e usadas por outros NgModules.",
          "Organizar seu código em módulos funcionais distintos ajuda no gerenciamento do desenvolvimento de aplicativos complexos e no design para reutilização.",
          "A modularização  permite aproveitar o carregamento lento, ou seja, carregar módulos sob demanda, para minimizar a quantidade de código que precisa ser carregado na inicialização.",
          "O HttpClientModule da Angular registra os provedores que seu aplicativo precisa para usar uma única instância do serviço HttpClient em todo o aplicativo."
        ],
        "Decoradores": [
          "Decoradores são funções que modificam as classes JavaScript.",
          "Angular define vários decoradores que anexam tipos específicos de metadados às classes, para que o sistema saiba o que essas classes significam e como devem funcionar."
        ],
        "Modelos": [
          "A interpolação {{ }} permite renderizar o valor da propriedade como texto.",
          "A ligação de propriedade [ ] permite usar o valor da propriedade em uma expressão de modelo.",
          "A associação de eventos usa um conjunto de parênteses ( ) ao redor do evento.",
          "Conceitos pertinentes a Templates, directives, and data binding",
          "Um modelo combina HTML com marcação angular que pode modificar elementos HTML antes de serem exibidos.",
          "As diretivas de modelo fornecem lógica de programa e a marcação de ligação conecta os dados da aplicação e o DOM.",
          "As diretivas estruturais moldam ou remodelam a estrutura do DOM, geralmente adicionando, removendo e manipulando os elementos aos quais estão anexados - diretivas com um asterisco *, são diretivas estruturais.",
          "A associação de eventos permite que seu aplicativo responda à entrada do usuário no ambiente de destino, atualizando os dados  da aplicação .",
          "A associação de propriedades permite interpolar valores calculados a partir dos dados da aplicação para o HTML.",
          "Antes de uma 'view'' ser exibida, o Angular avalia as diretivas e resolve a sintaxe de ligação no modelo para modificar os elementos HTML e o DOM, de acordo com os dados e a lógica do programa.",
          "O Angular suporta ligação de dados bidirecional, o que significa que alterações no DOM, como opções do usuário, também são refletidas nos dados do programa.",
          "Seus modelos podem usar 'pipes' para melhorar a experiência do usuário, transformando valores para exibição.",
          "O Angular fornece 'pipes' predefinidos para transformações comuns, e você também pode definir seus próprios 'pipes'.",
          "O async pipe retorna o valor mais recente de um fluxo de dados e continua a fazê-lo pela vida útil de um determinado componente - quando o Angular destrói esse componente, o pipe assíncrono para automaticamente."
        ],
        "Injeção de Dependência": [
          "Para dados ou lógica que não estão associados a uma exibição específica e que você deseja compartilhar entre componentes, você cria uma classe de serviço.",
          "Uma definição de classe de serviço é imediatamente precedida pelo decorador @Injectable().",
          "O decorador fornece os metadados que permitem que outros provedores sejam injetados como dependências em sua classe.",
          "A injeção de dependência (DI) permite manter suas classes de componentes magras e eficientes, eles não buscam dados do servidor, validam a entrada do usuário ou fazem logon diretamente no console; eles delegam essas tarefas nos serviços."
        ],
        "Roteamento": [
          "O ActivatedRoute é específico para cada componente roteado que o roteador angular carrega. Ele contém informações sobre a rota, seus parâmetros e dados adicionais associados à rota.",
          "Ao injetar o ActivatedRoute, você está configurando o componente para usar um serviço.",
          "O NgModule do roteador angular fornece um serviço que permite definir um caminho de navegação entre os diferentes estados da aplicação e exibir hierarquias no seu aplicativo, e ele é modelado nas convenções familiares de navegação do navegador.",
          "O roteador mapeia caminhos semelhantes a URL para visualizações em vez de páginas, quando um usuário executa uma ação, como clicar em um link, que carregaria uma nova página no navegador, o roteador intercepta o comportamento do navegador e mostra ou oculta as hierarquias de exibição.",
          "Se o roteador determinar que o estado atual da aplicação requer funcionalidade específica e o módulo que o define não foi carregado, o roteador poderá carregar preguiçosamente o módulo sob demanda.",
          "Você pode definir regras de navegação, associando os caminhos de navegação aos seus componentes."
        ],
        "Resumo": "https://angular.io/generated/images/guide/architecture/overview2.png"
      },
      "Módulos": {
        "Informações Relevantes": [
          "Os aplicativos Angular são modulares, sendo que o Angular possui seu próprio sistema de modularidade chamado NgModules.",
          "NgModules são contêineres para um bloco de código coeso dedicado a um domínio de aplicativo, um fluxo de trabalho ou um conjunto de recursos intimamente relacionados.",
          "Os NgModules podem conter componentes, provedores de serviços e outros arquivos de código cujo escopo é definido pelo NgModule que contém.",
          "Os NgModules podem importar a funcionalidade exportada de outros NgModules e exportar a funcionalidade selecionada para uso por outros NgModules.",
          "To da aplicação  Angular tem pelo menos uma classe NgModule, o módulo raiz, que é convencionalmente chamado AppModule e reside em um arquivo chamado app.module.ts. Você inicia seu aplicativo inicializando o NgModule raiz.",
          "Um NgModule é definido por uma classe decorada com @NgModule(). O decorador @NgModule() é uma função que aceita um único objeto de metadados, cujas propriedades descrevem o módulo.",
          "O sistema NgModule é diferente e não está relacionado ao sistema do módulo JavaScript (ES2015) para gerenciar coleções de objetos JavaScript. Estes são sistemas de módulos complementares que você pode usar juntos para escrever seus aplicativos."
        ],
        "Propriedades Importantes": {
          "declarations": "Os componentes, diretivas e canais que pertencem a este NgModule.",
          "exports": "O subconjunto de declarações que devem ser visíveis e utilizáveis ​​nos modelos de componentes de outros NgModules.",
          "imports": "Outros módulos cujas classes exportadas são necessárias pelos modelos de componentes declarados neste NgModule.",
          "providers": "Criadores de serviços com os quais este NgModule contribui para a coleção global de serviços; eles se tornam acessíveis em todas as partes  da aplicação . (Você também pode especificar provedores no nível do componente, o que geralmente é preferido.)",
          "bootstrap": "A visualização principal  da aplicação , chamada componente raiz, que hospeda todas as outras visualizações  da aplicação . Somente o NgModule raiz deve definir a propriedade bootstrap."
        }
      },
      "Componentes": {
        "Informações Relevantes": [
          "Um componente controla um pedaço de tela chamado 'view'.",
          "Você define a lógica da aplicação de um componente - o que ele faz para suportar a exibição - dentro de uma classe. A classe interage com a exibição por meio de uma API de propriedades e métodos.",
          "Os metadados de um componente informam ao Angular onde obter os principais componentes necessários para criar e apresentar o componente e sua visualização. Em particular, associa um modelo ao componente, diretamente com o código embutido ou por referência."
        ],
        "Template Syntax": [
          "Um sintaxe de modelo se parece com HTML comum, exceto que também contém a sintaxe do modelo angular, que altera o HTML com base na lógica da aplicação e no estado dos dados da aplicação e do DOM.",
          "Um modelo pode usar a ligação de dados para coordenar o aplicativo e os dados do DOM, canalizar para transformar os dados antes que eles sejam exibidos e diretrizes para aplicar a lógica da aplicação ao que é exibido."
        ],
        "Data Biding": [
          "Angular suporta ligação de dados bidirecional, um mecanismo para coordenar as partes de um modelo com as partes de um componente. Adicione marcação de ligação ao HTML do modelo para informar ao Angular como conectar os dois lados.",
          "Na ligação bidirecional, um valor de propriedade de dados flui para a caixa de entrada do componente, como na ligação de propriedade. As alterações do usuário também retornam ao componente, redefinindo a propriedade para o valor mais recente, como na ligação de eventos.",
          "A ligação de dados desempenha um papel importante na comunicação entre um modelo e seu componente e também é importante na comunicação entre os componentes pai e filho.",
          "Angular processa todas as ligações de dados uma vez para cada ciclo de eventos JavaScript, desde a raiz da árvore de componentes da aplicação até todos os componentes filhos."
        ],
        "Pipes": [
          "Pipes permitem declarar transformações de valor de exibição no HTML do seu modelo.",
          "Uma classe com o decorador @Pipe define uma função que transforma valores de entrada em valores de saída para exibição em uma 'view'.",
          "Você pode encadear tubos, enviando a saída de uma função de tubo para ser transformada por outra função de tubo. Um pipe também pode receber argumentos que controlam como ele realiza sua transformação. Por exemplo, você pode passar o formato desejado para o pipe de datas."
        ],
        "Diretivas": [
          "Angular templates are dynamic. When Angular renders them, it transforms the DOM according to the instructions given by directives. A directive is a class with a @Directive() decorator.",
          "Um componente é tecnicamente uma diretiva. No entanto, os componentes são tão distintos e centrais para aplicativos Angular que Angular define o decorador @Component(), que estende o decorador @Directive() com recursos orientados a modelo.",
          "Além dos componentes, existem outros dois tipos de diretivas: estrutural e atributo. Angular define várias diretivas de ambos os tipos e você pode definir suas próprias usando o decorador @Directive().",
          "Os metadados de uma diretiva associam a classe decorada a um elemento seletor usado para inseri-lo no HTML. Nos modelos, as diretivas geralmente aparecem em uma tag de elemento como atributos, por nome ou como destino de uma atribuição ou ligação.",
          "As diretivas estruturais alteram o layout adicionando, removendo e substituindo elementos no DOM.",
          "As diretivas de atributo alteram a aparência ou o comportamento de um elemento existente. Nos modelos, eles se parecem com atributos HTML regulares, daí o nome."
        ],
        "Configurações Úteis": {
          "selector": "Um seletor de CSS que informa ao Angular para criar e inserir uma instância desse componente sempre que encontrar a tag correspondente no HTML. Ex.: se no HTML conter a tag <app-test> </app-test>, o Angular inserirá uma instância da exibição TestComponent entre essas tags.",
          "templateUrl": "O endereço relativo ao modelo HTML deste componente. Como alternativa, você pode fornecer o modelo HTML embutido, como o valor da propriedade do modelo. Este modelo define a visualização do host do componente.",
          "providers": "Uma matriz de provedores de serviços que o componente requer."
        },
        "4 Formas de Data Binding": "https://angular.io/generated/images/guide/architecture/databinding.png"
      },
      "Serviço Injetável": {
        "Informações Relevantes": [
          "Serviço é uma categoria ampla que abrange qualquer valor, função ou recurso que um aplicativo precise. Um serviço geralmente é uma classe com um objetivo estreito e bem definido. Deve fazer algo específico e fazê-lo bem.",
          "Angular distingue componentes de serviços para aumentar a modularidade e a reutilização. Ao separar a funcionalidade relacionada à exibição de um componente de outros tipos de processamento, você pode tornar suas classes de componentes mais enxutas e eficientes.",
          "Idealmente, o trabalho de um componente é permitir a experiência do usuário e nada mais. Um componente deve apresentar propriedades e métodos para ligação de dados, para mediar entre a visualização (renderizada pelo modelo) e a lógica da aplicação (que geralmente inclui alguma noção de modelo).",
          "Um componente pode delegar determinadas tarefas aos serviços, como buscar dados do servidor, validar a entrada do usuário ou efetuar logon diretamente no console. Ao definir essas tarefas de processamento em uma classe de serviço injetável, você disponibiliza essas tarefas para qualquer componente.",
          "Angular não aplica esses princípios, mas sim ajuda a seguir tais princípios, facilitando a fatoração da lógica da aplicação em serviços e disponibilizando esses serviços aos componentes por meio da injeção de dependência.",
          "Para definir uma classe como um serviço no Angular, use o decorador @Injectable() para fornecer os metadados que permitem ao Angular injetá-lo em um componente como uma dependência.",
          "O injetor é o mecanismo principal. Angular cria um injetor para todo o aplicativo durante o processo de inicialização e injetores adicionais, conforme necessário. Você não precisa criar injetores.",
          "Um injetor cria dependências e mantém um contêiner de instâncias de dependência que reutiliza, se possível. Um provedor é um objeto que informa ao injetor como obter ou criar uma dependência.",
          "Quando o Angular descobre que um componente depende de um serviço, ele primeiro verifica se o injetor possui alguma instância existente desse serviço. Se uma instância de serviço solicitada ainda não existir, o injetor fará uma usando o provedor registrado e a adicionará ao injetor antes de retornar o serviço à Angular.",
          "Quando você fornece o serviço no nível raiz, o Angular cria uma instância única e compartilhada do HeroService e o injeta em qualquer classe que solicitar. O registro do provedor nos metadados @Injectable() também permite que o Angular otimize um aplicativo removendo o serviço da aplicação compilado, se ele não for usado.",
          "Quando você registra um provedor com um NgModule específico, a mesma instância de um serviço está disponível para todos os componentes nesse NgModule. Para se registrar nesse nível, use a propriedade provider do decorador @NgModule().",
          "Ao registrar um provedor no nível do componente, você obtém uma nova instância do serviço com cada nova instância desse componente."
        ]
      }
    },
    "Componentes e Modelos": {
      "Exibindo Dados": {
        "Informações Relevantes": [
          "Componentes angulares formam a estrutura de dados do seu aplicativo. O modelo HTML associado a um componente fornece os meios para exibir esses dados no contexto de uma página da web. Juntos, a classe e o modelo de um componente formam uma visualização dos dados  da aplicação .",
          "O processo de combinar valores de dados com sua representação na página é chamado de ligação de dados. Você exibe seus dados para um usuário (e coleta dados do usuário) vinculando controles no modelo HTML às propriedades de dados da classe de componente.",
          "Você pode adicionar lógica ao modelo incluindo diretivas, que informam ao Angular como modificar a página conforme ela é renderizada.",
          "Angular define uma linguagem de modelo que expande a notação HTML com sintaxe que permite definir vários tipos de ligação de dados e diretivas lógicas. Quando a página é renderizada, Angular interpreta a sintaxe do modelo para atualizar o HTML de acordo com sua lógica e estado atual dos dados."
        ]
      },
      "Sintaxe do Modelo": {
        "Introdução": [
          "O aplicativo Angular gerencia o que o usuário vê e pode fazer, conseguindo isso através da interação de uma instância de classe de componente (o componente) e seu modelo voltado para o usuário.",
          "Em Angular, o componente desempenha o papel do controlador, e o modelo (template) representa a visualização."
        ],
        "HTML como Modelo": [ 
          "HTML é a linguagem do modelo Angular. Quase toda a sintaxe HTML é uma sintaxe de modelo válida. O elemento <script> é uma exceção notável; é proibido, eliminando o risco de ataques de injeção de script. Na prática, <script> é ignorado e um aviso aparece no console do navegador.",
          "Algumas tags não fazem muito sentido em um modelo, os elementos <html>, <body> e <base> não têm função útil, mas todas as tags restantes são uteis.",
          "Você pode estender o vocabulário HTML de seus modelos com componentes e diretivas que aparecem como novos elementos e atributos."
        ],
        "Interpolação": [
          "A interpolação permite incorporar seqüências de caracteres calculados no texto entre as tags de elemento HTML e nas atribuições de atributo. Expressões de modelo são o que você usa para calcular essas strings.",
          "Interpolação refere-se à incorporação de expressões no texto marcado. Por padrão, a interpolação usa como delimitador as chaves duplas, {{ ... }}.",
          "O texto entre os colchetes geralmente é o nome de uma propriedade ou método do componente. Angular substitui esse nome pelo valor da sequência da propriedade do componente correspondente.",
          "Angular avalia todas as expressões entre chaves duplas, converte os resultados da expressão em seqüências de caracteres e as vincula a seqüências literais vizinhas. Por fim, atribui esse resultado interpolado composto a uma propriedade de elemento ou diretiva.",
          "A interpolação é uma sintaxe especial que o Angular converte em uma ligação de propriedade."
        ],
        "Expressão de Modelo": [
          "Uma expressão de modelo produz um valor e aparece dentro das chaves duplas, {{}}. Angular executa a expressão e a atribui a uma propriedade de um destino de ligação; o destino pode ser um elemento HTML, um componente ou uma diretiva.",
          "Na ligação de propriedade, uma expressão de modelo aparece entre aspas à direita do símbolo = como em [property]='expression'.",
          "Em termos de sintaxe, as expressões de modelo são semelhantes ao JavaScript.",
          "Muitas expressões JavaScript são expressões legais de modelo, com algumas exceções: você não pode usar expressões JavaScript que tenham ou promovam efeitos colaterais, incluindo: atribuições (=, + =, - =, etc) ... operadores como new, typeof, instanceof etc. ... encadeando expressões com ; ou , ... operadores de incremento e decremento ++ e - ..."
        ],
        "Contexto de Expressão": [
          "O contexto da expressão é geralmente a instância do componente.",
          "Uma expressão também pode se referir a propriedades do contexto do modelo, como uma variável de entrada do modelo 'let <variavel>', ou uma variável de referência de modelo '#customerInput'.",
          "O contexto para termos em uma expressão é uma mistura das variáveis ​​do modelo, do objeto de contexto da diretiva (se houver) e dos membros do componente. Se você referenciar um nome que pertence a mais de um desses espaços para nome, o nome da variável do modelo terá precedência, seguido por um nome no contexto da diretiva e, por último, os nomes dos membros do componente."
        ],
        "Diretrizes de Expressão": {
          "Simplicidade": [
            "Embora seja possível escrever expressões de modelo complexas, a melhor prática é evitá-las.",
            "Um nome de propriedade ou chamada de método deve ser a norma, mas uma negação booleana ocasional,!, Está OK. Caso contrário, restrinja a lógica de aplicativo e de negócios ao componente, onde é mais fácil desenvolver e testar."
          ],
          "Rápidas Execuções": [
            "Angular executa expressões de modelo após cada ciclo de detecção de alterações - os ciclos de detecção de alterações são acionados por muitas atividades assíncronas, como resoluções de promessas, resultados HTTP, eventos de timer, pressionamentos de teclas e movimentos do mouse.",
            "As expressões devem terminar rapidamente ou a experiência do usuário pode se arrastar, especialmente em dispositivos mais lentos - considere armazenar valores em cache quando o cálculo for caro."
          ],
          "Sem Efeitos Colaterais Visíveis": [
            "Uma expressão de modelo não deve alterar nenhum estado de aplicativo que não seja o valor da propriedade de destino. Essa regra é essencial para a política de 'fluxo de dados unidirecional' do Angular - essa regra é essencial para a política de 'fluxo de dados unidirecional' do Angular.",
            "Você nunca deve se preocupar que a leitura de um valor de componente possa alterar algum outro valor exibido - a visualização deve ser estável ao longo de uma única passagem de renderização.",
            "Uma expressão idempotente é ideal porque é livre de efeitos colaterais e melhora o desempenho da detecção de alterações do Angular.",
            "Em termos do Angular, uma expressão idempotente sempre retorna exatamente a mesma coisa até que um de seus valores dependentes seja alterado.",
            "Os valores dependentes não devem mudar durante uma única volta do loop de eventos.",
            "Se uma expressão idempotente retornar uma sequência ou um número, ela retornará a mesma sequência ou número quando chamada duas vezes seguidas.",
            "Se a expressão retornar um objeto, incluindo uma matriz, retornará a mesma referência de objeto quando chamada duas vezes seguidas."
          ],
          "Instruções de Modelo": [
            "Uma instrução de modelo responde a um evento gerado por um destino de ligação, como um elemento, componente ou diretiva.",
            "Uma declaração de modelo tem um efeito colateral, esse é o objetivo de um evento, é assim que você atualiza o estado da aplicação a partir da ação do usuário.",
            "Responder a eventos é o outro lado do 'fluxo de dados unidirecional' da Angular, você é livre para alterar qualquer coisa, em qualquer lugar, durante essa reviravolta do evento.",
            "Como expressões de modelo, as instruções de modelo usam uma linguagem que se parece com JavaScript, o analisador de instrução de modelo difere do analisador de expressão de modelo e suporta especificamente a atribuição básica (=) e as expressões de encadeamento com ';'."
          ],
          "Contexto da Instrução": [
            "Assim como nas expressões, as instruções podem se referir apenas ao conteúdo do contexto da instrução, como um método de manipulação de eventos da instância do componente.",
            "O contexto da instrução geralmente é a instância do componente, ou seja, metodo() em (click)='metodo()'' é um método do componente vinculado a dados.",
            "O contexto da instrução também pode se referir às propriedades do próprio contexto do modelo.",
            "Os nomes de contexto do modelo têm precedência sobre os nomes de contexto do componente."
          ],
          "Diretrizes de Instrução": [
            "As instruções do modelo não podem se referir a nada no espaço para nome global.",
            "As instruções não podem se referir a 'window' ou 'document'.",
            "As instruções não podem chamar console.log ou Math.max.",
            "Como nas expressões, evite escrever instruções de modelo complexas.",
            "Uma chamada de método ou atribuição simples de propriedade deve ser a norma."
          ],
          "Sintaxe de Ligação": [
            "A ligação de dados é um mecanismo para coordenar o que os usuários veem, especificamente com os valores dos dados  da aplicação .",
            "Embora você possa enviar valores e extrair valores do HTML, o aplicativo é mais fácil de escrever, ler e manter se você entregar essas tarefas para uma estrutura de ligação, você simplesmente declara ligações entre fontes de ligação, direciona elementos HTML e deixa a estrutura fazer o resto.",
            "Os tipos de ligação que não sejam interpolação têm um nome de destino à esquerda do sinal de igual, cercado por pontuação, [] ou() ou precedido por um prefixo: bind-, on-, bindon-.",
            "Em um desenvolvimento normal de HTML, você cria uma estrutura visual com elementos HTML e modifica esses elementos definindo atributos de elemento com constantes de sequência - com a ligação de dados, você pode controlar coisas como o estado de um botão por exemplo.",
            "A ligação de dados funciona com propriedades de elementos, componentes e diretivas DOM, não atributos HTML, isso se aplica à ligação de dados em geral."

          ],
          "Atributo HTML vs. Propriedade DOM": [
            "A distinção entre um atributo HTML e uma propriedade DOM é fundamental para entender como funciona a ligação Angular.",
            "Os atributos são definidos por HTML e as propriedades são acessadas a partir dos nós DOM (Document Object Model).",
            "É importante lembrar que o atributo HTML e a propriedade DOM são coisas diferentes, mesmo quando eles têm o mesmo nome.",
            "No Angular, a única função dos atributos HTML é inicializar o elemento e o estado da diretiva.",
            "A ligação de modelo funciona com propriedades e eventos, não atributos.",
            "Quando você escreve uma ligação de dados, está lidando exclusivamente com as propriedades e eventos do DOM do objeto de destino.",
            "Esta regra geral pode ajudá-lo a construir um modelo mental de atributos e propriedades DOM: Os atributos inicializam as propriedades DOM e, então, elas são concluídas; os valores da propriedade podem mudar; valores de atributo não podem, mas há uma exceção a esta regra: os atributos podem ser alterados por setAttribute(), que reinicializa a propriedade DOM correspondente.",
            {
              "Exemplo 1":[
                "Quando o navegador renderiza <input type='text' value='Sarah'>, ele cria um nó DOM correspondente com uma propriedade de valor inicializada em 'Sarah'.",
                "Quando o usuário digita 'Sally' na <input>, a propriedade value do elemento DOM se torna 'Sally'.",
                "No entanto, se você observar o valor do atributo HTML usando input.getAttribute ('value'), poderá ver que o atributo permanece inalterado - ele retorna 'Sarah'.",
                "O valor do atributo HTML especifica o valor inicial; a propriedade do valor DOM é o valor atual."
              ],
              "Exemplo 2":[
                "O atributo 'disabled' desativado é outro exemplo.",
                "A propriedade 'disabled' de um botão é falsa por padrão, portanto, o botão está ativado.",
                "Quando você adiciona o atributo 'disabled', apenas sua presença inicializa a propriedade desativada do botão para true, para que o botão seja desativado.",
                "Adicionar e remover o atributo 'disabled' desativa e ativa o botão, no entanto, o valor do atributo é irrelevante, e é por isso que você não pode ativar um botão escrevendo <button disabled='false'> ainda desativado </button>.",
                "Para controlar o estado do botão, defina a propriedade desativada,"
              ]
            }
          ],
          "Tipos e Destinos de Ligação": "O alvo de uma ligação de dados é algo no DOM, e dependendo do tipo de ligação, o destino pode ser uma propriedade (elemento, componente ou diretiva), um evento (elemento, componente ou diretiva) ou, às vezes, um nome de atributo.",
          "Ligação de Propriedade": {
            "Descrição": "Use a associação de propriedades para definir propriedades dos elementos de destino ou os decoradores da diretiva @Input().",
            "Unidirecional": [
              "A ligação de propriedade flui um valor em uma direção, da propriedade de um componente para uma propriedade do elemento de destino.",
              "Você não pode usar a associação de propriedades para ler ou extrair valores dos elementos de destino.",
              "Você não pode usar a associação de propriedades para chamar um método no elemento de destino. Se o elemento gerar eventos, você poderá ouvi-los com uma ligação de evento.",
              "Se você precisar ler uma propriedade do elemento de destino ou chamar um de seus métodos, consulte a referência da API para ViewChild e ContentChild."
            ],
            "Evite Efeitos Colaterais":[
              "A avaliação de uma expressão de modelo não deve ter efeitos colaterais visíveis.",
              "A própria linguagem de expressão, ou a maneira como você escreve expressões de modelo, ajuda até certo ponto; você não pode atribuir um valor a nada em uma expressão de ligação de propriedade nem usar os operadores de incremento e decremento.",
              "Por exemplo, você pode ter uma expressão que invoque uma propriedade ou método que tenha efeitos colaterais, a expressão pode chamar algo como getFoo(), onde somente você sabe o que getFoo() faz, Se getFoo() mudar alguma coisa e você estiver vinculando a alguma coisa, Angular poderá ou não exibir o valor alterado.",
              "Como prática recomendada, atenha-se às propriedades e aos métodos que retornam valores e evitam efeitos colaterais.",
              "Angular pode detectar a alteração e gerar um erro de aviso."
            ],
            "Retornar o Tipo Adequado":[
              "A expressão do modelo deve avaliar o tipo de valor que a propriedade de destino espera.",
              "Retorne uma string se a propriedade alvo espera uma string, um número se espera um número, um objeto se espera um objeto e assim por diante."
            ],
            "Vinculação de Propriedade vs Interpolação":[
              "Você geralmente pode escolher entre interpolação e associação de propriedades, os seguintes pares de ligação fazem o mesmo: <p><img src='{{itemImageUrl}}> is the <i>interpolated</i> image.</p> ... ou ... <p><img [src]='itemImageUrl'> is the <i>property bound</i> image.</p>",
              "A interpolação é uma alternativa conveniente à associação de propriedades em muitos casos.",
              "Ao renderizar valores de dados como seqüências de caracteres, não há razão técnica para preferir uma forma à outra, embora a legibilidade tenda a favorecer a interpolação.",
              "Ao definir uma propriedade de elemento como um valor de dados não-string, você deve usar a ligação de propriedade."
            ],
            "Segurança do Counteúdo": [
              "Angular não permite que o HTML com tags de script vaze no navegador, nem com interpolação nem associação de propriedades.",
              "A interpolação lida com as tags <script> de maneira diferente da ligação à propriedade, mas ambas as abordagens tornam o conteúdo inofensivo."
            ]
          },
          "Ligações de Atributo, Classe e Estilo": "https://angular.io/guide/template-syntax#attribute-class-and-style-bindings",
          "Ligação de Evento":{
            "Informações Relevantes":[
              "A associação de eventos permite que você ouça certos eventos, como pressionamentos de teclas, movimentos do mouse, cliques e toques.",
              "A sintaxe de ligação a eventos do Angular consiste em um nome de evento de destino entre parênteses à esquerda de um sinal de igual e uma declaração de modelo entre aspas à direita.",
              "A seguinte ligação de evento escuta os eventos de clique do botão, chamando o método onSave() do componente sempre que um clique ocorre: <button (click)='onSave()'>Save</button>"
            ],
            "$event e Instruções de Manipulação de Evento":[
              "Em uma ligação de evento, o Angular configura um manipulador de eventos para o evento de destino.",
              "Quando o evento é gerado, o manipulador executa a instrução de modelo.",
              "A instrução de modelo geralmente envolve um receptor, que executa uma ação em resposta ao evento, como armazenar um valor do controle HTML em um modelo.",
              "A ligação transmite informações sobre o evento, essas informações podem incluir valores de dados, como um objeto de evento, sequência ou número chamado $event.",
              "O evento de destino determina a forma do objeto $event.",
              "Se o evento de destino for um evento de elemento DOM nativo, $event será um objeto de evento DOM, com propriedades como target e target.value."
            ],
            "Eventos Personalizados com EventEmitter":[
              "As diretivas normalmente geram eventos personalizados com um Angular EventEmitter.",
              "A diretiva cria um EventEmitter e o expõe como uma propriedade.",
              "A diretiva chama 'EventEmitter.emit(payload)' para disparar um evento, transmitindo um payload de mensagem, que pode ser qualquer coisa.",
              "As diretivas pai ouvem o evento vinculando a essa propriedade e acessando a carga através do objeto $event."
            ],
            "Associação Bidirecional":[
              "A associação bidirecional fornece ao seu aplicativo uma maneira de compartilhar dados entre uma classe de componente e seu modelo.",
              "Angular oferece uma sintaxe de ligação de dados bidirecional especial para esse propósito, [()]. A sintaxe [()] combina os colchetes da ligação de propriedade, [], com os parênteses da ligação de evento,().",
              "A sintaxe de ligação bidirecional é uma grande conveniência em comparação com ligações de propriedades e eventos separadas. Seria conveniente usar a ligação bidirecional com elementos de formulário HTML como <input> e <select>. No entanto, nenhum elemento HTML nativo segue o valor x e o padrão de evento xChange."
            ]
          },
          "Diretivas Internas":{
            "Informações Relevantes":[
              "A Angular oferece dois tipos de diretivas internas: diretivas de atributo e diretivas estruturais."
            ],
            "Diretivas de Propriedade":[
              "As diretivas de atributo ouvem e modificam o comportamento de outros elementos, atributos, propriedades e componentes HTML.",
              "Você geralmente os aplica a elementos como se fossem atributos HTML, daí o nome.",
              "Muitos NgModules como o RouterModule e o FormsModule definem suas próprias diretivas de atributo.",
              "As diretivas de atributo mais comuns são as seguintes: NgClass - adiciona e remove um conjunto de classes CSS ; NgStyle - adiciona e remove um conjunto de estilos HTML ; NgModel - adiciona ligação de dados bidirecional a um elemento de formulário HTML."
            ],
            "Diretivas Estruturais":[
              "Diretivas estruturais são responsáveis ​​pelo layout HTML.",
              "Eles moldam ou remodelam a estrutura do DOM, geralmente adicionando, removendo e manipulando os elementos do host aos quais estão anexados.",
              "As diretivas de atributo mais comuns são as seguintes: NgIf - cria ou destrói condicionalmente sub-visualizações do modelo ; NgFor - repita um nó para cada item em uma lista ; NgSwitch - um conjunto de diretivas que alternam entre visualizações alternativas.",
              {
                "NgIf":[
                  "Você pode adicionar ou remover um elemento do DOM aplicando uma diretiva NgIf a um elemento host.",
                  "Quando a expressão isActive retorna um valor de verdade, NgIf adiciona o ItemDetailComponent ao DOM. Quando a expressão é falsa, NgIf remove o ItemDetailComponent do DOM, destruindo esse componente e todos os seus subcomponentes.",
                  "Ocultar um elemento é diferente de removê-lo com NgIf",
                  "Quando você oculta um elemento, esse elemento e todos os seus descendentes permanecem no DOM - todos os componentes para esses elementos permanecem na memória e o Angular pode continuar a verificar alterações, e você pode manter recursos consideráveis ​​de computação e prejudicar o desempenho desnecessariamente.",
                  "NgIf funciona de maneira diferente, quando NgIf é falso, o Angular remove o elemento e seus descendentes do DOM, destrói seus componentes, liberando recursos, o que resulta em uma melhor experiência do usuário.",
                  "Se você estiver ocultando grandes árvores de componentes, considere NgIf como uma alternativa mais eficiente para mostrar/ocultar.",
                  "Outra vantagem do ngIf é que você pode usá-lo para se proteger contra nulos.",
                  "Mostrar/Ocultar é mais adequado para casos de uso muito simples; portanto, quando você precisar de um protetor, opte por ngIf.",
                  "Angular lançará um erro se uma expressão aninhada tentar acessar uma propriedade null."
                ],
                "NgFor":[
                  "NgFor é uma diretiva repetidora - uma maneira de apresentar uma lista de itens.",
                  "Você define um bloco de HTML que define como um único item deve ser exibido e instrui o Angular a usar esse bloco como um modelo para renderizar cada item da lista.",
                  "O texto atribuído a * ngFor é a instrução que guia o processo do repetidor.",
                  "A sequência atribuída a * ngFor não é uma expressão de modelo. Pelo contrário, é uma microssintaxe - uma linguagem própria que o Angular interpreta.",
                  "A sequência 'let item of items' significa: pegue cada item na matriz de itens, armazene-o na variável de loop do item local e disponibilize-o no HTML de modelo para cada iteração.",
                  "Angular converte essa instrução em um <ng-template> em torno do elemento host e, em seguida, usa esse modelo repetidamente para criar um novo conjunto de elementos e ligações para cada item da lista.",
                  { "*ngFor with trackBy": [
                    "Se você usar o NgFor com listas grandes, uma pequena alteração em um item, como remover ou adicionar um item, poderá disparar uma cascata de manipulações do DOM.",
                    "Por exemplo, consultar novamente o servidor poderia redefinir uma lista com todos os novos objetos de itens, mesmo quando esses itens fossem exibidos anteriormente.",
                    "Nesse caso, o Angular vê apenas uma lista atualizada de novas referências a objetos e não tem escolha a não ser substituir os elementos DOM antigos por todos os novos elementos DOM.",
                    "Você pode tornar isso mais eficiente com o trackBy, adicionando um método ao componente que retorne o valor que NgFor deve rastrear.",
                    "Como exemplo de caso, p valor é um ID, se o ID já foi renderizado, o Angular o acompanha e não consulta novamente o servidor para o mesmo ID.",
                    "src/app/app.component.ts -> trackByItems(index: number, item: Item): number { return item.id; }",
                    "src/app/app.component.html -> <div *ngFor='let item of items; trackBy: trackByItems'>({{item.id}}) {{item.name}}</div>"
                    ]
                  }
                ]
              }
            ],
            "Diretivas NgSwitch":[
              "NgSwitch é como a declaração de opção JavaScript.",
              "Ele exibe um elemento dentre vários elementos possíveis, com base em uma condição de chave.",
              "O Angular coloca apenas o elemento selecionado no DOM.",
              "NgSwitch é na verdade um conjunto de três diretivas cooperativas: NgSwitch, NgSwitchCase e NgSwitchDefault, como no exemplo a seguir.",
              "NgSwitch é a diretiva do controlador. Ligue-o a uma expressão que retorne o valor da opção, como recurso.",
              "Vinculu-se a [ngSwitch] - você receberá um erro se tentar definir * ngSwitch porque NgSwitch é uma diretiva de atributo, não uma diretiva estrutural. Em vez de tocar diretamente no DOM, ele altera o comportamento de suas diretrizes complementares.",
              "Vincule-se a * ngSwitchCase e * ngSwitchDefault - as diretivas NgSwitchCase e NgSwitchDefault são diretivas estruturais porque adicionam ou removem elementos do DOM.",
              "NgSwitchCase adiciona seu elemento ao DOM quando seu valor limite é igual ao valor do comutador e remove seu valor limite quando não é igual ao valor do comutador.",
              "NgSwitchDefault adiciona seu elemento ao DOM quando não há NgSwitchCase selecionado."
            ]
          },
          "Variáveis ​​de Referência do Modelo":[
            "Uma variável de referência de modelo geralmente é uma referência a um elemento DOM dentro de um modelo, mas também pode se referir a uma diretiva (que contém um componente), um elemento, TemplateRef ou um componente da web.",
            "Use o símbolo de hash (#) para declarar uma variável de referência , a seguinte variável de referência, #phone, declara uma variável de telefone em um elemento <input> ... <input #phone placeholder='phone number' />",
            "Você pode consultar uma variável de referência de modelo em qualquer lugar no modelo do componente.",
            "Uma variável de referência de modelo (#phone) não é a mesma que uma variável de entrada de modelo (let phone), como em um * ngFor. Veja Diretivas Estruturais para mais informações. O escopo de uma variável de referência é o modelo inteiro.",
            "Não defina o mesmo nome de variável mais de uma vez no mesmo modelo, pois o valor do tempo de execução será imprevisível."
          ],
          "Propriedades de @Input() e @Output()":[
            "Ambas permitem que o Angular compartilhe dados entre o contexto pai e as diretivas ou componentes filhos.",
            "Uma propriedade @Input() é gravável enquanto uma propriedade @Output() é observável.",
            "Ambas atuam como a API, ou interface de programação de aplicativos, do componente filho, na medida em que permitem que o filho se comunique com o pai.",
            "Pense em @Input() e @Output() como portas ou portas - @ Input() é a porta de entrada do componente, permitindo que os dados fluam enquanto @Output() é a porta de saída do componente, permitindo que o componente filho envie saída de dados.",
            "@Output() marca uma propriedade em um componente filho como uma porta através da qual os dados podem viajar do filho para o pai. O componente filho precisa gerar um evento para que o pai saiba que algo mudou.",
            "Para gerar um evento, @Output() trabalha em conjunto com EventEmitter, que é uma classe em @ angular / core que você usa para emitir eventos personalizados."
          ],
          "Operadores de Expressão de Modelo":{
            "Operadores": "A linguagem de expressão de modelo angular emprega um subconjunto de sintaxe JavaScript suplementado com alguns operadores especiais para cenários específicos: pipe, safe navigation operator, non-null assertion operator.",
            "Pipe Operator":[
              "O resultado de uma expressão pode exigir alguma transformação antes de você estar pronto para usá-lo em uma ligação.",
              "Por exemplo, você pode exibir um número como moeda, alterar o texto para maiúscula ou filtrar uma lista e classificá-la.",
              "Pipes são funções simples que aceitam um valor de entrada e retornam um valor transformado.",
              "Eles são fáceis de aplicar em expressões de modelo, usando o operador de pipe (|).",
              "O operador de pipe passa o resultado de uma expressão à esquerda para uma função de pipe à direita.",
              "Você pode encadear expressões através de vários pipes e também pode aplicar parâmetros caso necessário.",
              "O operador do tubo tem uma precedência mais alta que o operador ternário (? :), o que significa a? b: c | x é analisado como a? b: (c | x).",
              "No entanto, por várias razões, o operador do tubo não pode ser usado sem parênteses no primeiro e no segundo operandos de (? :) - uma boa prática é usar parênteses no terceiro operando também."
            ],
            "Safe Navigation Operator":[
              "O operador de navegação segura do Angular '?', protege contra valores nulos e indefinidos nos caminhos da propriedade.",
              "Ele protege contra uma falha de renderização de exibição se o item for nulo.",
              "Se o item for nulo, a exibição ainda é renderizada, mas o valor exibido estará em branco.",
              "Às vezes, porém, valores nulos no caminho da propriedade podem estar OK em determinadas circunstâncias, especialmente quando o valor inicia nulo, mas os dados chegam eventualmente.",
              "Com o operador de navegação segura, o Angular para de avaliar a expressão quando atinge o primeiro valor nulo e renderiza a exibição sem erros.",
              "Funciona perfeitamente com caminhos de propriedade longos, como um  a?.b?.c?.d?."
            ],
            "Non-Null Assertion Operator":[
              "A partir do Typecript 2.0, você pode aplicar uma verificação nula estrita com o sinalizador --strictNullChecks.",
              "O TypeScript garante que nenhuma variável seja involuntariamente nula ou indefinida.",
              "Nesse modo, as variáveis ​​digitadas não permitem nulo e indefinido por padrão.",
              "O verificador de tipos gera um erro se você deixar uma variável não atribuída ou tentar atribuir nulo ou indefinido a uma variável cujo tipo não permite nulo e indefinido.",
              "O verificador de tipos também gera um erro se não puder determinar se uma variável será nula ou indefinida em tempo de execução.",
              "Você diz ao verificador de tipos para não gerar um erro aplicando o operador de asserção não nula do postfix (!).",
              "O operador de asserção Angular não nula, serve ao mesmo objetivo em um modelo Angular, por exemplo: você pode afirmar que as propriedades do item também estão definidas.",
              "Ao contrário do operador de navegação segura, o operador de asserção não nula não protege contra nula ou indefinida, em vez disso, ele instrui o verificador de tipo TypeScript a suspender verificações nulas estritas para uma expressão de propriedade específica.",
              "O operador de asserção não nula, é opcional, com a exceção de que você deve usá-lo quando ativar verificações nulas estritas."
            ]
          }
        }
      },
      "Entrada do Usuário":{
        "Informações Relevantes":[
          "Ações do usuário, como clicar em um link, pressionar um botão e inserir texto, aumentam os eventos DOM."
        ],
        "Vinculação a Eventos":[
          "Você pode usar ligações de eventos angulares para responder a qualquer evento DOM.",
          "Muitos eventos DOM são acionados pela entrada do usuário.",
          "A associação a esses eventos fornece uma maneira de obter informações do usuário.",
          "Para vincular a um evento DOM, coloque o nome do evento DOM entre parênteses e atribua uma instrução de modelo entre aspas.",
          "Em <button (click)='onClickMe()'> Clique em mim! </button> : o (click) à esquerda do sinal de igual identifica o evento de clique do botão como o destino da ligação, e o texto entre aspas à direita do sinal de igual é a instrução do modelo, que responde ao evento click chamando o método onClickMe do componente.",
          "Ao escrever uma ligação, esteja ciente do contexto de execução de uma instrução de modelo, os identificadores em uma instrução de modelo pertencem a um objeto de contexto específico, geralmente o componente Angular que controla o modelo."
        ],
        "Objeto $event":[
          "Eventos DOM carregam uma carga útil de informações que podem ser úteis para o componente.",
          "O código <input (keyup)='onKey($event)'> : escuta o evento keyup e passa toda a carga útil do evento ($event) para o manipulador de eventos do componente.",
          "As propriedades de um objeto $event variam dependendo do tipo de evento DOM, por exemplo: um evento de mouse inclui informações diferentes de um evento de edição da caixa de entrada.",
          "Todos os objetos de evento DOM padrão têm uma propriedade de destino, uma referência ao elemento que gerou o evento - por exemplo: o destino refere-se ao elemento <input> e event.target.value retorna o conteúdo atual desse elemento.",
          {
            "Especificando $event":[
              "Especificar o objeto de evento revela uma objeção significativa à passagem de todo o evento DOM para o método: o componente tem muito conhecimento dos detalhes do modelo.",
              "Ele não pode extrair informações sem saber mais do que deveria sobre a implementação do HTML.",
              "Isso quebra a separação de preocupações entre o modelo (o que o usuário vê) e o componente (como o aplicativo processa os dados do usuário)."
            ]
          }
        ],
        "Variáveis de Referência de Modelo":[
          "Para declarar uma variável de referência de modelo, preceda um identificador com um caractere de hash (ou libra) (#), por exemplo: <input #box (keyup)='onKey(box.value)'>",
          "Use variáveis ​​de referência de modelo angular, essas variáveis ​​fornecem acesso direto a um elemento de dentro do modelo.",
          "É mais fácil chegar à caixa de entrada com a variável de referência do modelo do que passar pelo objeto $event."
        ],
        "Filtragem de Eventos":[
          "O manipulador de eventos (keyup) ouve cada pressionamento de tecla.",
          "Às vezes, apenas a tecla Enter é importante, porque indica que o usuário terminou de digitar.",
          "Uma maneira de reduzir o ruído seria examinar todos os $ event.keyCode e executar uma ação somente quando a chave for Enter.",
          "Existe uma maneira mais fácil: vincular-se ao pseudo-evento keyup.enter do Angular, por exemplo: <input #box (keyup.enter)='onEnter(box.value)''>",
          "O Angular chama o manipulador de eventos apenas quando o usuário pressiona Enter."
        ],
        "Considerações Importantes":[
          "Use variáveis ​​de modelo para se referir a elementos.",
          "Passe valores, não elementos",
          "Mantenha as instruções do modelo simples"
        ]
      },
      "Angular Elements": {
        "O que é ?": "São componentes angulares empacotados como elementos personalizados (também chamados de Web Components), um padrão da Web para definir novos elementos HTML de uma maneira independente da estrutura.",
        "Visão Geral":[
          "Angular Elements basicamente funciona como uma ponte entre as APIs do browser e as diversas funcionalidades providas pelo Angular.",
          "Os elementos personalizados são um recurso da plataforma da Web atualmente suportado pelo Chrome, Edge (baseado no Chromium), Firefox, Opera e Safari, e estão disponíveis em outros navegadores através de polyfills.",
          "Um elemento personalizado estende o HTML, permitindo definir uma tag cujo conteúdo é criado e controlado pelo código JavaScript.",
          "O navegador mantém um CustomElementRegistry de elementos personalizados definidos, que mapeia uma classe JavaScript instável para uma tag HTML.",
          "O pacote '@angular/elements' exporta uma API createCustomElement() que fornece uma ponte da interface do componente do Angular e altera a funcionalidade de detecção para a API DOM interna.",
          "A transformação de um componente em um elemento personalizado disponibiliza toda a infraestrutura Angular necessária para o navegador.",
          "Criar um elemento personalizado é simples e direto e conecta automaticamente sua visualização definida por componente com detecção de alterações e ligação de dados, mapeando a funcionalidade Angular aos equivalentes HTML nativos correspondentes."
        ],
        "Usando Angular Elements":[
          "Os elementos personalizados se autoinicializam - eles iniciam automaticamente quando são adicionados ao DOM e são destruídos automaticamente quando removidos do DOM.",
          "Depois que um elemento personalizado é adicionado ao DOM para qualquer página, ele se parece e se comporta como qualquer outro elemento HTML e não requer nenhum conhecimento especial de termos angulares ou convenções de uso.",
          {
            "Conteúdos Dinamicos com Facilidade":[
              "A transformação de um componente em um elemento personalizado fornece um caminho fácil para a criação de conteúdo HTML dinâmico no aplicativo Angular.",
              "O conteúdo HTML que você adiciona diretamente ao DOM em um aplicativo Angular é normalmente exibido sem processamento Angular, a menos que você defina um componente dinâmico, adicione seu próprio código para conectar a tag HTML aos dados do aplicativo e participe da detecção de alterações - com um elemento personalizado, toda essa fiação é tratada automaticamente."
            ],
            "Apps Ricos em Contéudo":[
              "Se você possui um aplicativo rico em conteúdo, os elementos personalizados permitem que você ofereça aos provedores de conteúdo uma funcionalidade Angular sofisticada sem exigir o conhecimento de Angular.",
              "Por exemplo, um guia Angular é adicionado diretamente ao DOM pelas ferramentas de navegação Angular, mas pode incluir elementos especiais como <code-snippet> que executam operações complexas.",
              "Tudo o que você precisa dizer ao seu provedor de conteúdo é a sintaxe do seu elemento personalizado, eles não precisam saber nada sobre o Angular ou sobre a estrutura ou implementação de dados do seu componente."
            ]
          }
        ],
        "Como Funciona ?":[
          "Use a função createCustomElement() para converter um componente em uma classe que pode ser registrada no navegador como um elemento personalizado.",
          "Depois de registrar sua classe configurada no registro de elementos personalizados do navegador, você pode usar o novo elemento como um elemento HTML interno no conteúdo adicionado diretamente no DOM: <my-popup message='Use Angular!'></my-popup>",
          "Quando seu elemento personalizado é colocado em uma página, o navegador cria uma instância da classe registrada e a adiciona ao DOM.",
          "O conteúdo é fornecido pelo modelo do componente, que usa a sintaxe do modelo angular, e é renderizado usando o componente e os dados DOM.",
          "As propriedades de entrada no componente correspondem aos atributos de entrada para o elemento.",
          "Fluxograma: https://angular.io/generated/images/guide/elements/customElement1.png"
        ],
        "Conversão":[
          "Angular fornece a função createCustomElement() para converter um componente Angular, juntamente com suas dependências, em um elemento personalizado.",
          "A função coleta as propriedades observáveis ​​do componente, juntamente com a funcionalidade Angular de que o navegador precisa para criar e destruir instâncias, além de detectar e responder a alterações.",
          "O processo de conversão implementa a interface NgElementConstructor e cria uma classe de construtor configurada para produzir uma instância de autoinicialização do seu componente.",
          "Use uma função JavaScript, customElements.define(), para registrar o construtor configurado e sua tag de elemento personalizado associada ao CustomElementRegistry do navegador.",
          "Quando o navegador encontra a tag do elemento registrado, ele usa o construtor para criar uma instância de elemento personalizado.",
          "Fluxograma: https://angular.io/generated/images/guide/elements/createElement.png"
        ],
        "Mapeamento":[
          "Um elemento personalizado hospeda um componente Angular, fornecendo uma ponte entre os dados e a lógica definidos no componente e nas APIs DOM padrão, propriedades de componentes e mapas lógicos diretamente nos atributos HTML e no sistema de eventos do navegador.",
          "A API de criação analisa o componente procurando propriedades de entrada e define os atributos correspondentes para o elemento customizado.",
          "Ele transforma os nomes de propriedades para torná-los compatíveis com elementos personalizados, que não reconhecem distinções entre maiúsculas e minúsculas.",
          "Os nomes de atributo resultantes usam letras minúsculas separadas por traço : por exemplo, para um componente contendo como propriedade  '@Input('myInputProp') inputProp', o elemento personalizado correspondente define um atributo 'my-input-prop'.",
          "As saídas de componentes são despachadas como Eventos Customizados em HTML, com o nome do evento personalizado correspondente ao nome da saída.",
          "Para um componente contendo como propriedaed '@Output() valueChanged = new EventEmitter()', o elemento personalizado correspondente enviará eventos com o nome 'valueChanged' e os dados emitidos serão armazenados na propriedade de detalhes do evento.",
          "Se você fornecer um alias, esse valor será usado, por exemplo: '@Output ('myClick') clicks = new EventEmitter <string>()' resulta em eventos de despacho com o nome 'myClick'."
        ],
        "Suporte dos Navegadores":[
          "Em navegadores que suportam elementos personalizados de forma nativa, a especificação exige que os desenvolvedores usem as classes ES2015 para definir os Elementos Personalizados - os desenvolvedores podem optar por isso definindo a propriedade target: 'es2015' no tsconfig.json do projeto.",
          "Como o suporte a Elemento personalizado e ES2015 pode não estar disponível em todos os navegadores, os desenvolvedores podem optar por usar um polyfill para oferecer suporte a navegadores mais antigos e código ES5.",
          "Use a CLI Angular para configurar automaticamente seu projeto com o polyfill correto: 'ng add @angular/elements --name=*your_project_name*'."
        ],
        "Exemplificação":[
          "Anteriormente, quando você queria adicionar um componente a um aplicativo em tempo de execução, precisava definir um componente dinâmico.",
          "O módulo do aplicativo precisaria listar seu componente dinâmico em entryComponents, para que o aplicativo não esperasse que ele estivesse presente na inicialização e, então, seria necessário carregá-lo, anexá-lo a um elemento no DOM e conectar todos os componentes nas dependências, detecção de alterações e manipulação de eventos.",
          "O uso de um elemento personalizado Angular torna o processo muito mais simples e transparente, fornecendo toda a infraestrutura e estrutura automaticamente - tudo o que você precisa fazer é definir o tipo de manipulação de eventos que você deseja (você ainda precisa excluir o componente da compilação, se não for usá-lo no seu aplicativo).",
          {
            "Aplicativo de Exemplo": [
              "O App Serviço Pop-up (https://angular.io/generated/live-examples/elements/stackblitz.html) define um componente que você pode carregar dinamicamente ou converter em um elemento personalizado.",
              {
                "popup.component.ts": "define um elemento pop-up simples que exibe uma mensagem de entrada, com alguma animação e estilo.",
                "popup.service.ts": "cria um serviço injetável que fornece duas maneiras diferentes de chamar o PopupComponent; como um componente dinâmico ou como um elemento personalizado, observe quanto mais configuração é necessária para o método de carregamento dinâmico.",
                "app.module.ts": " adiciona o PopupComponent na lista entryComponents do módulo, para excluí-lo da compilação e evitar avisos ou erros de inicialização.",
                "app.component.ts": "define o componente raiz do aplicativo, que usa o PopupService para adicionar o pop-up ao DOM no tempo de execução, quando o aplicativo é executado, o construtor do componente raiz converte PopupComponent em um elemento personalizado."
              }
            ],
            "Artigo de App como Exemplo": "https://dev.to/wilmarques/angular-elements-implementacao-basica-48lk"
          }
        ],
        "Tipologias para 'Custom Elements'":[
          "APIs DOM genéricas, como document.createElement() ou document.querySelector(), retornam um tipo de elemento apropriado para os argumentos especificados.",
          "Por exemplo: chamar document.createElement('a') retornará um HTMLAnchorElement, que o TypeScript sabe que possui uma propriedade href, da mesma forma: chamar document.createElement('div') retornará um HTMLDivElement, que o TypeScript sabe que não possui propriedade href.",
          "Quando chamados com elementos desconhecidos, como um nome de elemento personalizado, os métodos retornarão um tipo genérico, como HTMLElement, pois o TypeScript não pode inferir o tipo correto do elemento retornado.",
          "Os elementos personalizados criados com Angular estendem NgElement (que por sua vez estende HTMLElement), esses elementos personalizados terão uma propriedade para cada entrada do componente correspondente.",
          "Existem algumas opções se você deseja obter tipos corretos para seus elementos personalizados: a maneira mais direta de obter tipografias precisas é converter o valor de retorno dos métodos DOM relevantes no tipo correto, para isso, você pode usar os tipos NgElement e WithProperties (ambos exportados de '@angular/elements').",
          {
            "Code": {
              "1": "const aDialog = document.createElement('my-dialog') as NgElement & WithProperties<{content: string}>;",
              "2": "aDialog.content = 'Hello, world!';",
              "3": "aDialog.content = 123;  // <-- ERROR: TypeScript knows this should be a string.",
              "4": "aDialog.body = 'News';  // <-- ERROR: TypeScript knows there is no `body` property on `aDialog`."
            },
            "Info": "Essa é uma boa maneira de obter rapidamente os recursos do TypeScript, como verificação de tipo e suporte ao preenchimento automático, para seu elemento personalizado, mas pode ficar complicado se você precisar em vários lugares, porque é necessário converter o tipo de retorno em cada ocorrência."
          }
        ]
      },
      "Pipes": {
        "Informações Relevantes":[
          "Todo aplicativo começa com o que parece ser uma tarefa simples: obter dados, transformá-los e mostrá-los aos usuários.",
          "Obter dados pode ser tão simples quanto criar uma variável local ou tão complexo quanto transmitir dados por um WebSocket.",
          "Depois que os dados chegam, você pode enviar os valores brutos de toString diretamente para a exibição, mas isso raramente contribui para uma boa experiência do usuário.",
          "Na maioria dos casos de uso, os usuários preferem ver uma data em um formato simples, como 15 de abril de 1988, em vez do formato de sequência bruta Sex Abr 15 1988 00:00:00 GMT-0700 (Horário de verão do Pacífico).",
          "Um tubo recebe os dados como entrada e os transforma na saída desejada.",
          "Dentro da expressão de interpolação, você flui o valor da variavel do componente através do operador de pipe  '|' para a função localizada à direita.",
          "Angular vem com um estoque de pipes, como DatePipe, UpperCasePipe, LowerCasePipe, CurrencyPipe e PercentPipe, estão todos disponíveis para uso em qualquer modelo.",
          "Você pode encadear tubos juntos em combinações potencialmente úteis.",
          "Você pode escrever seus próprios tubos personalizados."
        ],
        "Parametrizando um Pipe":[
          "Um pipe pode aceitar qualquer número de parâmetros opcionais para ajustar sua saída.",
          "Para adicionar parâmetros a um pipe, coloque na frente do nome dois pontos (:) e, em seguida, o valor do parâmetro (seu_pipe:parâmetro), se o pipe aceitar vários parâmetros, separe os valores com dois pontos (seu_pipe:param1:param2 ...)",
          "O valor do parâmetro pode ser qualquer expressão de modelo válida, como uma literal de cadeia ou uma propriedade de componente."
        ],
        "Pipes Personalizados":[
          "Um Pipe é uma classe decorada com metadados de canal.",
          "A classe pipe implementa o método de transformação da interface PipeTransform que aceita um valor de entrada seguido por parâmetros opcionais e retorna o valor transformado.",
          "Haverá um argumento adicional para o método de transformação para cada parâmetro passado para o canal.",
          "Para informar ao Angular que a classe é um Pipe, aplique o decorador @Pipe, importado da biblioteca Angular principal.",
          "O decorador @Pipe permite definir o nome do canal que você usará nas expressões de modelo, ele deve ser um identificador JavaScript válido.",
          "Você usa seu pipe personalizado da mesma maneira que usa tubos internos.",
          "Você deve incluir seu pipe na matriz de declarações do AppModule.",
          "Se você optar por injetar seu pipe em uma classe, deverá fornecê-lo na matriz de fornecedores do seu NgModule.",
          "Você deve registrar pipes personalizados, caso contrário, o Angular relata um erro, e o gerador da CLI Angular registra o tubo automaticamente."
        ],
        "Detecção de Alterações":[
          "O Angular procura alterações nos valores vinculados aos dados por meio de um processo de detecção de alterações que é executado após cada evento do DOM: cada pressionamento de tecla, movimentação do mouse, tique do timer e resposta do servidor, e isso pode ser caro.",
          "O Angular se esforça para reduzir o custo sempre que possível e apropriado.",
          "O Angular escolhe um algoritmo de detecção de alterações mais simples e rápido quando você usa um pipe."
        ],
        "Categorias de Tupos":{
          "Pipes Puros":[
            "Angular executa um pipe puro somente quando detecta uma alteração pura no valor de entrada.",
            "Uma mudança pura é uma alteração em um valor de entrada primitivo (String, Number, Boolean, Symbol) ou uma referência de objeto alterada (Data, Matriz, Função, Objeto).",
            "Angular ignora alterações dentro de objetos (compostos), ou seja, não chamará um canal puro se você alterar um mês de entrada, adicionar a uma matriz de entrada ou atualizar uma propriedade do objeto de entrada.",
            "Isso pode parecer restritivo, mas também rápido, pois uma verificação de referência de objeto é rápida - muito mais rápida que uma verificação profunda de diferenças - para que o Angular possa determinar rapidamente se pode pular a execução do pipe e uma atualização de exibição.",
            "Por esse motivo, é preferível um canal puro quando você pode conviver com a estratégia de detecção de alterações - quando você não pode, pode usar o tubo impuro."
          ],
          "Pipes Impuros":[
            "Angular executa um tubo impuro durante cada ciclo de detecção de alterações de componentes.",
            "Um tubo impuro é chamado com freqüência, com a mesma frequência de cada pressionamento de tecla ou movimento do mouse.",
            "Com essa preocupação em mente, implemente um tubo impuro com muito cuidado.",
            "Um tubo caro e de longa execução pode destruir a experiência do usuário.",
            "O Angular AsyncPipe é um exemplo interessante de um tubo impuro.",
            "O AsyncPipe aceita Promise ou Observable como entrada e assina a entrada automaticamente, retornando eventualmente os valores emitidos.",
            "O AsyncPipe também é estável, o pipe mantém uma assinatura da entrada Observable e continua entregando valores a partir desse Observable à medida que eles chegam."
          ]
        }

      }
    },
    "Formulários": {
      "Introdução": {
        "Informações Relevantes": [
          "Angular fornece duas abordagens diferentes para lidar com a entrada do usuário por meio de formulários: reativo e orientado a modelo.",
          "Ambos os paradigmas capturam eventos de entrada do usuário a partir da visualização, validam a entrada do usuário, criam um modelo de formulário e um modelo de dados para atualizar e fornecem uma maneira de rastrear alterações",
          "Formulários reativos e controlados por modelo processam e gerenciam dados de formulário de maneira diferente. Cada um oferece vantagens diferentes.",
          "As formas reativas são mais robustas: são mais escaláveis, reutilizáveis ​​e testáveis. Se os formulários são uma parte essencial do seu aplicativo, ou você já está usando padrões reativos para criar seu aplicativo, use formulários reativos.",
          "Formulários controlados por modelo são úteis para adicionar um formulário simples a um aplicativo, como um formulário de inscrição na lista de e-mails. Eles são fáceis de adicionar a um aplicativo, mas não são dimensionados tão bem quanto em formas reativas. Se você possui requisitos e lógica de formulário muito básicos que podem ser gerenciados apenas no modelo, use formulários controlados por modelo"
        ],
        "Fluxo de Dados": [
          "Os formulários reativos e controlados por modelo seguem duas estratégias diferentes ao manipular a entrada de formulário.",
          "nas formas reativas, cada elemento do formulário na exibição é diretamente vinculado a um modelo de formulário (instância do FormControl). As atualizações da visualização para o modelo e do modelo para a visualização são síncronas e não dependem da interface do usuário renderizada.",
          "Nos formulários controlados por modelo, cada elemento do formulário está vinculado a uma diretiva que gerencia o modelo de formulário internamente."
        ],
        "Validação": [
          "O Angular fornece um conjunto de validadores internos, além da capacidade de criar validadores personalizados.",
          "Os formulários reativos definem validadores personalizados como funções que recebem um controle para validar.",
          "Os formulários controlados por modelo estão vinculados às diretivas de modelo e devem fornecer diretivas de validador personalizadas que agrupam as funções de validação."
        ],
        "Testes": [
          "O teste desempenha um papel importante em aplicativos complexos e uma estratégia de teste mais simples é útil ao validar se seus formulários funcionam corretamente.",
          "Formulários reativos e formulários controlados por modelo têm diferentes níveis de confiança na renderização da interface do usuário para executar asserções com base no controle de formulário e alterações no campo de formulário.",
          "Os formulários reativos fornecem uma estratégia de teste relativamente fácil, porque fornecem acesso síncrono ao formulário e aos modelos de dados e podem ser testados sem renderizar a interface do usuário. Nesses testes, status e dados são consultados e manipulados através do controle sem interagir com o ciclo de detecção de alterações.",
          "A gravação de testes com formulários orientados a modelos requer um conhecimento detalhado do processo de detecção de alterações e um entendimento de como as diretivas são executadas em cada ciclo para garantir que os elementos sejam consultados, testados ou alterados no momento correto."
        ],
        "Mutabilidade": {
          "Reativo": [
            "Os formulários reativos mantêm o modelo de dados puro, fornecendo-o como uma estrutura de dados imutável.",
            "Sempre que uma alteração é acionada no modelo de dados, a instância FormControl retorna um novo modelo de dados em vez de atualizar o modelo de dados existente.",
            "Permite rastrear alterações exclusivas no modelo de dados através da observação do controle.",
            "Fornece uma maneira de a detecção de alterações ser mais eficiente, porque ela só precisa atualizar as alterações exclusivas.",
            "Segue padrões reativos que se integram aos operadores observáveis ​​para transformar dados.",
            "Com formulários reativos, a instância FormControl sempre retorna um novo valor quando o valor do controle é atualizado."
          ],
          "Orientado a Modelos": [
            "Os formulários controlados por modelo dependem da mutabilidade com ligação de dados bidirecional para atualizar o modelo de dados no componente conforme as alterações são feitas no modelo.",
            "Como não há alterações exclusivas a serem rastreadas no modelo de dados ao usar a ligação de dados bidirecional, a detecção de alterações é menos eficiente na determinação de quando são necessárias atualizações.",
            "Com formulários controlados por modelo, a propriedade de cor favorita é sempre modificada para seu novo valor."
          ]
        },
        "Escalabilidade": [
          "Os formulários reativos fornecem acesso a APIs de baixo nível e acesso síncrono ao modelo de formulário, facilitando a criação de formulários em grande escala.",
          "Os formulários orientados a modelos concentram-se em cenários simples, não são tão reutilizáveis, abstraem as APIs de baixo nível e fornecem acesso assíncrono ao modelo de formulário.",
          "A abstração com formulários controlados por modelo também aparece no teste, onde o teste de formulários reativos requer menos configuração e nenhuma dependência do ciclo de detecção de alterações ao atualizar e validar o formulário e os modelos de dados durante o teste."
        ],
        "Considerações Relevantes": [
          "A escolha de uma estratégia começa com a compreensão dos pontos fortes e fracos das opções apresentadas.",
          "Acesso de API de baixo nível e modelo de formulário, previsibilidade, mutabilidade, estratégias diretas de validação e teste e escalabilidade são considerações importantes na escolha da infraestrutura que você usa para criar seus formulários no Angular.",
          "Os formulários controlados por modelo são semelhantes aos padrões no AngularJS, mas têm limitações, devido aos critérios de muitos aplicativos Angular modernos em grande escala.",
          "As formas reativas integram-se aos padrões reativos já presentes em outras áreas da arquitetura Angular e complementam bem esses requisitos."
        ]
      },
      "Formulários Reativos":{
        "Visão Geral":[
          "Os formulários reativos fornecem uma abordagem orientada a modelo para lidar com entradas de formulário cujos valores mudam ao longo do tempo.",
          "Os formulários reativos usam uma abordagem explícita e imutável para gerenciar o estado de um formulário em um determinado momento.",
          "Cada alteração no estado do formulário retorna um novo estado, que mantém a integridade do modelo entre as alterações.",
          "Os formulários reativos são construídos em torno de fluxos observáveis, nos quais as entradas e os valores do formulário são fornecidos como fluxos de valores de entrada, que podem ser acessados ​​de forma síncrona.",
          "Os formulários reativos também fornecem um caminho direto para o teste, porque você tem certeza de que seus dados são consistentes e previsíveis quando solicitados, qualquer consumidor dos fluxos tem acesso para manipular esses dados com segurança.",
          "Os formulários reativos diferem dos formulários orientados a modelos de maneiras distintas.",
          "Os formulários reativos fornecem mais previsibilidade com acesso síncrono ao modelo de dados, imutabilidade com operadores observáveis ​​e rastreamento de alterações através de fluxos observáveis.",
          "Formulários controlados por modelo permitem acesso direto para modificar dados em seu modelo, mas são menos explícitos que formulários reativos, porque eles dependem de diretivas incorporadas no modelo, juntamente com dados mutáveis ​​para rastrear alterações de forma assíncrona",
        ],
        "Controle de Formulários": {
          "Descrição": "Há três etapas para usar controles de formulário.",
          "Etapas": {
            "1": "Registre o módulo de formulários reativos no seu aplicativo, este módulo declara as diretivas de forma reativa que você precisa para usar formulários reativos.",
            "2": "Gere uma nova instância do FormControl e salve-a no componente.",
            "3": "Registre o FormControl no modelo."
          },
          "Procedimentos":{
            "Registrar o Módulo": [
              "Para usar controles de formulário reativos, importe ReactiveFormsModule do pacote '@angular/forms' e adicione-o à matriz de importações do NgModule."
            ],
            "Gere o FormControl":[
              "Use o comando da CLI ng generate para gerar um componente em seu projeto para hospedar o controle.",
              "Para registrar um único controle de formulário, importe a classe FormControl e crie uma nova instância do FormControl para salvar como uma propriedade de classe.",
              "Use o construtor de FormControl para definir seu valor inicial, que nesse caso é uma sequência vazia.",    
              "Ao criar esses controles em sua classe de componente, você obtém acesso imediato para escutar, atualizar e validar o estado da entrada do formulário."
            ],
            "Registre o FormControl no Modelo":[
              "Depois de criar o controle na classe de componente, você deve associá-lo a um elemento de controle de formulário no modelo.",
              "Atualize o modelo com o controle de formulário usando a ligação formControl fornecida pelo FormControlDirective, que também está incluída no ReactiveFormsModule.",
              "Usando a sintaxe de ligação do modelo, o controle de formulário agora está registrado no elemento de entrada de nome no modelo.",
              "O controle de formulário e o elemento DOM se comunicam entre si: a visualização reflete alterações no modelo e o modelo reflete alterações na visualização."
            ],
            "Exibir o Componente": [
              "Você pode exibir o formulário adicionando o componente ao modelo.",
              "O controle de formulário atribuído a propriedade é exibido quando o componente é adicionado a um modelo."
            ]
          }
        },
        "Exibindo Valores":{
          "Maneiras de Exibição":{
            "1": "Por meio do valueChanges observável, onde você pode ouvir as alterações no valor do formulário no modelo usando AsyncPipe ou na classe de componente usando o método subscribe().",
            "2": "Com a propriedade value, que fornece uma captura instantânea do valor atual."
          },
          "Informações Relevantes":[
            "O valor exibido muda conforme você atualiza o elemento de controle do formulário.",
            "Os formulários reativos fornecem acesso a informações sobre um determinado controle por meio de propriedades e métodos fornecidos com cada instância.",
            "Essas propriedades e métodos da classe AbstractControl subjacente são usados ​​para controlar o estado do formulário e determinar quando exibir mensagens ao manipular a validação de entrada."
          ]
        },
        "Substituindo Valores":[
          "Os formulários reativos têm métodos para alterar o valor de um controle programaticamente, o que oferece flexibilidade para atualizar o valor sem a interação do usuário.",
          "Uma instância de controle de formulário fornece um método setValue() que atualiza o valor do controle de formulário e valida a estrutura do valor fornecido em relação à estrutura do controle.",
          "Por exemplo, ao recuperar dados de formulário de uma API ou serviço de back-end, use o método setValue() para atualizar o controle para seu novo valor, substituindo completamente o valor antigo."
        ],
        "Agrupamento de Controle":{
          "Informações Relevantes":[
            "Os formulários geralmente contêm vários controles relacionados.",
            "Os formulários reativos fornecem duas maneiras de agrupar vários controles relacionados em um único formulário de entrada.",
            {
              "Maneiras":{
                "Por Grupo": "Um grupo de formulários define um formulário com um conjunto fixo de controles que você pode gerenciar juntos - você também pode aninhar grupos de formulários para criar formulários mais complexos.",
                "Por Matriz": "Uma matriz de formulários define um formulário dinâmico, onde você pode adicionar e remover controles em tempo de execução - você também pode aninhar matrizes de formulários para criar formulários mais complexos."
              }
            },
            "Assim como uma instância de controle de formulário fornece controle sobre um único campo de entrada, uma instância de grupo de formulários rastreia o estado do formulário de um grupo de instâncias de controle de formulários (por exemplo, um formulário).",
            "Cada controle em uma instância de grupo de formulários é rastreado pelo nome ao criar o grupo de formulários."
          ],
          "Procdimentos":{
            "Criando":[
              "Crie uma propriedade na classe de componente e defina a propriedade para uma nova instância do grupo de formulários.",
              "Para inicializar o grupo de formulários, forneça ao construtor um objeto de chaves nomeadas mapeadas para seu controle.",
              "No objeto de chaves fornecida no construtor do FormGroup instancia controles de formulários ou até mesmo outro grupo de formulários (que neste caso ficarão aninhandos).",
              "Uma instância do FormGroup fornece seu valor de modelo como um objeto reduzido dos valores de cada controle no grupo.",
              "Uma instância do grupo de formulários possui as mesmas propriedades (como 'value' e 'untouched') e métodos (como setValue()) que uma instância de controle de formulário."
            ],
            "Associando":[
              "Um grupo de formulários controla o status e as alterações para cada um de seus controles; portanto, se um dos controles for alterado, o controle pai também emitirá um novo status ou alteração de valor.",
              "O modelo para o grupo é mantido por seus membros.",
              "Depois de definir o modelo, você deve atualizar o modelo para refletir o modelo na visualização.",
              "Assim como um grupo de formulários contém um grupo de controles, o formulário de perfil FormGroup é vinculado ao elemento de formulário com a diretiva FormGroup, criando uma camada de comunicação entre o modelo e o formulário que contém as entradas.",
              "A entrada formControlName fornecida pela diretiva FormControlName vincula cada entrada individual ao controle de formulário definido no FormGroup.",
              "Os controles do formulário se comunicam com seus respectivos elementos, eles também comunicam alterações na instância do grupo de formulários, que fornece a fonte da verdade para o valor do modelo."
            ],
            "Salvando":[
              "Em um cenário real você deseja capturar o valor do formulário e disponibilizar para processamento adicional fora do componente.",
              "A diretiva FormGroup escuta o evento de envio emitido pelo elemento de formulário e emite um evento ngSubmit que você pode vincular a uma função de retorno de chamada.",
              "Adicione um ouvinte de evento ngSubmit à tag do formulário com o método de retorno de chamada onSubmit().",
              "O método onSubmit() no componente captura o valor atual de profileForm.",
              "Use EventEmitter para manter o formulário encapsulado e fornecer o valor do formulário fora do componente.",
              "O evento de envio é emitido pela tag do formulário usando o evento DOM nativo.",
              "Você aciona o evento clicando em um botão com o tipo de envio., isso permite que o usuário pressione a tecla Enter para enviar o formulário preenchido."
            ],
            "Atualizando":[
              "Ao atualizar o valor para uma instância de grupo de formulários que contém vários controles, você pode querer atualizar apenas partes do modelo.",
              "Há duas maneiras de atualizar o valor do modelo.",
              { 
                "Maneiras":{
                  "1": "Use o método setValue() para definir um novo valor para um controle individual, ele segue estritamente a estrutura do grupo de formulários e substitui todo o valor do controle.",
                  "2": "Use o método patchValue() para substituir quaisquer propriedades definidas no objeto que foram alteradas no modelo de formulário."
                }
              },
              "As verificações rigorosas do método setValue() ajudam a detectar erros de aninhamento em formulários complexos, enquanto o patchValue() falha silenciosamente nesses erros."
            ]
          }
        },
        "Serviço para Gerar Controles":[
          "Criar instâncias de controle de formulário manualmente pode se tornar repetitivo ao lidar com vários formulários.",
          "O serviço FormBuilder fornece métodos convenientes para gerar controles.",
          "O serviço FormBuilder possui três métodos: control(), group() e array() - estes são métodos de fábrica para gerar instâncias nas classes de componentes, incluindo controles, grupos e matrizes de formulários.",
          "Você pode definir o controle apenas com o valor inicial, mas se seus controles precisarem de validação de sincronização ou assíncrona, adicione validadores de sincronização e assíncrona como o segundo e o terceiro itens da matriz."
        ],
        "Validação de Entrada":[
          "A validação de formulário é usada para garantir que a entrada do usuário esteja completa e correta.",
          "Os formulários reativos incluem um conjunto de funções validadoras para casos de uso comuns.",
          "Essas funções recebem um controle para validar e retornar um objeto de erro ou um valor nulo com base na verificação de validação.",
          "Use atributos de validação HTML5 em combinação com os validadores internos fornecidos pelos formulários reativos da Angular, a utilização combinada evita erros quando a expressão é alterada após a verificação do modelo."
        ],
        "Formulários Dinámicos":[
          "O FormArray é uma alternativa ao FormGroup para gerenciar qualquer número de controles sem nome.",
          "Como nas instâncias do grupo de formulários, você pode inserir e remover dinamicamente controles das instâncias da matriz de formulários, e o valor e o status de validação da instância da matriz de formulários são calculados a partir de seus controles filhos.",
          "No entanto, você não precisa definir uma chave para cada controle por nome, portanto, essa é uma ótima opção se você não souber o número de valores filho com antecedência",
          "Você pode inicializar uma matriz de formulário com qualquer número de controles, de zero a muitos, definindo-os em uma matriz.",
          "Use o método FormBuilder.array() para definir a matriz e o método FormBuilder.control() para preencher a matriz com um controle inicial."
        ],
        "Resumo":{
          "Classes":{
            "AbstractControl": "A classe base abstrata para as classes de controle de formulário concretas FormControl, FormGroup e FormArray, fornece seus comportamentos e propriedades comuns.",
            "FormControl": "Gerencia o valor e o status de validade de um controle de formulário individual, corresponde a um controle de formulário HTML, como <input> ou <select>.",
            "FormGroup": "Gerencia o valor e o estado de validade de um grupo de instâncias AbstractControl, as propriedades do grupo incluem seus controles filho, e o formulário de nível superior no seu componente é FormGroup.",
            "FormArray": "Gerencia o valor e o estado de validade de uma matriz numericamente indexada de instâncias AbstractControl.",
            "FormBuilder": "Um serviço injetável que fornece métodos de fábrica para criar instâncias de controle."
          },
          "Diretivas":{
            "FormControlDirective": "Sincroniza uma instância independente de FormControl com um elemento de controle de formulário.",
            "FormControlName": "Sincroniza FormControl em uma instância existente do FormGroup para um elemento de controle de formulário por nome.",
            "FormGroupDirective": "Sincroniza uma instância existente do FormGroup com um elemento DOM.",
            "FormGroupName": "Sincroniza uma instância FormGroup aninhada em um elemento DOM.",
            "FormArrayName": "Sincroniza uma instância FormArray aninhada em um elemento DOM."
          }
        }
      }
    },
    "Observables & RxJS": {
      "Observables": {
        "Informações Relevantes": [
          "Observáveis ​​fornecem suporte para a passagem de mensagens entre partes do seu aplicativo. Eles são usados ​​com freqüência no Angular e são a técnica recomendada para manipulação de eventos, programação assíncrona e manipulação de vários valores.",
          "O 'observer pattern' é um padrão de design de software no qual um objeto, chamado de sujeito, mantém uma lista de seus dependentes, chamados observadores, e os notifica automaticamente sobre alterações de estado. Esse padrão é semelhante (mas não idêntico) ao padrão de design de 'publish/subscribe'.",
          "Observáveis ​​são declarativos - ou seja, você define uma função para publicar valores, mas ela não é executada até que um consumidor assine. O consumidor inscrito recebe notificações até que a função seja concluída ou até que eles cancelem a inscrição."
        ],
        "Uso Básico": "Como publicado, você cria uma instância Observable que define uma função de assinante. Essa é a função que é executada quando um consumidor chama o método subscribe(). A função de assinante define como obter ou gerar valores ou mensagens a serem publicadas.",
        "Subscrever": [
          "Uma instância Observable começa a publicar valores somente quando alguém se inscreve nela. Você se inscreve chamando o método subscribe() da instância, passando um objeto observador para receber as notificações.",
          "Como um termo geral, nos referimos aos dados publicados por um observável como um fluxo. Qualquer tipo de valor pode ser representado com um observável, e os valores são publicados como um fluxo."
        ],
        "Multicasting": [
          "Um observável típico cria uma nova execução independente para cada observador inscrito - quando um observador se inscreve, o observável liga um manipulador de eventos e entrega valores a esse observador - quando outra observador se inscreve, o observável liga um novo manipulador de eventos e entrega valores para esse segundo observador em uma execução separada.",
          "Às vezes, em vez de iniciar uma execução independente para cada assinante, se deseja que cada assinatura obtenha os mesmos valores - mesmo que os valores já tenham começado a ser emitidos.",
          "O Multicasting é a prática de transmitir para uma lista de vários assinantes em uma única execução.",
          "Com um multicast observável, você reutilza o primeiro ouvinte e envia valores para cada assinante."
        ],
        "Error": [
          "Como os observáveis ​​produzem valores de forma assíncrona, o try/catch não captura efetivamente os erros.",
          "Você lida com erros especificando um retorno de chamada de erro no observador.",
          "Produzir um erro também faz com que o observável limpe as assinaturas e pare de produzir valores. Um observável pode produzir valores (chamando o próximo retorno de chamada) ou pode ser concluído chamando o retorno de chamada completo ou de erro."
        ]
      },
      "Biblioteca RxJS": {
        "Informações Relevantes": [
          "A programação reativa é um paradigma de programação assíncrona relacionado aos fluxos de dados e à propagação da mudança (Wikipedia)",
          "O RxJS (Extensões Reativas para JavaScript) é uma biblioteca para programação reativa usando observáveis ​​que facilita a composição de código assíncrono ou baseado em retorno de chamada.",
          "O RxJS fornece uma implementação do tipo Observable, necessária até que o tipo se torne parte do idioma e até que os navegadores o suportem. A biblioteca também fornece funções utilitárias para criar e trabalhar com observáveis.",
          "Funções utilitárias podem ser usadas para: Convertendo código existente para operações assíncronas em observáveis; Iterando Através dos Valores em um Fluxo; Mapeando valores para diferentes tipos; Filtrando fluxos Compondo vários fluxos;"
        ],
        "Operadores": [
          "Operadores são funções que se baseiam na base observável para permitir manipulação sofisticada de coleções. Por exemplo, o RxJS define operadores como map(), filter(), concat() e flatMap(). Os operadores aceitam opções de configuração e retornam uma função que leva uma fonte observável. Ao executar esta função retornada, o operador observa os valores emitidos do observável de origem, os transforma e retorna um novo observável desses valores transformados.",
          "Você pode usar tubos para vincular operadores. Os tubos permitem combinar várias funções em uma única função. A função pipe() usa como argumento as funções que você deseja combinar e retorna uma nova função que, quando executada, executa as funções compostas em sequência.",
          "Um conjunto de operadores aplicados a um observável é uma receita, ou seja, um conjunto de instruções para produzir os valores nos quais você está interessado. Por si só, a receita não faz nada. Você precisa chamar subscribe() para produzir um resultado através da receita.",
          "Para aplicativos Angular, preferimos combinar operadores com tubos, em vez de encadear, embora o encadeamento é usado em muitos exemplos de RxJS."
        ],
        "Erros": [
          "Além do manipulador error() que você fornece na assinatura, o RxJS fornece o operador catchError que permite manipular erros conhecidos na receita observável.",
          "Suponha que você tenha um observável que faça uma solicitação de API e mapeie a resposta do servidor. Se o servidor retornar um erro ou o valor não existir, será produzido um erro. Se você capturar esse erro e fornecer um valor padrão, seu fluxo continuará processando valores em vez de gerar erros."
        ],
        "Retry": [
          "Enquanto o operador catchError fornece um caminho simples de recuperação, o operador de nova tentativa permite tentar novamente uma solicitação com falha. Use o operador de nova tentativa antes do operador catchError. Ele reinscreve a fonte original observável, que pode executar novamente a sequência completa de ações que resultaram no erro. Se isso incluir uma solicitação HTTP, ela tentará novamente.",
          "Não tente novamente as solicitações de autenticação, pois elas devem ser iniciadas apenas pela ação do usuário. Não queremos bloquear contas de usuário com solicitações de login repetidas que o usuário não iniciou."
        ],
        "Nomenclaturas": [
          "Como os aplicativos angulares são geralmente escritos em TypeScript, você normalmente sabe quando uma variável é observável. Embora a estrutura Angular não imponha uma convenção de nomenclatura para observáveis, você verá frequentemente observáveis ​​nomeados com um sinal '$'' à direita.",
          "Definir '$' como convenção pode ser útil ao varrer o código e procurar valores observáveis.",
          "Se você deseja que uma propriedade armazene o valor mais recente de um observável, pode ser conveniente simplesmente usar o mesmo nome com ou sem o '$'"
        ]
      },
      "Observables no Angular": {
        "Informações Relevantes": [
          "Angular usa observáveis ​​como uma interface para lidar com uma variedade de operações assíncronas comuns.",
          "Você pode definir eventos personalizados que enviam dados de saída observáveis ​​de um filho para um componente pai.",
          "O módulo HTTP usa observáveis ​​para lidar com solicitações e respostas AJAX.",
          "Os módulos Router e Forms usam observáveis ​​para ouvir e responder a eventos de entrada do usuário."
        ],
        "Transmissão de Dados": [
          "Angular fornece uma classe EventEmitter que é usada ao publicar valores de um componente por meio do decorador @Output().",
          "O EventEmitter estende de Subject RxJS, adicionando um método emit() para que ele possa enviar valores arbitrários.",
          "Quando emit() é chamado, o EventEmitter passa o valor emitido para o próximo método ) de qualquer observador inscrito."
        ],
        "HTTP": [
          "O HttpClient da Angular retorna observáveis ​​de chamadas de método HTTP.",
          "Observáveis ​​não alteram a resposta do servidor (como pode ocorrer através de chamadas encadeadas .then() sob promessas), em vez disso, você pode usar uma série de operadores para transformar valores conforme necessário.",
          "Solicitações HTTP são canceláveis ​​através do método unsubscribe().",
          "As solicitações podem ser configuradas para obter atualizações de eventos em andamento.",
          "Solicitações com falha podem ser repetidas facilmente."
        ],
        "Async Pipe": "O AsyncPipe assina um cumprimento ou promessa e retorna o valor mais recente que ele emitiu. Quando um novo valor é emitido, o tubo marca o componente a ser verificado quanto a alterações.",
        "Roteamento": [
          "Router.events fornece eventos como observáveis, use o operador filter() do RxJS para procurar eventos de interesse e se inscrever nele para tomar decisões com base na sequência de eventos no processo de navegação.",
          "O ActivatedRoute é um serviço de roteador injetado que utiliza observáveis ​​para obter informações sobre um caminho e parâmetros de rota."
        ],
        "Formulários Reativos": [
          "Os formulários reativos têm propriedades que usam observáveis ​​para monitorar os valores de controle do formulário. As propriedades FormControl valueChanges e statusChanges contêm observáveis ​​que geram eventos de alteração.",
          "A inscrição em uma propriedade observável de controle de formulário é uma maneira de acionar a lógica da aplicação dentro da classe de componentes."
        ]
      },
      "Observables vs Promisses": [
        "Observáveis ​​são declarativos; o cálculo não inicia até a assinatura. As promessas são executadas imediatamente na criação. Isso torna os observáveis ​​úteis para definir receitas que podem ser executadas sempre que você precisar do resultado.",
        "Observáveis ​​fornecem muitos valores. Promessas fornecem um. Isso torna os observáveis ​​úteis para obter vários valores ao longo do tempo.",
        "Observáveis ​​diferenciam entre encadeamento e assinatura. Promessas possuem apenas cláusulas .then(). Isso torna os observáveis ​​úteis para criar receitas de transformação complexas a serem usadas por outras partes do sistema, sem causar a execução do trabalho.",
        "Observáveis subscribe() é responsável por manipular erros. Promessas empurram erros para seus filhos. Isso torna os observáveis ​​úteis para o tratamento centralizado e previsível de erros.",
        "Observáveis ​​não são executados até que um consumidor assine. O subscribe() executa o comportamento definido uma vez e pode ser chamado novamente. Cada assinatura tem seu próprio cálculo. A nova assinatura causa recomputação de valores.",
        "As promessas são executadas imediatamente e apenas uma vez. O cálculo do resultado é iniciado quando a promessa é criada. Não há como reiniciar o trabalho. Todas as cláusulas (assinaturas) compartilham o mesmo cálculo.",
        "Observáveis ​​diferenciam entre funções de transformação, como um mapa e uma assinatura. Somente a assinatura ativa a função de assinante para começar a calcular os valores. As promessas não diferenciam entre as últimas cláusulas .then (equivalentes à assinatura) e as intermediárias .then cláusulas (equivalentes ao map).",
        "Assinaturas observáveis ​​são canceláveis. O cancelamento da inscrição remove o ouvinte de receber mais valores e notifica a função de assinante para cancelar o trabalho. Promessas não são canceláveis.",
        "Erros de execução observáveis ​​são entregues ao manipulador de erros do assinante e o assinante cancela automaticamente a assinatura do observável. Promisses empurram os erros para seus filhos."
      ]
    },
    "HttpClient": {
      "Informações Relevantes": [
        "A maioria dos aplicativos front-end se comunica com serviços de back-end pelo protocolo HTTP. Navegadores modernos suportam duas APIs diferentes para fazer solicitações HTTP: a interface XMLHttpRequest e a API fetch().",
        "O HttpClient em @angular/common/http oferece uma API HTTP do cliente simplificada para aplicativos Angular que repousa na interface XMLHttpRequest exposta pelos navegadores.",
        "Os benefícios adicionais do HttpClient incluem recursos de testabilidade, objetos de solicitação e resposta digitados, interceptação de solicitação e resposta, APIs observáveis ​​e tratamento de erros simplificado.",
        "É uma prática recomendada separar a apresentação dos dados do acesso a dados, encapsulando o acesso a dados em um serviço separado e delegando esse serviço no componente, mesmo em casos simples."
      ],
      "Observáveis ​​e Operadores": [
        "O RxJS é uma biblioteca para compor código assíncrono e baseado em retorno de chamada em um estilo funcional e reativo. Muitas APIs Angular, incluindo HttpClient, produzem e consomem Observáveis ​​RxJS.",
        "Embora você possa se familiarizar com o mínimo de conhecimento em RxJS, convém aumentar suas habilidades em RxJS ao longo do tempo para usar o HttpClient com eficiência.",
        "Um método HttpClient não inicia sua solicitação HTTP até você chamar subscribe() no observável retornado por esse método. Isso vale para todos os métodos HttpClient",
        "Todos os observáveis ​​retornados dos métodos HttpClient são congelados por padrão, a execução da solicitação HTTP é adiada, permitindo que você estenda o observável com operações adicionais, como tap e catchError antes que algo realmente aconteça.",
        "De fato, cada subscrever() inicia uma execução separada e independente do observável. A inscrição duas vezes resulta em duas solicitações HTTP."
      ],
      "Interceptadores": {
        "Informações Relevantes": [
          "Com a interceptação, você declara interceptores que inspecionam e transformam solicitações HTTP do seu aplicativo no servidor. Os mesmos interceptadores também podem inspecionar e transformar as respostas do servidor no caminho de volta ao aplicativo. Vários interceptadores formam uma cadeia de manipuladores de solicitações/respostas para frente e para trás.",
          "Os interceptadores podem executar uma variedade de tarefas implícitas, da autenticação ao log, de maneira rotineira e padrão, para cada solicitação/resposta HTTP.",
          "Sem interceptação, os desenvolvedores teriam que implementar essas tarefas explicitamente para cada chamada de método HttpClient.",
          "A maioria dos interceptadores inspeciona a solicitação no caminho e encaminha a solicitação (talvez alterada) para o método handle() do próximo objeto que implementa a interface HttpHandler.",
          "Como intercept(), o método handle() transforma uma solicitação HTTP em um Observable of HttpEvents, que inclui a resposta do servidor. O método intercept() pode inspecionar esse observável e alterá-lo antes de devolvê-lo ao chamador.",
          "O 'next' objeto representa o próximo interceptador na cadeia de interceptores. O 'next' final da cadeia é o manipulador de back-end HttpClient que envia a solicitação ao servidor e recebe a resposta do servidor.",
          "A maioria dos interceptores chama next.handle() para que a solicitação flua para o próximo interceptador e, eventualmente, para o manipulador de back-end. Um interceptador pode pular a chamada next.handle(), causar um curto-circuito na cadeia e retornar seu próprio Observable com uma resposta artificial do servidor.",
          "Como os interceptores são dependências (opcionais) do serviço HttpClient, você deve fornecê-los no mesmo injetor (ou pai do injetor) que fornece o HttpClient. Os interceptores fornecidos após o DI criar o HttpClient são ignorados."
        ],
        "Ordem dos Interceptadores": [
          "Angular aplica interceptores na ordem em que você os fornece. Se você fornecer interceptores A, então B e C, as solicitações fluirão em A-> B-> C e as respostas fluirão C-> B-> A.",
          "Você não pode alterar a ordem ou remover os interceptores posteriormente. Se você precisar habilitar e desabilitar um interceptor dinamicamente, precisará criar esse recurso no próprio interceptador.",
          "Embora os interceptores sejam capazes de alterar solicitações e respostas, as propriedades da instância HttpRequest e HttpResponse são somente leitura, tornando-as imutáveis."
        ],
        "Imutabilidade": [
          "Eles são imutáveis ​​por um bom motivo: o aplicativo pode repetir uma solicitação várias vezes antes de ser bem-sucedido, o que significa que a cadeia de interceptadores pode reprocessar a mesma solicitação várias vezes.",
          "Se um interceptador pudesse modificar o objeto de solicitação original, a operação tentada novamente seria iniciada a partir da solicitação modificada, e não do original. A imutabilidade garante que os interceptadores vejam a mesma solicitação para cada tentativa.",
          "O protetor de atribuição somente leitura não pode impedir atualizações profundas e, em particular, não pode impedir que você modifique uma propriedade de um objeto do corpo da solicitação. Se você deve alterar o corpo da solicitação, copie-o primeiro, altere a cópia, clone() a solicitação e defina o corpo do clone com o novo corpo",
          "Às vezes, você precisa limpar o corpo da solicitação em vez de substituí-lo. Se você definir o corpo da solicitação clonada como indefinido, o Angular assumirá que pretende deixar o corpo como está. Não é isso que você quer. Se você definir o corpo da solicitação clonada como nulo, o Angular saberá que você deseja limpar o corpo da solicitação."
        ],
        "Registro": "Como os interceptores podem processar a solicitação e a resposta juntos, eles podem fazer coisas como tempo e registrar uma operação HTTP inteira.",
        "Cache": [
          "Os interceptadores podem lidar com solicitações por si mesmos, sem encaminhar para next.handle().",
          "Você pode decidir armazenar em cache determinadas solicitações e respostas para melhorar o desempenho.",
          "Você pode delegar o armazenamento em cache a um interceptador sem perturbar os serviços de dados existentes."
        ],
        "Progresso de Eventos": [
          "Às vezes, os aplicativos transferem grandes quantidades de dados e essas transferências podem levar muito tempo, e os uploads de arquivos são um exemplo típico. Fornecer ao usuário feedback sobre o andamento dessas transferências, é uma ótima prática.",
          "Para fazer uma solicitação com os eventos de progresso ativados, é possível criar uma instância do HttpRequest com a opção reportProgress configurada como true para ativar o rastreamento de eventos de progresso.",
          "Todo evento de progresso aciona a detecção de alterações, portanto, somente ative-as se você realmente pretender relatar o progresso na interface do usuário. Ao usar HttpClient # request() com um método HTTP, configure com observe: 'events' para ver todos os eventos, incluindo o andamento das transferências."
        ],
        "Segurança: Proteção XSR": [
          "A falsificação de solicitação entre sites (XSRF ou CSRF) é uma técnica de ataque pela qual o invasor pode induzir um usuário autenticado a executar ações inconscientemente no seu site.",
          "O HttpClient suporta um mecanismo comum usado para impedir ataques XSRF.",
          "Ao executar solicitações HTTP, um interceptador lê um token de um cookie, por padrão, XSRF-TOKEN, e o define como um cabeçalho HTTP, X-XSRF-TOKEN. Como apenas o código executado em seu domínio pode ler o cookie, o back-end pode ter certeza de que a solicitação HTTP veio da aplicação cliente e não de um invasor.",
          "Por padrão, um interceptador envia esse cabeçalho em todas as solicitações mutantes (como POST) para URLs relativos, mas não em solicitações GET/HEAD ou em solicitações com uma URL absoluta.",
          "Seu servidor precisa definir um token em um cookie de sessão legível por JavaScript chamado XSRF-TOKEN no carregamento da página ou na primeira solicitação GET, de modo que, em solicitações subsequentes, o servidor pode verificar se o cookie corresponde ao cabeçalho HTTP X-XSRF-TOKEN e, portanto, verificar se apenas o código em execução no seu domínio pode ter enviado a solicitação.",
          "O token deve ser exclusivo para cada usuário e deve ser verificável pelo servidor; isso impede que o cliente crie seus próprios tokens.",
          "Definir o token como um resumo do cookie de autenticação do seu site como um extra, para aumentar a segurança."
        ]
      }
    },
    "Injeção de Dependência": {
      "DI no Angular": {
        "Informações Relevantes": [
          "A injeção de dependência (DI) é um importante padrão de design de aplicativo. O Angular possui sua própria estrutura DI, que normalmente é usada no design de aplicativos Angular para aumentar sua eficiência e modularidade.",
          "Dependências são serviços ou objetos que uma classe precisa para desempenhar sua função. O DI é um padrão de codificação no qual uma classe solicita dependências de fontes externas, em vez de criá-las.",
          "No Angular, a estrutura DI fornece dependências declaradas para uma classe quando essa classe é instanciada.",
          "Os módulos filhos e os injetores de componentes são independentes entre si e criam suas próprias instâncias separadas dos serviços fornecidos.",
          "Quando o Angular destrói uma instância NgModule ou componente, também destrói as instâncias de serviço desse injetor e do injetor.",
          "Quando um componente ou serviço declara uma dependência, o construtor da classe assume essa dependência como parâmetro. Você pode dizer ao Angular que a dependência é opcional, anotando o parâmetro do construtor com @Optional()."
        ],
        "Injetores": [
          "Os injetores são herdados, o que significa que, se um determinado injetor não puder resolver uma dependência, ele solicitará ao injetor pai que a resolva. Um componente pode obter serviços de seu próprio injetor, dos injetores de seus ancestrais, do injetor do NgModule pai ou do injetor raiz.",
          "Você pode dizer ao Angular para injetar uma dependência no construtor de um componente, especificando um parâmetro do construtor com o tipo de dependência.",
          "Existe apenas um injetor de raiz para um aplicativo. Fornecer 'YourService' no nível raiz ou AppModule significa que ele é registrado com o injetor raiz.",
          "Graças à herança do injetor, você ainda pode injetar serviços de todo o aplicativo nesses componentes. O injetor de um componente é filho do injetor de seu componente pai e herda de todos os injetores ancestrais desde o injetor raiz  da aplicação . A Angular pode injetar um serviço prestado por qualquer injetor nessa linhagem.",
          "Ao configurar um injetor com um provedor, você o associa a um token DI. O injetor mantém um mapa de provedor de token interno que ele faz referência quando solicitado por uma dependência. O token é a chave do mapa."
        ],
        "Serviços": [
          "Os serviços são singletons no escopo de um injetor. Ou seja, existe no máximo uma instância de serviço em um determinado injetor.",
          "Há apenas uma instância de 'YourService' no aplicativo inteiro e todas as classes que injetam UserService obtêm essa instância de serviço, a menos que você configure outro provedor com um injetor filho."
        ]
      },
      "Injetores Hierárquicos": {
        "Informações Relevantes": [
          "Os injetores no Angular têm regras que você pode aproveitar para alcançar a visibilidade desejada dos injetáveis ​​em seus aplicativos. Ao entender essas regras, você pode determinar em qual NgModule, Componente ou Diretiva deve declarar um provedor.",
          "Existem duas hierarquias de injetores em Angular: Hierarquia ModuleInjector - é configurada usando uma anotação @NgModule() ou @Injectable(). Hierarquia ElementInjector - criada implicitamente em cada elemento DOM. Um ElementInjector está vazio por padrão, a menos que você o configure na propriedade provider em @Directive() ou @Component()."
        ],
        "ModuleInjector": [
          "O decorador @Injectable() identifica uma classe de serviço, e a propriedade 'providedIn' configura um ModuleInjector específico no 'root', que disponibiliza o serviço no ModuleInjector raiz.",
          "Existem mais dois injetores acima da raiz, um ModuleInjector adicional e NullInjecto.",
          "O método bootstrapModule() cria um injetor filho do injetor de plataforma que é configurado pelo AppModule. Este é o ModuleInjector raiz.",
          "O método platformBrowserDynamic() cria um injetor configurado por um PlatformModule, que contém dependências específicas da plataforma. Isso permite que vários aplicativos compartilhem uma configuração de plataforma.",
          "O próximo injetor pai na hierarquia é o NullInjector(), que é o topo da árvore. Se você foi tão longe na árvore que procura um serviço no NullInjector(), você receberá um erro, a menos que tenha usado @Optional() porque, no final das contas, tudo termina no NullInjector() e ele retorna um erro ou, no caso de @Optional(), nulo.",
          "O diagrama a seguir representa o relacionamento entre o ModuleInjector raiz e seus injetores-pai: https://angular.io/generated/images/guide/dependency-injection/injectors.svg",
          "Enquanto o nome root é um alias especial, outros ModuleInjectors não têm alias. Você tem a opção de criar ModuleInjectors sempre que um componente carregado dinamicamente é criado, como no roteador, que criará ModuleInjectors filho."
        ],
        "ElementInjector": [
          "Angular cria ElementInjectors implicitamente para cada elemento DOM.",
          "Fornecer um serviço no decorador @Component() usando seus provedores ou a propriedade viewProviders configura um ElementInjector.",
          "Quando você fornece serviços em um componente, esse serviço está disponível por meio do ElementInjector nessa instância do componente.",
          "Quando a instância do componente é destruída, o mesmo ocorre com a instância do serviço.",
          "Um componente é um tipo especial de diretiva, o que significa que, assim como @Directive() possui uma propriedade de provedores, @Component() também possui.",
          "Diretivas e Componentes podem configurar provedores usando a propriedade de provedores. Quando você configura um provedor para um componente ou diretiva usando a propriedade provider, esse provedor pertence ao ElementInjector desse componente ou diretiva. Componentes e diretivas no mesmo elemento compartilham um injetor.",
          "Ao resolver um token para um componente/diretiva, o Angular o resolve em duas fases: Contra a hierarquia do ElementInjector (seus pais) Contra a hierarquia do ModuleInjector (seus pais)",
          "Quando um componente declara uma dependência, o Angular tenta satisfazer essa dependência com seu próprio ElementInjector. Se o injetor do componente não tiver o provedor, ele passará a solicitação para o ElementInjector do componente pai, de modo que, as solicitações continuam sendo encaminhadas até que o Angular encontre um injetor que possa manipular a solicitação ou ficar sem os ElementInjectors ancestrais",
          "Se o Angular não encontrar o provedor em nenhum ElementInjectors, ele retornará ao elemento em que a solicitação se originou e procurará na hierarquia ModuleInjector. Se o Angular ainda não encontrar o provedor, ele gera um erro.",
          "Quando você fornece serviços na classe de componente, os serviços são visíveis na árvore ElementInjector em relação a onde e como você fornece esses serviços.",
          "Compreender a estrutura lógica subjacente do modelo Angular fornecerá uma base para configurar serviços e, por sua vez, controlar sua visibilidade."
        ],
        "Modificadores": [
          "O comportamento da resolução da Angular pode ser modificado com @Optional(), @Self(), @SkipSelf() e @Host(). Importe cada um deles de @angular/core e use cada um no construtor da classe de componentes ao injetar seu serviço.",
          "Os modificadores de resolução se enquadram em três categorias: O que fazer se o Angular não encontrar o que você está procurando, que é @Optional() - Por onde começar a procurar, é @SkipSelf() - Onde parar de procurar, @Host() e @Self().",
          "Por padrão, o Angular sempre inicia no Injetor atual e continua pesquisando até o fim. Os modificadores permitem alterar o local inicial (final) ou final.",
          "Opcional() permite que a Angular considere um serviço que você injeta como opcional. Dessa forma, se não puder ser resolvido em tempo de execução, o Angular simplesmente resolverá o serviço como nulo, em vez de gerar um erro.",
          "Use @Self() para que o Angular procure apenas no ElementInjector o componente ou a diretiva atual. Um bom caso de uso para @Self() é injetar um serviço, mas apenas se estiver disponível no elemento host atual. Para evitar erros nessa situação, combine @Self() com @Optional().",
          "@SkipSelf() é o oposto de @Self(). Com o @SkipSelf(), o Angular inicia a busca por um serviço no ElementInjector pai, em vez do atual.",
          "@Host() permite designar um componente como a última parada na árvore do injetor ao procurar fornecedores. Mesmo se houver uma instância de serviço mais adiante, o Angular não continuará procurando."
        ]
      },
      "Informações Extras": [
        "Um provedor de dependência configura um injetor com um token DI, que esse injetor usa para fornecer a versão concreta e em tempo de execução de um valor de dependência.",
        "O injetor depende da configuração do provedor para criar instâncias das dependências injetadas em componentes, diretivas, tubulações e outros serviços.",
        "Você deve configurar um injetor com um provedor ou ele não saberá como criar a dependência. A maneira mais óbvia de um injetor criar uma instância de uma classe de serviço é com a própria classe. Se você especificar a própria classe de serviço como o token do provedor, o comportamento padrão é o injetor instanciar essa classe com 'new'.",
        "Você pode configurar um injetor com um provedor alternativo, a fim de fornecer outro objeto que forneça a funcionalidade de registro necessária. Por exemplo: Você pode fornecer uma classe substituta. Você pode fornecer um objeto do tipo logger. Seu provedor pode chamar uma função de fábrica de registrador.",
        "A configuração do provedor expandido é um objeto literal com duas propriedades - a propriedade 'provider' tem o token que serve como a chave para localizar um valor de dependência e configurar o injetor - a segunda propriedade é um objeto de definição de provedor, que informa ao injetor como criar o valor da dependência. A chave de definição de provedor pode ser useClass, como no exemplo. Também pode ser useExisting, useValue ou useFactory. Cada uma dessas chaves fornece um tipo diferente de dependência.",
        "Um aplicativo Angular possui vários injetores, organizados em uma hierarquia de árvore que é paralela à árvore de componentes. Cada injetor cria uma instância singleton de uma dependência. Essa mesma instância é injetada onde quer que esse injetor forneça esse serviço. Um serviço específico pode ser fornecido e criado em qualquer nível da hierarquia do injetor, o que significa que pode haver várias instâncias de um serviço se ele for fornecido por vários injetores.",
        "Dependências fornecidas pelo injetor raiz podem ser injetadas em qualquer componente em qualquer lugar  da aplicação . Em alguns casos, convém restringir a disponibilidade do serviço a uma região específica  da aplicação . Por exemplo, convém permitir que os usuários optem explicitamente pelo uso de um serviço, em vez de permitir que o injetor raiz o forneça automaticamente."
      ]
    },
    "Roteamento e Navegação": {
      "Visão Geral": {
        "Navegador": [
          "O navegador é um modelo familiar de navegação de aplicativos.",
          "Digite um URL na barra de endereço e o navegador navegará para uma página correspondente.",
          "Clique nos links da página e o navegador navegará para uma nova página.",
          "Clique nos botões voltar e avançar do navegador e o navegador navega para trás e para frente no histórico de páginas que você viu."
        ],
        "Roteador Angular": [
          "O roteador angular ('o roteador') empresta esse modelo (representando o navegador).",
          "Ele pode interpretar um URL do navegador como uma instrução para navegar para uma visualização gerada pelo cliente.",
          "Ele pode passar parâmetros opcionais para o componente de visualização de suporte que ajuda a decidir qual conteúdo específico apresentar",
          "Você pode vincular o roteador aos links em uma página e ele navegará para a visualização apropriada do aplicativo quando o usuário clicar em um link.",
          "Você pode navegar imperativamente quando o usuário clica em um botão, seleciona em uma caixa suspensa ou em resposta a algum outro estímulo de qualquer fonte. E o roteador registra a atividade no diário de histórico do navegador para que os botões voltar e avançar também funcionem."
        ]
      },
      "Básico": {
        "Introdução": "A maioria dos aplicativos de roteamento deve adicionar um elemento <base href='/'> ao index.html como o primeiro filho na tag <head> para informar ao roteador como compor URLs de navegação.",
        "Importação": "O roteador angular é um serviço opcional que apresenta uma exibição de componente específica para um determinado URL - bão faz parte do núcleo angular ... está no seu próprio pacote de biblioteca, @angular/router ... importe o que você precisa dele como faria em qualquer outro pacote Angular.",
        "Configuração": [
          "Um aplicativo Angular roteado possui uma instância singleton do serviço Roteador: quando a URL do navegador muda, o roteador procura uma rota correspondente a partir da qual pode determinar o componente a ser exibido, e um roteador não tem rotas até você configurá-lo.",
          "A matriz de rotas 'const appRoutes: Routes = []' descreve como navegar. Passe-o para o método RouterModule.forRoot() nas importações de módulos para configurar o roteador.",
          "Cada rota mapeia um caminho de URL para um componente - não há barras principais no caminho. O roteador analisa e cria a URL final para você, permitindo o uso de caminhos relativos e absolutos ao navegar entre as visualizações do aplicativo.",
          "Utilizar dois pontos ':' é um token para um parâmetro de rota ... em uma URL configurada como '/component/:id' ao ser buscado '/component/1' o numero 1 é o valor do parâmetro id.",
          "A propriedade de 'data' é um local para armazenar dados arbitrários associados a essa rota específica. A propriedade data está acessível dentro de cada rota ativada. Use-o para armazenar itens como títulos de página, texto de trilha de navegação e outros dados estáticos somente leitura.",
          "Um caminho vazio representa o caminho padrão para o aplicativo, o lugar para ir quando o caminho na URL estiver vazio, como normalmente ocorre: 'https://www.seudominio.com.br/' ... não há nenhum caminho informado após a barra '/'.",
          "Dois asteriscos '**' é um curinga, e o roteador selecionará essa rota se o URL solicitado não corresponder a nenhum caminho para as rotas definidas anteriormente na configuração.",
          "A ordem das rotas na configuração é importante e isso ocorre por design - o roteador usa uma estratégia de vitórias de primeira correspondência ao combinar rotas, portanto, rotas mais específicas devem ser colocadas acima de rotas menos específicas.",
          "Em uma configuração padrão, as rotas com um caminho estático são listadas primeiro, seguidas por uma rota de caminho vazia, que corresponde à rota padrão, e a rota curinga vem por último porque corresponde a todos os URLs e deve ser selecionada apenas se nenhuma outra rota corresponder primeiro.",
          "Se você precisar ver quais eventos estão acontecendo durante o ciclo de vida da navegação, há a opção enableTracing como parte da configuração padrão do roteador.",
          "A proriedade enableTracing gera cada evento do roteador que ocorreu durante cada ciclo de vida da navegação no console do navegador e somente deve ser usada apenas para fins de depuração ... a definição ocorre passando true para a propriedade 'enableTracing' no objeto passado como o segundo argumento para o método RouterModule.forRoot()."
        ],
        "Saida de Componentes": "O RouterOutlet é uma diretiva da biblioteca de roteadores usada como um componente, ele atua como um espaço reservado que marca o ponto no modelo em que o roteador deve exibir os componentes através dessa diretiva.",
        "Ligação de Rotas": "As diretivas RouterLink nas tags de âncora dão ao roteador controle sobre esses elementos. Os caminhos de navegação são fixos, para que você possa atribuir uma string ao routerLink (uma ligação 'única').",
        "Links Ativos do Roteador": [
          "A diretiva RouterLinkActive alterna classes css para ligações RouterLink ativas com base no RouterState atual.",
          "Em cada tag de âncora, você vê uma ligação de propriedade à diretiva RouterLinkActive que se parece com routerLinkActive='...'",
          "Você define a diretiva RouterLinkActive como uma sequência de classes como [routerLinkActive]=\"['class1', class2']\" ou vincula-a a uma propriedade de componente que retorna essa sequência.",
          "Os links de rota ativos passam em cascata por cada nível da árvore de rotas, para que os links de roteador pai e filho possam estar ativos ao mesmo tempo.",
          "Para substituir o comportamento padrão de lnks de rota ativos, você pode vincular à ligação de entrada [routerLinkActiveOptions] com a expressão {exact: true} ... ao usar {exact: true}, um determinado RouterLink estará ativo apenas se o URL corresponder exatamente ao URL atual."
        ],
        "Estado do Roteador": [
          "Após o final de cada ciclo de vida de navegação bem-sucedido, o roteador cria uma árvore de objetos ActivatedRoute que compõem o estado atual do roteador.",
          "Você pode acessar o RouterState atual de qualquer lugar do aplicativo usando o serviço Router e a propriedade routerState.",
          "Cada ActivatedRoute no RouterState fornece métodos para percorrer a árvore de rotas para cima e para baixo para obter informações das rotas pai, filho e irmão."
        ],
        "Rota Ativada": {
          "Serviço": "O caminho e os parâmetros da rota estão disponíveis através de um serviço de roteador injetado chamado ActivatedRoute.",
          "Propriedades": {
            "url": "Um Observável do (s) caminho (s) da rota, representado como uma matriz de seqüências de caracteres para cada parte do caminho da rota.",
            "data": "Um Observable que contém o objeto de dados fornecido para a rota. Também contém quaisquer valores resolvidos do protetor de resolução.",
            "paramMap": "Um Observável que contém um mapa dos parâmetros obrigatórios e opcionais específicos da rota. O mapa suporta a recuperação de valores únicos e múltiplos do mesmo parâmetro.",
            "queryParamMap": "Um Observable que contém um mapa dos parâmetros de consulta disponíveis para todas as rotas. O mapa suporta a recuperação de valores únicos e múltiplos do parâmetro de consulta.",
            "fragment": "Um Observável do fragmento de URL disponível para todas as rotas.",
            "outlet": "O nome do RouterOutlet usado para renderizar a rota. Para uma tomada sem nome, o nome da tomada é primário.",
            "routeConfig": "A configuração de rota usada para a rota que contém o caminho de origem.",
            "parent": "O ActivatedRoute pai da rota quando esta rota é uma rota filho.",
            "firstChild": "Contém o primeiro ActivatedRoute na lista de rotas filho desta rota.",
            "children": "Contém todas as rotas secundárias ativadas na rota atual."
          }
        },
        "Eventos do Roteador": {
          "Propriedade": "Durante cada navegação, o roteador emite eventos de navegação através da propriedade Router.events ... esses eventos variam desde quando a navegação começa e termina em muitos pontos no meio do caminho.",
          "Eventos": {
            "NavigationStart": "Um evento acionado quando a navegação é iniciada.",
            "RouteConfigLoadStart": "Um evento disparado antes que o roteador preguiçosamente carregue uma configuração de rota.",
            "RouteConfigLoadEnd": "Um evento acionado após o carregamento lento de uma rota.",
            "RoutesRecognized": "Um evento disparado quando o roteador analisa a URL e as rotas são reconhecidas.",
            "GuardsCheckStart": "Um evento disparado quando o roteador inicia a fase de roteamento dos guardas.",
            "ChildActivationStart": "Um evento acionado quando o roteador começa a ativar os filhos de uma rota.",
            "ActivationStart": "Um evento disparado quando o roteador começa a ativar uma rota.",
            "GuardsCheckEnd": "Um evento disparado quando o roteador termina com êxito a fase de roteamento dos guardas.",
            "ResolveStart": "Um evento acionado quando o roteador inicia a fase de resolução do roteamento.",
            "ResolveEnd": "Um evento disparado quando o roteador termina com êxito a fase de resolução do roteamento.",
            "ChildActivationEnd": "Um evento disparado quando o roteador termina de ativar os filhos de uma rota.",
            "ActivationEnd": "Um evento disparado quando o roteador termina de ativar uma rota.",
            "NavigationEnd": "Um evento acionado quando a navegação termina com sucesso.",
            "NavigationCancel": "Um evento acionado quando a navegação é cancelada. Isso pode acontecer quando um Route Guard retorna false durante a navegação ou redireciona retornando um UrlTree.",
            "NavigationError": "Um evento acionado quando a navegação falha devido a um erro inesperado.",
            "Scroll": "Um evento que representa um evento de rolagem."
          }
        },
        "Sumário": {
          "Router": "Exibe o componente do aplicativo para a URL ativa. Gerencia a navegação de um componente para o próximo.",
          "RouterModule": "Um NgModule separado que fornece os provedores de serviços e diretrizes necessárias para navegar pelas exibições de aplicativos.",
          "Routes": "Define uma matriz de rotas, cada uma mapeando um caminho de URL para um componente.",
          "Route": "Define como o roteador deve navegar para um componente com base em um padrão de URL, a maioria das rotas consiste em um caminho e um tipo de componente.",
          "RouterOutlet": "A diretiva (<router-outlet>) que marca onde o roteador exibe uma exibição.",
          "RouterLink": "A diretiva para vincular um elemento HTML clicável a uma rota. Clicar em um elemento com uma diretiva routerLink vinculada a uma cadeia de caracteres ou a uma matriz de parâmetros de link aciona uma navegação.",
          "RouterLinkActive": "A diretiva para adicionar/remover classes de um elemento HTML quando um routerLink associado contido no elemento ou dentro dele se torna ativo/inativo.",
          "ActivatedRoute": "Um serviço que é fornecido a cada componente da rota que contém informações específicas da rota, como parâmetros de rota, dados estáticos, dados de resolução, parâmetros de consulta global e o fragmento global.",
          "RouterState": "O estado atual do roteador, incluindo uma árvore das rotas ativadas no momento, juntamente com métodos de conveniência para percorrer a árvore de rotas."
        }
      }
    },
    "Animações": {
      "Introdução": {
        "Informações Relevantes": [
          "O sistema de animação da Angular é baseado na funcionalidade CSS, o que significa que você pode animar qualquer propriedade que o navegador considere animador - isso inclui posições, tamanhos, transformações, cores, bordas e muito mais.",
          "Os principais módulos angulares para animações são @angular/animations e @angular/platform-browser - quando você cria um novo projeto usando a CLI, essas dependências são adicionadas automaticamente ao seu projeto."
        ],
        "Configuração": [
          "Para começar a adicionar animações angulares ao seu projeto, importe Importe o BrowserAnimationsModule, que apresenta os recursos de animação no seu módulo de aplicativo raiz Angular.",
          "Se você planeja usar funções específicas de animação em arquivos de componentes, importe essas funções de @angular/animations.",
          "No arquivo de componente, adicione uma propriedade de metadados chamada animações: no decorador @Component(). Você coloca o gatilho que define uma animação na propriedade de metadados das animações.",
          "Use a função state() da Angular para definir diferentes estados para chamar no final de cada transição. Essa função usa dois argumentos: um nome exclusivo, e uma função style() ... use a função style() para definir um conjunto de estilos para associar a um determinado nome de estado - observe que os atributos de estilo devem estar no camelCase."
        ],
        "Transições e Tempo": [
          "No Angular, você pode definir vários estilos sem nenhuma animação - no entanto, sem refinamentos adicionais, o botão se transforma instantaneamente sem desbotamento, retração ou outro indicador visível de que uma alteração está ocorrendo.",
          "Para tornar a alteração menos abrupta, precisamos definir uma transição de animação para especificar as alterações que ocorrem entre um estado e outro durante um período de tempo.",
          "A função transit() aceita dois argumentos: o primeiro argumento aceita uma expressão que define a direção entre dois estados de transição e o segundo argumento aceita uma ou uma série de etapas animate().",
          "Use a função animate() para definir a duração, o atraso e a flexibilização de uma transição e para designar a função de estilo para definir estilos enquanto as transições estão ocorrendo.",
          "Você também pode usar a função animate() para definir a função de keyframes() para animações de várias etapas."
        ],
        "Gatilho": [
          "Uma animação requer um gatilho, para que ele saiba quando iniciar.",
          "A função trigger() coleta os estados e transições e fornece um nome à animação, para que você possa anexá-la ao elemento acionador no modelo HTML.",
          "A função trigger() descreve o nome da propriedade a ser observada nas alterações - quando ocorre uma alteração, o gatilho inicia as ações incluídas em sua definição - essas ações podem ser transições ou outras funções.",
          "Dentro de cada chamada de função trigger(), um elemento pode estar apenas em um estado a qualquer momento. No entanto, é possível que vários gatilhos estejam ativos ao mesmo tempo."
        ],
        "Definição": "As animações são definidas nos metadados do componente que controla o elemento HTML a ser animado - coloque o código que define suas animações sob a propriedade animations: dentro do decorador @Component().",
        "Resumo da API": {
          "trigger()": "Inicia a animação e serve como um contêiner para todas as outras chamadas de função de animação ... o modelo HTML é vinculado ao triggerName ... use o primeiro argumento para declarar um nome de acionador exclusivo ... usa sintaxe de matriz.",
          "style()": "Define um ou mais estilos CSS para usar em animações, controla a aparência visual dos elementos HTML durante as animações. Usa sintaxe de objeto.",
          "state()": "Cria um conjunto nomeado de estilos CSS que deve ser aplicado na transição bem-sucedida para um determinado estado ... o estado pode ser referenciado pelo nome em outras funções de animação.",
          "animate()": "Especifica as informações de tempo para uma transição ... pode aplicar valores opcionais para atraso e flexibilização .. pode conter chamadas de style() dentro.",
          "transition()": "Define a sequência de animação entre dois estados nomeados ... usa sintaxe de matriz.",
          "keyframes()": "Permite uma alteração seqüencial entre estilos dentro de um intervalo de tempo especificado ... use dentro de animation() ... pode incluir várias chamadas de style() em cada quadro-chave() ... usa sintaxe de matriz.",
          "group()": "Especifica um grupo de etapas de animação (animações internas) a serem executadas em paralelo ... a animação continua apenas após a conclusão de todas as etapas internas da animação ... usado dentro da sequência() ou transição().",
          "query()": "Use para encontrar um ou mais elementos HTML internos no elemento atual.",
          "sequence()": "Especifica uma lista de etapas de animação executadas seqüencialmente, uma por uma.",
          "stagger()": "Seleciona a hora de início das animações para vários elementos.",
          "animation()": "Produz uma animação reutilizável que pode ser chamada de outro lugar quando usado junto com useAnimation().",
          "useAnimation()": "Ativa uma animação reutilizável ... usado com animação().",
          "animateChild()": "Permite que animações em componentes filhos sejam executadas no mesmo período do pai."
        }
      },
      "Transições e Gatilhos": {
        "Informações Relevantes": [
          "O suporte de animação da Angular se baseia em animações da Web, para que você possa animar qualquer propriedade que o navegador considere animador. Isso inclui posições, tamanhos, transformações, cores, bordas e muito mais. O W3C mantém uma lista de propriedades animáveis ​​em sua página Transições CSS.",
          "Em Angular, os estados de transição podem ser definidos explicitamente através da função state() ou usando os estados predefinidos * (curinga) e void (nulos).",
          "Você pode combinar estados curinga e estados nulos em uma transição para acionar animações que entram e saem da página: uma transição de * => nulo se aplica quando o elemento sai de uma visualização, independentemente do estado em que estava antes de sair - uma transição de void => * se aplica quando o elemento entra em uma visualização, independentemente do estado que ele assume ao entrar ... o estado curinga * corresponde a qualquer estado, incluindo nulo.",
          "Os alias ':enter' e ':leave' são correspondentes para  as transições 'void => *' e '* => void' ... esses aliases são usados ​​por várias funções de animação.",
          "É mais difícil segmentar um elemento que está entrando em uma visualização porque ainda não está no DOM ... portanto, use os aliases: enter e: leave para direcionar elementos HTML que são inseridos ou removidos de uma visualização.",
          "A transição :enter é executada quando qualquer exibição *ngIf ou *ngFor é colocada na página e :leave é executada quando essas exibições são removidas da página.",
          "A função transition() recebe valores adicionais de seletor, como ':incremento' e ':decremento' ...  use-os para iniciar uma transição quando um valor numérico aumentou ou diminuiu de valor.",
          "Um asterisco * ou curinga corresponde a qualquer estado de animação. Isso é útil para definir transições que se aplicam independentemente do estado inicial ou final do elemento HTML.",
          "Os estados curinga são melhores quando um elemento em um estado específico possui vários estados potenciais para os quais pode mudar.",
          "Use o curinga * com um estilo para dizer à animação para usar o valor atual do estilo e animar com isso. Curinga é um valor de fallback usado se o estado que está sendo animado não for declarado no gatilho.",
          "Você pode usar o estado nulo (void) para configurar transições para um elemento que está entrando ou saindo de uma página.",
          "Se você não fornecer uma unidade ao especificar uma dimensão, Angular assumirá uma unidade padrão de pixels ou px. Expressar 50 pixels como 50 é o mesmo que dizer '50px'."
        ],
        "Mutiplos Gatilhos": [
          "Você pode definir mais de um gatilho de animação para um componente.",
          "Você pode anexar gatilhos de animação a diferentes elementos, e os relacionamentos pai-filho entre os elementos afetam como e quando as animações são executadas.",
          "Sempre que uma animação é acionada em Angular, a animação pai sempre tem prioridade e as animações filho são bloqueadas.",
          "Para que uma animação filho seja executada, a animação pai deve consultar cada um dos elementos que contêm animações filho e permitir que as animações sejam executadas usando a função animateChild().",
          "Uma ligação de controle de animação especial chamada @.disabled pode ser colocada em um elemento HTML para desativar as animações nesse elemento, bem como quaisquer elementos aninhados. - quando verdadeira, a ligação @.disabled impede que todas as animações sejam renderizadas.",
          "Quando um elemento em um modelo HTML tem animações desativadas usando a ligação de host @.disabled, as animações também são desativadas em todos os elementos internos - você não pode desativar seletivamente várias animações em um único elemento.",
          "Animações filho seletivas ainda podem ser executadas em um pai desabilitado de uma das seguintes maneiras: uma animação pai pode usar a função query() para coletar elementos internos localizados em áreas desabilitadas do modelo HTML - uma sub-animação pode ser consultada por um pai e posteriormente animada com a função animateChild()."
        ],
        "Keyframes": [
          "A função keyframe() do Angular é semelhante aos quadros-chave em CSS. Os quadros-chave permitem várias mudanças de estilo em um único segmento de tempo.",
          "Os quadros-chave incluem um deslocamento que define o ponto na animação em que cada alteração de estilo ocorre.",
          "Deslocamentos são medidas relativas de zero a um, marcando o início e o final da animação, respectivamente, e devem ser aplicados a cada uma das etapas do quadro-chave, se usadas pelo menos uma vez.",
          "Definir deslocamentos para quadros-chave é opcional. Se você os omitir, as compensações espaçadas igualmente serão atribuídas automaticamente. Por exemplo, três quadros-chave sem deslocamentos predefinidos recebem deslocamentos de 0, 0,5 e 1.",
          "Você pode combinar quadros-chave com duração, atraso e facilidade em uma única animação.",
          "A função keyframes() no Angular permite especificar vários estilos intermediários em uma única transição, com um deslocamento opcional para definir o ponto na animação em que ocorre a alteração de cada estilo."
        ]
      },
      "Animações Complexas": {
        "Informações Relevantes": [
          "Angular também permite animar seqüências coordenadas, como uma grade inteira ou uma lista de elementos à medida que eles entram e saem de uma página. Você pode optar por executar várias animações em paralelo ou animações discretas sequencialmente, uma após a outra.",
          "As funções que controlam sequências complexas de animação são as seguintes: query() localiza um ou mais elementos HTML internos. stagger() aplica um atraso em cascata às animações para vários elementos. group() executa várias etapas de animação em paralelo. sequence() executa as etapas de animação uma após a outra."
        ],
        "Multiplas Animações": [
          "A função query() permite encontrar elementos internos no elemento que está sendo animado - essa função tem como alvo elementos HTML específicos dentro de um componente pai e aplica animações a cada elemento individualmente. O Angular manipula inteligentemente a instalação, desmontagem e limpeza, pois coordena os elementos na página.",
          "A função stagger() permite definir um intervalo de tempo entre cada item consultado que é animado e, assim, anima elementos com um atraso entre eles."
        ],
        "Animação Paralela": "Você também pode configurar animações que acontecem em paralelo - por exemplo, você pode animar duas propriedades CSS do mesmo elemento, mas usar uma função de atenuação diferente para cada uma - para isso, você pode usar a função group().",
        "Animação Sequencial": "As funções angulares para animar vários elementos começam com query() para encontrar elementos internos, por exemplo, reunindo todas as imagens em um <div>. As demais funções, stagger(), group() e sequence(), aplicam cascatas ou permitem controlar como várias etapas de animação são aplicadas.",
        "Sequencial vs Paralelo": "Uma segunda função chamada sequence() permite executar as mesmas animações uma após a outra. Dentro de sequence(), as etapas de animação consistem em chamadas de função style() ou animate()."
      },
      "Animações Reutilizáveis": [
        "A interface AnimationOptions nas animações angulares permite criar animações que podem ser reutilizadas em diferentes componentes.",
        "Para criar uma animação reutilizável, use o método animation() para definir uma animação em um arquivo .ts separado e declare essa definição de animação como uma variável de exportação const. Você pode importar e reutilizar essa animação em qualquer um dos componentes do seu aplicativo usando a API useAnimation()."
      ],
      "Animações de Rota": {
        "Informações Relevantes": [
          "O roteamento permite que os usuários naveguem entre diferentes rotas em um aplicativo. Quando um usuário navega de uma rota para outra, o roteador Angular mapeia o caminho da URL para um componente relevante e exibe sua exibição.",
          "Animar essa transição de rota pode melhorar bastante a experiência do usuário.",
          "O roteador Angular vem com funções de animação de alto nível que permitem animar as transições entre visualizações quando uma rota é alterada. Para produzir uma sequência de animação ao alternar entre rotas, é necessário definir sequências de animação aninhadas.",
          "Comece com o componente de nível superior que hospeda a visualização e aninhe animações adicionais nos componentes que hospedam as visualizações incorporadas."
        ],
        "Configuração": [
          "Para começar, configure um conjunto de rotas usando os métodos disponíveis na classe RouterModule.",
          "A configuração de rota informa ao roteador como navegar.",
          "Use o método RouterModule.forRoot para definir um conjunto de rotas.",
          "Importe esse RouterModule para a matriz de importações do módulo principal, AppModule.",
          "A propriedade data de cada rota define a principal configuração específica da animação associada a uma rota e seu valor é passado para AppComponent quando a rota é alterada - você também pode transmitir dados adicionais na configuração de rota consumida na animação.",
          "Depois de configurar as rotas, informe ao roteador Angular onde renderizar as visualizações quando corresponder a uma rota.",
          "AppComponent precisa definir um método que pode detectar quando uma exibição é alterada. O método atribui um valor de estado de animação ao acionador de animação (@routeAnimation) com base no valor da propriedade de dados de configuração da rota.",
          "Disponibilize a definição de animação no seu aplicativo adicionando a animação reutilizável aos metadados das animações do Componente."
        ],
        "Exemplo Prático": "https://angular.io/guide/route-animations"
      }
    },
    "NgZone": {
      "Informações Relevantes": [
        "Uma zona é um contexto de execução que persiste em tarefas assíncronas, você pode pensar nele como armazenamento local de thread para VMs JavaScript - o NgZone do Angular serve para detectar automaticamente alterações no componente para atualizar o HTML.",
        "A angular executa a detecção de alterações sempre que detecta que os dados podem ter sido alterados, e o resultado da detecção de alterações é que o DOM é atualizado com novos dados.",
        "Angular detecta as alterações de diferentes maneiras - para a inicialização do componente, as chamadas angulares alteram a detecção explicitamente - para operações assíncronas, o Angular usa uma zona para detectar alterações nos locais onde os dados poderiam ter sofrido uma mutação e executa a detecção de alterações automaticamente."
      ],
      "Base de Fundamentos": [
        "Você pode exibir dados vinculando controles em um modelo HTML às propriedades de um componente Angular.",
        "Você pode vincular eventos DOM a um método de um componente Angular. Nesses métodos, você também pode atualizar uma propriedade do componente Angular, que atualiza os dados correspondentes exibidos no modelo.",
        "Você também pode obter dados de um servidor através de uma solicitação HTTP.",
        "Você também pode atualizar os dados na função de retorno de chamada de uma macroTask, como setTimeout()",
        "Outras APIs assíncronas retornam um objeto Promise (como busca), para que a função de retorno de chamada then() também possa atualizar os dados.",
        "Além de addEventListener(), setTimeout() e Promise.then(), há outras operações que podem atualizar os dados de forma assíncrona. Alguns exemplos incluem WebSocket.onmessage() e Canvas.toBlob()."
      ],
      "Contexto de Execução": [
        "O contexto de zona persiste em operações assíncronas.",
        "Contexto de execução é um conceito abstrato que contém informações sobre o ambiente no código atual que está sendo executado.",
        "Uma região fornece um novo contexto de zona diferente do javascript:  por exemplo ... o 'this' de um callback não estar contido em outro método."
      ],
      "Zona": [
        "Uma zona fornece um contexto de execução que persiste em tarefas assíncronas.",
        "O Zone.js pode criar contextos que persistem em operações assíncronas, bem como fornecer ganchos de ciclo de vida para operações assíncronas.",
        "Todas as funções do Zone são fornecidas por uma biblioteca chamada Zone.js - essa biblioteca implementa esses recursos interceptando APIs assíncronas por meio de aplicação de patches monkey. O patch monkeys é uma técnica para adicionar ou modificar o comportamento padrão de uma função em tempo de execução sem alterar o código-fonte."
      ],
      "NgZone": [
        "Embora o Zone.js possa monitorar todos os estados das operações síncronas e assíncronas, a Angular também fornece um serviço chamado NgZone. Este serviço cria uma zona denominada angular para acionar automaticamente a detecção de alterações",
        "Ainda existem algumas APIs de terceiros que o Zone não manipula. Nesses casos, o serviço NgZone fornece um método run() que permite executar uma função dentro da zona angular - essa função e todas as operações assíncronas nessa função acionam a detecção de alterações automaticamente no momento correto.",
        "Por padrão, todas as operações assíncronas estão dentro da zona angular, o que aciona a detecção de alterações automaticamente.",
        "Quando você não deseja acionar a detecção de alterações, você pode usar outro método NgZone: runOutsideAngular().",
        "Para disponibilizar o Zone.js no Angular, você precisa importar o pacote zone.js - se você estiver usando a CLI Angular, esta etapa será realizada automaticamente e você verá a seguinte linha no src/polyfills.ts:",
        "Antes de importar o pacote zone.js, você pode definir configurações desejáveis e para fazer essas alterações, você precisa criar um arquivo zone-flags.ts, import zone-flags before you import zone.js in the polyfills.ts, importando-o antes de importar o zone.js no arquivo polyfills.ts.",
        "O Zone ajuda o Angular a saber quando acionar a detecção de alterações e permite que os desenvolvedores se concentrem no desenvolvimento de aplicativos.",
        "Por padrão, o Zone é carregado e funciona sem configuração adicional. No entanto, você não precisa necessariamente usar o Zone para fazer o Angular funcionar - em vez disso, você pode optar por ativar a detecção de alterações por conta própria."
      ]
    }
  },
  "Técnicas": {
    "Segurança": {
      "Melhores Práticas": [
         "Mantenha-se atualizado com as últimas versões da biblioteca Angular.",
         "Atualizamos regularmente as bibliotecas Angular e essas atualizações podem corrigir defeitos de segurança descobertos em versões anteriores.",
         "Verifique o log de alterações angulares para atualizações relacionadas à segurança.",
         "As versões particulares e personalizadas do Angular tendem a ficar para trás da versão atual e podem não incluir importantes correções e aprimoramentos de segurança.",
         "Evite APIs angulares marcadas na documentação como 'Risco de segurança'."
      ],
      "Cross-Site Scripting":{
         "O que é XSS ?": "O script entre sites (XSS) permite que os invasores injetem códigos maliciosos nas páginas da web. Esse código pode, por exemplo, roubar dados do usuário (em particular, dados de login) ou executar ações para se passar por ele. Este é um dos ataques mais comuns na web.",
         "Medida Preventiva": [
            "Para bloquear ataques XSS, você deve impedir que código malicioso entre no DOM (Document Object Model).",
            "Por exemplo, se os invasores podem induzi-lo a inserir uma tag <script> no DOM, eles podem executar um código arbitrário no seu site.",
            "O ataque não se limita às tags <script> - muitos elementos e propriedades no DOM permitem a execução do código, por exemplo, <img onerror=\"...\"> e <a href=\"javascript:...\"> ... se os dados controlados pelo invasor entrarem no DOM, espere vulnerabilidades de segurança."
         ],
         "Angular's XSS Security Model":[
            "Para bloquear sistematicamente os erros do XSS, o Angular trata todos os valores como não confiáveis ​​por padrão.",
            "Quando um valor é inserido no DOM a partir de um modelo, por meio de propriedade, atributo, estilo, associação de classe ou interpolação, o Angular limpa e escapa valores não confiáveis.",
            "Modelos angulares são iguais ao código executável: HTML, atributos e expressões de ligação (mas não os valores vinculados) nos modelos são confiáveis ​​para serem seguros - isso significa que os aplicativos devem impedir que os valores que um invasor possa controlar consigam o código-fonte de um modelo.",
            "Nunca gere o código fonte do modelo concatenando a entrada e os modelos do usuário. Para evitar essas vulnerabilidades, use o compilador de modelos offline, também conhecido como 'template injection'."
         ],
         "Contextos de Higienização e Segurança":{
            "Conceito": "A higienização é a inspeção de um valor não confiável, transformando-o em um valor seguro para inserir no DOM. Em muitos casos, a higienização não altera um valor - a higienização depende do contexto: um valor inofensivo no CSS é potencialmente perigoso em um URL.",
            "Contextos de Segurança":{
               "HTML": "É usado ao interpretar um valor como HTML, por exemplo, ao vincular a innerHtml.",
               "Style": "É usado ao vincular CSS à propriedade style.",
               "URL": "É usado para propriedades de URL, como <a href>.",
               "Resource URL": "É uma URL que será carregada e executada como código, por exemplo, em <script src>."
            },
            "Avisos": [
               "Angular limpa apenas valores não confiáveis ​​para HTML, estilos e URLs.",
               "A limpeza de URLs de recursos NÃO É POSSIVEL porque eles contêm código arbitrário.",
               "No modo de desenvolvimento, o Angular imprime um aviso do console quando ele precisa alterar um valor durante a higienização."
            ]
         },
         "Uso Direto das APIs do DOM": [
            "As APIs DOM do navegador interno não o protegem automaticamente contra vulnerabilidades de segurança.",
            "Por exemplo: em 'document', o nó disponível através do ElementRef e muitas APIs de terceiros contêm métodos não seguros.",
            "Da mesma forma, se você interagir com outras bibliotecas que manipulam o DOM, provavelmente não terá a mesma limpeza automática que as interpolações do angular possui.",
            "Evite interagir diretamente com o DOM e use modelos angulares sempre que possível.",
            "Nos casos inevitáveis, use as funções internas de higienização angular - limpe os valores não confiáveis ​​com o método DomSanitizer.sanitize e o SecurityContext apropriado.",
            "DomSanitizer também aceita valores marcados como confiáveis ​​usando as funções bypassSecurityTrust ... e não os higieniza, conforme descrito abaixo."
         ],
         "Content Security Policy": "A Política de Segurança de Conteúdo (CSP) é uma técnica de defesa profunda para impedir o XSS. Para habilitar o CSP, configure seu servidor da web para retornar um cabeçalho HTTP apropriado da Política de segurança de conteúdo.",
         "Compilador de Modelos Offline": "O compilador de modelos offline evita toda uma classe de vulnerabilidades chamada 'template injection' e melhora muito o desempenho do aplicativo - use o compilador de modelos offline em implantações de produção; não gere modelos dinamicamente.",
         "Proteção XSS do Servidor": [
            "O HTML construído no servidor é vulnerável a ataques de injeção. Injetar código de modelo em um aplicativo Angular é o mesmo que injetar código executável no aplicativo: fornece ao invasor controle total sobre o aplicativo.",
            "Use uma linguagem de modelo que escape automaticamente de valores para evitar vulnerabilidades XSS no servidor.",
            "Não gere modelos Angular no servidor usando uma linguagem de modelos; isso implica um alto risco de introdução de vulnerabilidades de injeção de modelo."
         ],
         "Confiando em Valores Seguros":[
            "Às vezes, os aplicativos realmente precisam incluir código executável, exibir um <iframe> de algum URL ou construir URLs potencialmente perigosos.",
            "Para impedir a higienização automática em qualquer uma dessas situações, você pode dizer à Angular que inspecionou um valor, verificou como ele foi gerado e garantiu que ele esteja sempre seguro.",
            "Contudo: tenha cuidado - se você confia em um valor que pode ser malicioso, está introduzindo uma vulnerabilidade de segurança em seu aplicativo."
         ],
         "Vulnerabilidades no nível HTTP":{
            "Informações Relevantes":[
               "A Angular possui suporte interno para ajudar a evitar duas vulnerabilidades HTTP comuns, falsificação de solicitação entre sites (CSRF ou XSRF) e inclusão de script entre sites (XSSI).",
               "Tanto (CSRF ou XSRF) devem ser atenuados principalmente no lado do servidor, mas o Angular fornece auxiliares para facilitar a integração no lado do cliente."
            ],
            "CSRF ou XSRF":[
               "Em uma falsificação de solicitação entre sites (CSRF ou XSRF), um invasor induz o usuário a visitar uma página da Web diferente (como evil.com) com código maligno que envia secretamente uma solicitação maliciosa ao servidor da Web do aplicativo (como exemplo: bank.com).",
               "Suponha que o usuário esteja logado no aplicativo em example-bank.com. O usuário abre um email e clica em um link para evil.com, que é aberto em uma nova guia.",
               "A página evil.com envia imediatamente uma solicitação maliciosa para example-bank.com. Talvez seja uma solicitação para transferir dinheiro da conta do usuário para a conta do atacante. O navegador envia automaticamente os cookies example-bank.com (incluindo o cookie de autenticação) com esta solicitação.",
               "Se o servidor example-bank.com não tiver proteção XSRF, ele não saberá a diferença entre uma solicitação legítima do aplicativo e a solicitação forjada do evil.com.",
               "Para evitar isso, o aplicativo deve garantir que uma solicitação do usuário se origine do aplicativo real, não de um site diferente. O servidor e o cliente devem cooperar para impedir esse ataque.",
               "Em uma técnica anti-XSRF comum, o servidor de aplicativos envia um token de autenticação gerado aleatoriamente em um cookie.",
               "O código do cliente lê o cookie e adiciona um cabeçalho de solicitação personalizado com o token em todas as solicitações subsequentes. O servidor compara o valor do cookie recebido ao valor do cabeçalho da solicitação e rejeita a solicitação se os valores estiverem ausentes ou não corresponderem.",
               "Essa técnica é eficaz porque todos os navegadores implementam a mesma política de origem.",
               "Somente o código do site no qual os cookies estão definidos pode ler os cookies desse site e definir cabeçalhos personalizados nas solicitações para esse site. Isso significa que apenas seu aplicativo pode ler este token de cookie e definir o cabeçalho personalizado. O código malicioso no evil.com não pode.",
               "O HttpClient da Angular possui suporte interno para a metade dessa técnica no lado do cliente."
            ],
            "XSSI":[
               "A inclusão de scripts entre sites, também conhecida como vulnerabilidade JSON, pode permitir que o site de um invasor leia dados de uma API JSON.",
               "O ataque funciona em navegadores antigos, substituindo os construtores de objetos JavaScript nativos e incluindo um URL da API usando uma tag <script>.",
               "O ataque será bem-sucedido apenas se o JSON retornado for executável com o JavaScript.",
               "Os servidores podem impedir um ataque prefixando todas as respostas JSON para torná-las não executáveis.",
               "A biblioteca HttpClient da Angular reconhece esta convenção e retira automaticamente a string contendo o script executavel de todas as respostas antes de analisar novamente."
            ],
            "Auditoria": "Os aplicativos angulares devem seguir os mesmos princípios de segurança que os aplicativos da Web comuns e devem ser auditados como tal. APIs específicas para ângulos que devem ser auditadas em uma revisão de segurança, como os métodos bypassSecurityTrust, são marcadas na documentação como confidenciais."
         }
      }
    },
    "Trabalhador de Serviço e PWA":{
      "Introdução ao Trabalhador de Serviço": [
        "Os trabalhadores de serviço aumentam o modelo tradicional de implantação na web e capacitam os aplicativos a oferecer uma experiência do usuário com a confiabilidade e o desempenho iguais aos códigos instalados originalmente.",
        "Adicionar um trabalhador de serviço a um aplicativo Angular é uma das etapas para transformar um aplicativo em um Aplicativo Web Progressivo (também conhecido como PWA).",
        "Um trabalhador de serviço é um script que é executado no navegador da web e gerencia o cache de um aplicativo.",
        "Os trabalhadores do serviço funcionam como um proxy de rede, eles interceptam todas as solicitações HTTP de saída feitas pelo aplicativo e podem escolher como responder a elas.",
        "Eles podem consultar um cache local e fornecer uma resposta em cache, se houver um disponível.",
        "O proxy não se limita a solicitações feitas por APIs programáticas, como fetch; também inclui recursos referenciados em HTML e até a solicitação inicial para index.html.",
        "O armazenamento em cache baseado no trabalhador de serviço é completamente programável e não depende de cabeçalhos de armazenamento em cache especificados pelo servidor.",
        "O trabalhador do serviço é preservado depois que o usuário fecha a guia, diferente dos outros scripts que compõem um aplicativo, como o pacote de aplicativos Angular.",
        "Na próxima vez que o navegador carregar o aplicativo, o responsável pelo serviço carregará primeiro e poderá interceptar todas as solicitações de recursos para carregar o aplicativo.",
        "Se o responsável pelo serviço for projetado para isso, ele poderá satisfazer completamente o carregamento do aplicativo, sem a necessidade da rede .",
        "Mesmo em uma rede rápida e confiável, os atrasos de ida e volta podem introduzir uma latência significativa ao carregar o aplicativo.",
        "Usar um técnico de serviço para reduzir a dependência da rede pode melhorar significativamente a experiência do usuário."
      ],
      "Trabalhadores de Serviço em Angular":[
        "Os aplicativos angulares, como aplicativos de página única, estão em uma posição privilegiada para se beneficiar das vantagens dos profissionais de serviço.",
        "A partir da versão 5.0.0, o Angular é enviado com uma implementação de trabalhador de serviço. Os desenvolvedores angulares podem tirar proveito desse prestador de serviços e se beneficiar da maior confiabilidade e desempenho que ele fornece, sem precisar codificar contra APIs de baixo nível",
        "O profissional de serviço da Angular foi projetado para otimizar a experiência do usuário final do uso de um aplicativo em uma conexão de rede lenta ou não confiável, além de minimizar os riscos de veicular conteúdo desatualizado.",
        "O comportamento do trabalhador do serviço Angular segue alguns objetivos de projeto.",
        {
          "Objetivos": [
            "Armazenar em cache um aplicativo é como instalar um aplicativo nativo. O aplicativo é armazenado em cache como uma unidade e todos os arquivos são atualizados juntos.",
            "Um aplicativo em execução continua sendo executado com a mesma versão de todos os arquivos. De repente, ele não começa a receber arquivos em cache de uma versão mais recente, provavelmente incompatível.",
            "Quando os usuários atualizam o aplicativo, eles veem a última versão totalmente em cache. Novas guias carregam o código em cache mais recente.",
            "As atualizações acontecem em segundo plano, relativamente rapidamente após a publicação das alterações. A versão anterior do aplicativo é veiculada até que uma atualização esteja instalada e pronta.",
            "O responsável pelo serviço conserva a largura de banda quando possível. Os recursos são baixados apenas se forem alterados."
          ]
        },
        "Para dar suporte a esses comportamentos, o responsável pelo serviço Angular carrega um arquivo de manifesto do servidor.",
        "O manifesto descreve os recursos para armazenar em cache e inclui hashes do conteúdo de todos os arquivos.",
        "Quando uma atualização para o aplicativo é implantada, o conteúdo do manifesto é alterado, informando o responsável pelo serviço que uma nova versão do aplicativo deve ser baixada e armazenada em cache.",
        "O manifesto é gerado a partir de um arquivo de configuração gerado pela CLI chamado ngsw-config.json."
      ],
      "Pré-Requisitos":[
        "Para usar todos os recursos do trabalhador de serviço Angular, use as versões mais recentes do Angular e da CLI Angular.",
        "Para que os trabalhadores do serviço sejam registrados, o aplicativo deve ser acessado por HTTPS, não por HTTP.",
        {
          "Observações":[
            "Os navegadores ignoram os funcionários de serviço em páginas que são veiculadas em uma conexão não segura.",
            "O motivo é que os trabalhadores do serviço são bastante poderosos, portanto, é necessário um cuidado extra para garantir que o script do trabalhador do serviço não seja violado.",
            "Para facilitar o desenvolvimento local, os navegadores não exigem uma conexão segura ao acessar um aplicativo localhost."
          ]
        }
      ],
      "Suporte do Navegador":[
        "Para se beneficiar do trabalhador do serviço Angular, seu aplicativo deve ser executado em um navegador da Web que ofereça suporte a trabalhadores do serviço em geral.",
        "Atualmente, os profissionais de serviço são suportados nas versões mais recentes do Chrome, Firefox, Edge, Safari, Opera, UC Browser (versão Android) e Samsung Internet, com exceção dos navegadores como o IE e o Opera Mini que não oferecem suporte a trabalhadores de serviço.",
        "Se o usuário estiver acessando seu aplicativo por meio de um navegador que não oferece suporte a trabalhadores de serviço, ele não será registrado e o comportamento relacionado, como gerenciamento de cache offline e notificações por push, não ocorrerá.",
        "É altamente recomendável garantir que seu aplicativo funcione mesmo sem o suporte do operador de serviço no navegador, embora um navegador não suportado ignore o cache do trabalhador de serviço, ele ainda reportará erros se o aplicativo tentar interagir com o trabalhador de serviço."
      ],
      "Shell do Aplicativo":[
        "O shell do aplicativo é uma maneira de renderizar uma parte do seu aplicativo por meio de uma rota no momento da criação.",
        "Ele pode melhorar a experiência do usuário iniciando rapidamente uma página renderizada estática (um esqueleto comum a todas as páginas) enquanto o navegador baixa a versão completa do cliente e muda automaticamente para ela após o carregamento do código.",
        "Isso fornece aos usuários uma primeira pintura significativa do seu aplicativo que aparece rapidamente, porque o navegador pode simplesmente renderizar o HTML e o CSS sem a necessidade de inicializar nenhum JavaScript."
      ],
      "Comunicação com o Trabalhador de Serviço":{
        "ServiceWorkerModule": "A importação ServiceWorkerModule para o seu site AppModulenão apenas registra o trabalhador do serviço, mas também fornece alguns serviços que você pode usar para interagir com o trabalhador do serviço e controlar o cache do seu aplicativo.",
        "Serviço SwUpdate": "O SwUpdateserviço fornece acesso a eventos que indicam quando o responsável pelo serviço descobriu uma atualização disponível para o seu aplicativo ou quando ativou essa atualização - o que significa que agora ele está veiculando conteúdo dessa atualização para o seu aplicativo.",
        "Operações do SwUpdate": [
          "Ser notificado de atualizações disponíveis . Estas são novas versões do aplicativo a serem carregadas se a página for atualizada.",
          "Ser notificado sobre a ativação da atualização . É quando o trabalhador do serviço começa a veicular uma nova versão do aplicativo imediatamente.",
          "Solicitar ao trabalhador do serviço que verifique se há novas atualizações no servidor.",
          "Solicitar ao trabalhador do serviço para ativar a versão mais recente do aplicativo para a guia atual."
        ],
        "Atualizações Disponíveis e Ativadas": "Os dois eventos de atualização 'available' e 'activated' são propriedades 'Observable' de SwUpdate e você pode usar esses eventos para notificar o usuário sobre uma atualização pendente ou atualizar suas páginas quando o código em execução estiver desatualizado.",
        "Verificando Atualizações": [
          "É possível solicitar ao responsável pelo serviço que verifique se alguma atualização foi implantada no servidor.",
          "Você pode optar por fazer isso se tiver um site que mude frequentemente ou desejar que as atualizações ocorram dentro de um cronograma.",
          "O método 'checkForUpdate()' retorna uma Promise que indica que a verificação da atualização foi concluída com êxito, embora não indique se uma atualização foi descoberta como resultado da verificação."
        ],
        "Forçando a Ativação da Atualização": "Se a guia atual precisar ser atualizada para a versão mais recente do aplicativo imediatamente, é possível solicitar isso com o ,étodo activateUpdate(), isso pode interromper o carregamento lento nos aplicativos em execução no momento, especialmente se os pedaços carregados com o uso lento usarem nomes de arquivos com hashes, que alteram todas as versões."
      },
      "Ambiente de Produção":{
        "Introdução":[
          "Conceitualmente, você pode imaginar o trabalhador do serviço Angular como um cache de encaminhamento ou uma borda da CDN instalada no navegador da web do usuário final.",
          "A tarefa do trabalhador de serviço é atender a solicitações feitas pelo aplicativo Angular para obter recursos ou dados de um cache local, sem a necessidade de aguardar a rede.",
          "Como qualquer cache, ele possui regras sobre como o conteúdo expira e atualiza."
        ],
        "Versões de Aplicativos":[
          "No contexto de um trabalhador de serviço Angular, uma 'versão' é uma coleção de recursos que representam uma compilação específica do aplicativo Angular.",
          "Sempre que uma nova compilação do aplicativo é implantada, o responsável pelo serviço trata essa compilação como uma nova versão do aplicativo, isso ocorre mesmo que apenas um único arquivo seja atualizado.",
          "A qualquer momento, o responsável pelo serviço pode ter várias versões do aplicativo em seu cache e pode fornecê-las simultaneamente.",
          "Para preservar a integridade do aplicativo, o trabalhador do serviço Angular agrupa todos os arquivos em uma versão, os arquivos agrupados em uma versão geralmente incluem arquivos HTML, JS e CSS.",
          "O agrupamento desses arquivos é essencial para a integridade, pois os arquivos HTML, JS e CSS frequentemente se referem um ao outro e dependem de conteúdo específico.",
          "Essa integridade do arquivo é especialmente importante ao carregar módulos preguiçosamente.",
          "Um pacote JS pode fazer referência a muitos trechos preguiçosos, e os nomes de arquivos dos trechos preguiçosos são exclusivos para a compilação específica do aplicativo, de modo que, se um aplicativo em execução na versão 'X' tentar carregar um pedaço lento, mas o servidor já tiver atualizado para a versão X + 1, a operação de carregamento lento falhará.",
          "O identificador de versão do aplicativo é determinado pelo conteúdo de todos os recursos e muda se algum deles mudar, na prática, a versão é determinada pelo conteúdo do arquivo ngsw.json, que inclui hashes para todo o conteúdo conhecido.",
          "Se algum dos arquivos em cache for alterado, o hash do arquivo será alterado ngsw.json, fazendo com que o responsável pelo serviço Angular trate o conjunto ativo de arquivos como uma nova versão.",
          "Com o comportamento de versão do trabalhador do serviço Angular, um servidor de aplicativos pode garantir que o aplicativo Angular sempre tenha um conjunto consistente de arquivos."
        ],
        "Verificações de Atualizações": "Sempre que o usuário abre ou atualiza o aplicativo, o responsável pelo serviço Angular verifica se há atualizações no aplicativo procurando atualizações no ngsw.jsonmanifesto. Se uma atualização for encontrada, ela será baixada e armazenada em cache automaticamente e será veiculada na próxima vez que o aplicativo for carregado.",
        "Integridade de Recursos":[
          "Um dos possíveis efeitos colaterais do armazenamento em cache longo é o armazenamento descuidado em cache de um recurso inválido.",
          "Em um cache HTTP normal, uma atualização forçada ou a expiração do cache limitam os efeitos negativos do armazenamento em cache de um arquivo inválido., um funcionário do serviço ignora essas restrições e efetivamente armazena em cache por muito tempo o aplicativo inteiro, conseqüentemente, é essencial que o responsável pelo serviço obtenha o conteúdo correto.",
          "Para garantir a integridade dos recursos, o responsável pelo serviço Angular valida os hashes de todos os recursos para os quais possui um hash, normalmente, para um aplicativo criado com a CLI Angular, ou seja, tudo no diretório 'dist' coberto pela configuração do usuário no 'src/ngsw-config.json'.",
          "Se um arquivo específico falhar na validação, o responsável pelo serviço Angular tenta buscar novamente o conteúdo usando um parâmetro de URL 'impedimento de cache' para eliminar os efeitos do navegador ou do cache intermediário, se esse conteúdo também falhar na validação, o responsável pelo serviço considera a versão inteira do aplicativo inválida e para de veicular o aplicativo.",
          "Se necessário, o responsável pelo serviço entra em um modo seguro em que as solicitações retornam à rede, optando por não usar seu cache se o risco de veicular conteúdo inválido, quebrado ou desatualizado for alto."
        ],
        "Conteúdo Unhashed": [
          "Os únicos recursos que possuem hashes no manifesto 'ngsw.json' são os que estavam presentes no diretório 'dist' no momento em que o manifesto foi criado.",
          "Outros recursos, especialmente aqueles carregados de CDNs, têm conteúdo desconhecido no momento da criação ou são atualizados com mais frequência do que o aplicativo é implantado.",
          "Se o trabalhador do serviço Angular não tiver um hash para validar um determinado recurso, ele ainda armazenará em cache seu conteúdo, mas honrará os cabeçalhos de cache HTTP usando uma política de 'obsoleto ao revalidar'.",
          "Quando os cabeçalhos de cache HTTP de um recurso em cache indicam que o recurso expirou, o trabalhador do serviço Angular continua a servir o conteúdo e tenta atualizar o recurso em segundo plano, dessa forma, recursos quebrados com unhashed não permanecem no cache além da vida útil configurada."
        ],
        "Abas de Aplicativos":[
          "Pode ser problemático para um aplicativo se a versão dos recursos que está recebendo mudar de repente ou sem aviso prévio.",
          "O responsável pelo serviço Angular fornece uma garantia: um aplicativo em execução continuará executando a mesma versão do aplicativo.",
          "Se outra instância do aplicativo for aberta em uma nova guia do navegador da Web, a versão mais atual do aplicativo será veiculada.",
          "Como resultado, essa nova guia pode estar executando uma versão diferente do aplicativo que a guia original.",
          "É importante observar que essa garantia é mais forte do que a fornecida pelo modelo normal de implantação na web.",
          "Sem um técnico de serviço, não há garantia de que o código carregado lentamente posteriormente em um aplicativo em execução seja da mesma versão que o código inicial do aplicativo."
        ],
        "Atualizações do Trabalhador de Serviço":[
          "O trabalhador do serviço Angular é um pequeno script executado em navegadores da web. Periodicamente, o responsável pelo serviço será atualizado com correções de bugs e aprimoramentos de recursos.",
          "O trabalhador do serviço Angular é baixado quando o aplicativo é aberto pela primeira vez e quando o aplicativo é acessado após um período de inatividade. Se o trabalhador do serviço tiver sido alterado, ele será atualizado em segundo plano.",
          "A maioria das atualizações para o trabalhador do serviço Angular é transparente para o aplicativo - os caches antigos ainda são válidos e o conteúdo ainda é exibido normalmente, no entanto, ocasionalmente, um recurso ou correção de bug no trabalhador do serviço Angular requer a invalidação de caches antigos. Nesse caso, o aplicativo será atualizado de forma transparente a partir da rede."
        ],
        "Ignorando o Trabalhador de Serviço":[
          "Em alguns casos, você pode querer ignorar completamente o responsável pelo serviço e deixar que o navegador lide com a solicitação.",
          "Para ignorar o trabalhador do serviço, você pode definir ngsw-bypasscomo um cabeçalho de solicitação ou como um parâmetro de consulta, o valor do cabeçalho ou parâmetro de consulta é ignorado e pode estar vazio ou omitido."
        ],
        "Depurando o Trab. do Serviço Angular": "Ocasionalmente, pode ser necessário examinar o trabalhador do serviço Angular em um estado de execução para investigar problemas ou garantir que ele esteja operando conforme projetado. Os navegadores fornecem ferramentas internas para os trabalhadores do serviço de depuração e o próprio trabalhador do serviço Angular inclui recursos úteis de depuração.",
        "Configuração do Trabalhador de serviço": "O ngsw-config.jsonarquivo de configuração especifica quais arquivos e URLs de dados o trabalhador do serviço Angular deve armazenar em cache e como deve atualizar os arquivos e dados em cache. A CLI Angular processa o arquivo de configuração durante 'ng build --prod' ... mais informações em: https://angular.io/guide/service-worker-config;"
      }
    },
    "Internacionalização (i18n)":{
       "Conceito": "A internacionalização de aplicativos é uma área de desenvolvimento multifacetada, focada em tornar os aplicativos disponíveis e fáceis de usar para um público mundial.",
       "Internacionalização": "É o processo de projetar e preparar seu aplicativo para ser usado em diferentes idiomas.",
       "Localização": "É o processo de tradução do aplicativo internacionalizado para idiomas específicos para localidades específicas.",
       "Simplificações do Angular":[
         "Exibindo datas, número, porcentagens e moedas em um formato local.",
         "Preparando texto em modelos de componentes para tradução.",
         "Manipulação de formas plurais de palavras.",
         "Manipulação de texto alternativo."
       ],
       "Configuração":{
         "Informações Relevantes": [ 
            "Angular segue a convenção LDML Unicode que usa identificadores estáveis ​​(identificadores de código de idioma Unicode) com base na norma BCP47",
            "É muito importante que você siga esta convenção ao definir seu código de idioma, porque as ferramentas Angular i18n usam esse código de idioma para encontrar os dados de código de idioma correspondentes corretos."
         ],
         "Localização": "A primeira etapa para configurar a localização ao usar a CLI Angular é adicionar o pacote '@angular/localize' ao projeto - isso instalará o pacote no seu projeto, além de inicializar o projeto para aproveitar os recursos de localização do Angular.",
         "Localidade": [
            "Um código de idioma é um identificador (ID) que se refere a um conjunto de preferências do usuário que tendem a ser compartilhadas em uma região do mundo, como país - este documento refere-se a um identificador de localidade como 'locale' ou 'locale id'.",
            "Um identificador de localidade Unicode é composto por um identificador de idioma Unicode e (opcionalmente) pelo caractere - seguido por uma extensão de localidade. (Por razões históricas, o caractere _ é suportado como uma alternativa a -.)",
            "Por exemplo, no código de idioma fr-CA, fr refere-se ao identificador de idioma francês e o CA refere-se à extensão de código de idioma Canadá.",
            "Por padrão, Angular usa o código de idioma en-US, que é o inglês falado nos Estados Unidos da América."
         ]
      },
      "Pipes i18n": [
         "Os pipes angulares podem ajudá-lo com a internacionalização: o DatePipe, CurrencyPipe, DecimalPipe e PercentPipe usam dados de localidade para formatar dados com base no token de injeção de dependência LOCALE_ID.",
         "Por padrão, o Angular contém apenas dados de localidade para en-US ... a CLI inclui automaticamente os dados do código do idioma e define o valor LOCALE_ID para você quando você usa o parâmetro '--i18nLocale' ou a opção 'i18nLocale' com 'ng serve' e 'ng build'.",
         "Você pode definir manualmente o valor de LOCALE_ID para outro código de idioma, para isso deverá importar dados de código de idioma para esse novo código de idioma.",
         "Os arquivos em '@angular/common/locales' contêm a maioria dos dados de localidade de que você precisa, mas algumas opções avançadas de formatação podem estar disponíveis apenas no conjunto de dados extra que você pode importar de @angular/common/locales/extra ... uma mensagem de erro é exbida quando for esse o caso.",
         "O Ivy incluirá automaticamente os dados extras do código do idioma se o código do idioma foi configurado via i18nLocale."
      ],
      "Pluralização": "Idiomas diferentes têm regras diferentes de pluralização e construções gramaticais que adicionam complexidade à tarefa de tradução - você pode usar expressões regulares com as cláusulas plural e select para fornecer padrões que auxiliam na tradução nesses casos."
    },
    "Acessibilidade":{
      "Introdução": [
         "A web é usada por uma grande variedade de pessoas, incluindo aquelas que apresentam deficiências visuais ou motoras.",
         "Está disponível uma variedade de tecnologias de assistência que facilitam muito a interação desses grupos com aplicativos de software baseados na Web.",
         "Projetar um aplicativo para ser mais acessível geralmente melhora a experiência do usuário para todos os usuários."
      ],
      "Atributos de Acessbilidade":[
         "A construção de experiência na Web acessível geralmente envolve a configuração de atributos ARIA para fornecer significado semântico onde, de outra forma, poderia estar ausente.",
         "Use a sintaxe do modelo de ligação de atributo para controlar os valores dos atributos relacionados à acessibilidade.",
         "Ao vincular aos atributos ARIA em Angular, você deve usar o prefixo 'attr.', pois a especificação ARIA depende especificamente dos atributos HTML, e não das propriedades dos elementos DOM."
      ],
      "Componentes de UI":[
         "A biblioteca Angular Material, mantida pela equipe Angular, é um conjunto de componentes reutilizáveis ​​da interface do usuário que visa ser totalmente acessível.",
         "O CDK (Component Development Kit) inclui o pacote a11y que fornece ferramentas para oferecer suporte a várias áreas de acessibilidade."
      ],
      "Gerenciamento de Foco e Roteamento":[
         "Rastrear e controlar o foco em uma interface do usuário é uma consideração importante no design para acessibilidade.",
         "Ao usar o roteamento angular, você deve decidir para onde o foco da página é direcionado à navegação.",
         "Para evitar confiar apenas em pistas visuais, é necessário garantir que as atualizações do código de roteamento fiquem após a navegação na página.",
         "Use o evento NavigationEnd do serviço Roteador para saber quando atualizar o foco.",
         "Em um aplicativo real, o elemento que recebe o foco dependerá da estrutura e do layout específicos do aplicativo.",
         "O elemento focado deve colocar os usuários em uma posição para migrar imediatamente para o conteúdo principal que acabou de ser roteado para exibição.",
         "Você deve evitar situações em que o foco retorne ao elemento do corpo após uma alteração de rota."
      ]
    },
    "Renderização Serve-Side (SSR)":{
       "(SSR) com Angular Universal":{
         "O que é ?": "Angular Universal é uma tecnologia que renderiza aplicativos Angular no servidor.",
         "Introdução":[
            "Um aplicativo Angular normal é executado no navegador, renderizando páginas no DOM em resposta às ações do usuário.",
            "O Angular Universal é executado no servidor, gerando páginas de aplicativos estáticos que posteriormente são inicializados no cliente.",
            "Isso significa que o aplicativo geralmente é renderizado mais rapidamente, dando aos usuários a chance de visualizar o layout do aplicativo antes que ele se torne totalmente interativo.",
            "Para uma visão mais detalhada das diferentes técnicas e conceitos que envolvem o SSR, confira este artigo: 'https://developers.google.com/web/updates/2019/02/rendering-on-the-web'.",
            "Você pode facilmente preparar um aplicativo para renderização no servidor usando a CLI Angular.",
            "O mecanismo esquemático da CLI '@nguniversal/express-engine' executa as etapas necessárias."
         ],
         "Por que usar SSR ?":{
            "Razões":{
               "SEO": [
                  "Facilite os rastreadores da web por meio da otimização do mecanismo de pesquisa (SEO)",
                  "Google, Bing, Facebook, Twitter e outros sites de mídia social contam com rastreadores da Web para indexar o conteúdo do aplicativo e torná-lo pesquisável na Web. Esses rastreadores da Web podem não conseguir navegar e indexar seu aplicativo Angular altamente interativo, como um usuário humano poderia fazer.",
                  "O Angular Universal pode gerar uma versão estática do seu aplicativo que é facilmente pesquisável, vinculável e navegável sem JavaScript.",
                  "A Universal também disponibiliza uma visualização do site, pois cada URL retorna uma página totalmente renderizada."
               ],
               "Desempenho": [
                  "Melhore o desempenho em dispositivos móveis e de baixa potência",
                  "Alguns dispositivos não suportam JavaScript ou executam JavaScript tão mal que a experiência do usuário é inaceitável.",
                  "Nesses casos, você pode exigir uma versão do aplicativo sem JavaScript renderizada pelo servidor.",
                  "Esta versão, embora limitada, pode ser a única alternativa prática para pessoas que de outra forma não poderiam usar o aplicativo."
               ],
               "Carregamento": [
                  "Mostre a primeira página rapidamente com uma primeira tinta com conteúdo (FCP)",
                  "Exibir a primeira página rapidamente pode ser crítico para o envolvimento do usuário.",
                  "As páginas que carregam mais rapidamente apresentam melhor desempenho, mesmo com alterações tão pequenas quanto 100 ms.",
                  "Com o Angular Universal, você pode gerar páginas de destino para o aplicativo que se parecem com o aplicativo completo.",
                  "As páginas são HTML puro e podem ser exibidas mesmo se o JavaScript estiver desativado.",
                  "As páginas não lidam com eventos do navegador, mas suportam a navegação pelo site usando o routerLink.",
                  "Na prática, você exibirá uma versão estática da página de destino para prender a atenção do usuário ... ao mesmo tempo, você carregará o aplicativo Angular completo por trás dele.",
                  "O usuário percebe um desempenho quase instantâneo na página de destino e obtém a experiência interativa completa após o carregamento completo do aplicativo."
               ]
            }
         },
         "Procedimentos":[
            "Um servidor da Web Universal responde a solicitações de páginas de aplicativos com HTML estático processado pelo mecanismo de modelo Universal.",
            "O servidor recebe e responde às solicitações HTTP dos clientes (geralmente navegadores) e serve ativos estáticos, como scripts, CSS e imagens.",
            "Pode responder a solicitações de dados, diretamente ou como um proxy para um servidor de dados separado.",
            "Os aplicativos universais usam o pacote Angular platform-server (em oposição ao navegador da plataforma), que fornece implementações de servidor do DOM, XMLHttpRequest e outros recursos de baixo nível que não dependem de um navegador.",
            "O servidor passa solicitações de clientes para páginas de aplicativos para o ngExpressEngine do NgUniversal ... sob o capô, isso chama a função renderModule() da Universal, enquanto fornece armazenamento em cache e outros utilitários úteis.",
            "A função renderModule() recebe como entrada uma página HTML de modelo (geralmente index.html), um módulo Angular contendo componentes e uma rota que determina quais componentes exibir ... a rota vem da solicitação do cliente para o servidor.",
            "Cada solicitação resulta na exibição apropriada para a rota solicitada. A função renderModule() renderiza a exibição na tag <app> do modelo, criando uma página HTML finalizada para o cliente.",
            "Finalmente, o servidor retorna a página renderizada para o cliente."
         ],
         "Trabalhando com as APIS do Navegador":[
            "Como um aplicativo Universal não é executado no navegador, algumas APIs e recursos do navegador podem estar ausentes no servidor.",
            "Aplicativos do lado do servidor não podem fazer referência a objetos globais apenas do navegador, como janela, documento, navegador ou local.",
            "Angular fornece algumas abstrações injetáveis ​​sobre esses objetos, como Location ou DOCUMENT; pode substituir adequadamente essas APIs.",
            "Se o Angular não fornecer, é possível escrever novas abstrações que delegam nas APIs do navegador enquanto estão no navegador e em uma implementação alternativa no servidor (também conhecido como shimming).",
            "Sem eventos de mouse ou teclado, um aplicativo do servidor não pode confiar em um usuário clicar em um botão para mostrar um componente.",
            "O aplicativo deve determinar o que renderizar com base unicamente na solicitação de entrada do cliente. Este é um bom argumento para tornar o aplicativo roteável."
         ],
         "URLS Absolutas":[
            "Em um aplicativo Universal, os URLs HTTP devem ser absolutos (por exemplo, https://my-server.com/api/heroes).",
            "Você precisa alterar seus serviços para fazer solicitações com URLs absolutos ao executar no servidor e com URLs relativos ao executar no navegador.",
            "Uma solução é fornecer a URL completa para seu aplicativo no servidor e escrever um interceptador que possa recuperar esse valor e anexá-lo à URL de solicitação."
         ],
         "Mecanismo de modelo universal":[
            "A função ngExpressEngine() é um invólucro da função renderModule() da Universal que transforma as solicitações de um cliente em páginas HTML renderizadas pelo servidor.",
            "O 1º parâmetro da função ngExpressEngine() é AppServerModule, e é a ponte entre o renderizador universal do lado do servidor e o aplicativo Angular.",
            "O 2º parâmetro da função ngExpressEngine() é extraProviders, e é opcional, mas permite especificar provedores de dependência que se aplicam apenas ao executar neste servidor.",
            "Com extraProviders, você pode fazer isso quando o aplicativo precisar de informações que só podem ser determinadas pela instância do servidor em execução no momento. Um exemplo pode ser a origem do servidor em execução, que pode ser usada para calcular URLs HTTP absolutas se não estiver usando o token de solicitação.",
            "A função ngExpressEngine() retorna um retorno de chamada Promise que resolve para a página renderizada, cabe ao mecanismo decidir o que fazer com essa página.",
            "O retorno de chamada Promise desse mecanismo retorna a página renderizada para o servidor da Web, que a encaminha para o cliente na resposta HTTP."
         ],
         "Servindo Arquivos Estáticos Seguros":[
            "Um único app.use() trata todos os outros URLs como solicitações de ativos estáticos, como JavaScript, imagem e arquivos de estilo.",
            "Para garantir que os clientes possam baixar apenas os arquivos que têm permissão para ver, coloque todos os arquivos de ativos voltados para o cliente na pasta '/dist' e apenas respeite as solicitações de arquivos da pasta '/dist'.",
            "O seguinte código do Node Express roteia todas as solicitações restantes para '/dist' e retorna um erro 404 - NÃO ENCONTRADO se o arquivo não for encontrado - código: server.get('*.*', express.static(distFolder, {maxAge: '1y'}));"
         ]
      }
    },
    "Esquemas (Schematics)":{
      "Visão Geral":{
        "O que é ?": [
          "Um esquema é um gerador de código baseado em modelo que suporta lógica complexa.",
          "Um conjunto de instruções para transformar um projeto de software gerando ou modificando código, e são empacotados em coleções e instalados com o npm."
        ],
        "Informações Relevantes": [
          "A coleção esquemática pode ser uma ferramenta poderosa para criar, modificar e manter qualquer projeto de software, mas é particularmente útil para personalizar projetos Angular para atender às necessidades específicas de sua própria organização.",
          "Você pode usar esquemas, por exemplo, para gerar padrões de interface do usuário comumente usados ​​ou componentes específicos, usando modelos ou layouts predefinidos.",
          "Você pode usar esquemas para aplicar regras e convenções arquiteturais, tornando seus projetos consistentes e interoperacionais.",
          "Esquemas fazem parte do ecossistema Angular ... a CLI do Angular usa esquemas para aplicar transformações a um projeto de aplicativo da web.",
          "Você pode modificar esses esquemas e definir novos para fazer coisas como atualizar seu código para corrigir alterações recentes em uma dependência, por exemplo, ou para adicionar uma nova opção ou estrutura de configuração a um projeto existente.",
          "Os esquemas incluídos na coleção '@schematics/angular' são executados por padrão pelos comandos ng generate e ng add.",
          "O pacote '@schematics/angular' contém esquemas nomeados que configuram as opções disponíveis para a CLI para subcomandos ng generate, como ng generate component e ng generate service, e os subcomandos para ng generate são atalhos para o esquema correspondente."
        ],
        "Configuração": [
          "Um esquema JSON associado a um esquema informa à CLI Angular quais opções estão disponíveis para comandos e subcomandos e determina os padrões.",
          "Esses padrões podem ser substituídos, fornecendo um valor diferente para uma opção na linha de comandos.",
          "Os esquemas JSON para os esquemas padrão usados ​​pela CLI para gerar projetos e partes de projetos são coletados no pacote '@schematics/angular.'",
          "O esquema descreve as opções disponíveis para a CLI para cada um dos subcomandos ng generate, como mostrado na saída --help."
        ],
        "Desenvolvendo Esquemas para Bibliotecas":[
          "Como desenvolvedor de bibliotecas, você pode criar suas próprias coleções de esquemas personalizados para integrar sua biblioteca à CLI Angular.",
          "Um esquema add permite que os desenvolvedores instalem sua biblioteca em um espaço de trabalho Angular usando ng add.",
          "Os esquemas de geração podem dizer aos subcomandos ng generate como modificar projetos, adicionar configurações e scripts e artefatos de andaime definidos em sua biblioteca.",
          "Um esquema de atualização pode dizer ao comando ng update como atualizar as dependências da sua biblioteca e ajustar as alterações mais recentes quando você lança uma nova versão."
        ],
        "Adição Esquemas":[
          "Um esquema add é normalmente fornecido com uma biblioteca, para que a biblioteca possa ser adicionada a um projeto existente com ng add.",
          "O comando add usa seu gerenciador de pacotes para baixar novas dependências e chama um script de instalação que é implementado como um esquema.",
          "Por exemplo, o esquema '@angular/material' informa ao comando add para instalar e configurar o Material Angular e o tema e registrar novos componentes iniciantes que podem ser criados com ng generate.",
          "As bibliotecas parceiras e de terceiros também oferecem suporte à CLI Angular com esquemas adicionais - por exemplo, o '@ng-bootstrap/schematics' adiciona o ng-bootstrap a um aplicativo e o '@clr/angular' instala e configura o Clarity no VMWare",
          "Um esquema de adição também pode atualizar um projeto com alterações de configuração, adicionar dependências adicionais (como polyfills) ou código de inicialização específico do pacote de andaime.",
          "Por exemplo, o esquema '@angular/pwa' transforma seu aplicativo em um PWA adicionando um manifesto de aplicativo e trabalhador de serviço, e o esquema '@angular/elements' adiciona o polyfill document-register-element.js e as dependências para elementos angulares."
        ],
        "Esquemas de Geração":[
          "Esquemas de geração são instruções para o comando ng generate.",
          "Os subcomandos documentados usam os esquemas de geração Angular padrão, mas você pode especificar um esquema diferente (no lugar de um subcomando) para gerar um artefato definido em sua biblioteca.",
          "O Angular Material, por exemplo, fornece esquemas de geração para os componentes da UI que ele define ... o comando 'ng generate @angular/material:table' por exemplo, usa um desses esquemas para renderizar um material angular <mat-table> pré-configurado com uma fonte de dados para classificação e paginação."
        ],
        "Atualização de Esquemas":[
          "O comando ng update pode ser usado para atualizar as dependências da biblioteca da área de trabalho.",
          "Se você não fornecer opções ou usar a opção de ajuda, o comando examinará sua área de trabalho e sugerirá a atualização de bibliotecas.",
          "Se você passar ao comando um conjunto de bibliotecas para atualizar (ou o sinalizador --all), ele atualizará essas bibliotecas, suas dependências de mesmo nível e as dependências de mesmo nível que dependem delas.",
          "Se houver inconsistências (por exemplo, se as dependências de pares não puderem corresponder a um intervalo simples de semver), o comando gerará um erro e não alterará nada na área de trabalho.",
          "O recomendado é que você não force uma atualização de todas as dependências por padrão. Tente atualizar dependências específicas primeiro.",
          "Se você criar uma nova versão da sua biblioteca que introduz possíveis alterações de interrupção, poderá fornecer um esquema de atualização para permitir que o comando ng update resolva automaticamente quaisquer alterações no projeto que está sendo atualizado."
        ]
      },
      "Criação de Esquemas":{
        "Informações Relevantes":[
          "Você pode criar seus próprios esquemas para operar em projetos angulares.",
          "Os desenvolvedores de bibliotecas geralmente empacotam esquemas com suas bibliotecas para integrá-los à CLI Angular.",
          "Você também pode criar esquemas independentes para manipular os arquivos e construções nos aplicativos Angular como uma maneira de personalizá-los para o seu ambiente de desenvolvimento e torná-los conformes aos seus padrões e restrições.",
          "Esquemas podem ser encadeados, executando outros esquemas para executar operações complexas.",
          "Manipular o código em um aplicativo tem o potencial de ser muito poderoso e correspondentemente perigoso - por exemplo, criar um arquivo que já existe seria um erro e, se fosse aplicado imediatamente, descartaria todas as outras alterações aplicadas até o momento.",
          "As ferramentas da Angular Schematics protegem contra efeitos colaterais e erros ao criar um sistema de arquivos virtual.",
          "Um esquema descreve um pipeline de transformações que podem ser aplicadas ao sistema de arquivos virtual - quando um esquema é executado, as transformações são registradas na memória e aplicadas apenas no sistema de arquivos real quando confirmadas como válidas."
        ],
        "Conceitos":{
          "Informações Relevantes":[
            "A API pública para esquemas define classes que representam os conceitos básicos.",
            "O objeto de contexto passado para uma regra fornece acesso às funções e metadados do utilitário com os quais o esquema pode precisar trabalhar, incluindo uma API de log para ajudar na depuração.",
            "O contexto também define uma estratégia de mesclagem que determina como as alterações são mescladas da árvore preparada na árvore base.",
            "Uma alteração pode ser aceita ou ignorada ou gerar uma exceção."
          ],
          "Conceitos Básicos":[
            "O sistema de arquivos virtual é representado por uma árvore -a estrutura de dados da árvore contém uma base (um conjunto de arquivos que já existe) e uma área intermediária (uma lista de alterações a serem aplicadas à base) - ao fazer modificações, na verdade você não altera a base, mas as adiciona à área de preparação.",
            "Um objeto de regra define uma função que pega uma árvore, aplica transformações e retorna uma nova árvore - o arquivo principal de um esquema, index.ts, define um conjunto de regras que implementam a lógica do esquema.",
            "Uma transformação é representada por uma ação - existem quatro tipos de ação: Criar, Renomear, Substituir e Excluir.",
            "Cada esquema é executado em um contexto, representado por um objeto SchematicContext."
          ]
        },
        "CLI Schematics":[
          "Esquemas vêm com sua própria ferramenta de linha de comando - usando o Node 6.9 ou superior, instale a ferramenta de linha de comando do Schematics globalmente: 'npm install -g @angular-devkit/schematics-cli'",
          "Isso instala o executável do esquema, que você pode usar para criar uma nova coleção de esquemas em sua própria pasta do projeto, adicionar um novo esquema a uma coleção existente ou estender um esquema existente."
        ]
      },
      "Esquemas para Bibliotecas":[
        "Ao criar uma biblioteca Angular, você pode fornecer e empacotá-la com esquemas que a integram à CLI Angular.",
        "Com seus esquemas, seus usuários podem usar ng add para instalar uma versão inicial da sua biblioteca, ng generate para criar artefatos definidos em sua biblioteca e ng update para ajustar o projeto deles para uma nova versão da sua biblioteca que introduz mudanças significativas - todos os três tipos de esquemas podem fazer parte de uma coleção que você empacota com sua biblioteca."
      ],
      "Artigo Relevante ": "https://medium.com/@ricardo.mello/schematics-criando-um-gerador-de-c%C3%B3digos-com-angular-introdu%C3%A7%C3%A3o-23fcad8e4ddb"
    },
    "Bibliotecas Angular":{
      "O que é ?": "Uma biblioteca Angular é um projeto Angular que difere de um aplicativo por não poder ser executado sozinho, devendo ser importada e usada em um aplicativo.",
      "Visão Geral": [
        "Muitos aplicativos precisam resolver os mesmos problemas gerais, como apresentar uma interface de usuário unificada, apresentar dados e permitir a entrada de dados.",
        "Os desenvolvedores podem criar soluções gerais para domínios específicos que podem ser adaptados para reutilização em aplicativos diferentes.",
        "Uma solução pode ser convertida em bibliotecas Angular e essas bibliotecas podem ser publicadas e compartilhadas como pacotes npm.",
        "As bibliotecas estendem a funcionalidade básica do Angula - por exemplo, para adicionar formulários reativos a um aplicativo, adicione o pacote da biblioteca usando 'ng add @angular/forms' e importe o ReactiveFormsModule da biblioteca '@angular/forms' no código do aplicativo.",
        "Adicionar a biblioteca de serviço a um aplicativo Angular é uma das etapas para transformar um aplicativo em um Aplicativo Web Progressivo (PWA).",
        "O Angular Material é um exemplo de uma grande biblioteca de uso geral que fornece componentes de interface do usuário sofisticados, reutilizáveis ​​e adaptáveis."
      ],
      "Informações de Desenvolvimento":[
        "Se você desenvolveu uma funcionalidade adequada para reutilização, pode criar suas próprias bibliotecas.",
        "Essas bibliotecas podem ser usadas localmente no seu espaço de trabalho ou você pode publicá-las como pacotes npm para compartilhar com outros projetos ou outros desenvolvedores Angular.",
        "Esses pacotes podem ser publicados no registro npm, em um registro corporativo npm privado ou em um sistema de gerenciamento de pacotes privado que suporte pacotes npm.",
        "Se você decide empacotar a funcionalidade como uma biblioteca é uma decisão arquitetural, semelhante a decidir se uma parte da funcionalidade é um componente ou serviço, ou decidir sobre o escopo de um componente.",
        "A funcionalidade de empacotamento como uma biblioteca força os artefatos da biblioteca a serem dissociados da lógica de negócios do aplicativo e isso pode ajudar a evitar várias práticas ruins ou erros de arquitetura que podem dificultar a dissociação e a reutilização de código no futuro.",
        "Colocar código em uma biblioteca separada é mais complexo do que simplesmente colocar tudo em um aplicativo, exige mais investimento em tempo e em consideração para gerenciar, manter e atualizar a biblioteca, mas essa complexidade pode compensar, no entanto, quando a biblioteca está sendo usada em vários aplicativos."
      ],
      "Informações de Instalação":[
        "As bibliotecas são publicadas como pacotes npm, geralmente juntamente com esquemas que os integram à CLI Angular.",
        "Para integrar código de biblioteca reutilizável em um aplicativo, você precisa instalar o pacote e importar a funcionalidade fornecida onde o usará.",
        "Para a maioria das bibliotecas Angular publicadas, você pode usar o comando Angular CLI ng add <lib_name>.",
        "O comando ng add usa o gerenciador de pacotes npm ou fio para instalar o pacote da biblioteca e chama esquemas que estão incluídos no pacote para outros andaimes no código do projeto, como adicionar instruções de importação, fontes, temas e assim por diante."
      ],
      "Declarações de Tipos":[
        "Artigo Relevante: https://medium.com/@oieduardorabelo/typescript-guia-para-declarac%CC%A7o%CC%83es-de-tipos-de-ambiente-7e54f070e5a6",
        "Em TypeScript, você pode receber vários erros sobre tipos de módulos não encontrado ou os “implíticos” any, que TypeScript não consegue inferir o tipo sem maiores informações",
        "Para resolver esse problema, você pode definir alguns tipos no seu projeto para descrever seus códigos, de modo que esses tipos geralmente são escritos em arquivos de declarações (*.d.ts), que contém apenas tipos e nenhum valor.",
        "Os pacotes de biblioteca geralmente incluem as tipografias nos arquivos '.d.ts' ... veja exemplos em 'node_modules/@angular/material'.",
        "Se o pacote da sua biblioteca não incluir tipografias e o seu IDE reclamar, pode ser necessário instalar o pacote @ types / <lib_name> associado à biblioteca.",
        "Os tipos definidos em um pacote '@types/' para uma biblioteca instalada na área de trabalho são automaticamente adicionados à configuração do TypeScript para o projeto que usa essa biblioteca.",
        "O TypeScript procura por tipos na pasta 'node_modules/@types' por padrão, para que você não precise adicionar cada pacote de tipos individualmente.",
        "Se uma biblioteca não tiver declarações de tipos disponíveis em '@types/', você ainda poderá usá-las adicionando-os manualmente - para fazer isso: Crie um arquivo 'typings.d.ts' na sua pasta 'src/' e este arquivo será incluído automaticamente como definição de tipo global."
      ],
      "Atualizando Bibliotecas": [
        "As bibliotecas podem ser atualizadas por seus editores e também possuem suas próprias dependências, que precisam ser mantidas atualizadas.",
        "Para verificar se há atualizações nas bibliotecas instaladas, use o comando ng update.",
        "Use 'ng update <lib_name>' para atualizar versões individuais da biblioteca.",
        "A CLI Angular verifica a versão mais recente publicada da biblioteca e, se a versão mais recente for mais recente que a versão instalada, faça o download e atualize seu package.json para corresponder à versão mais recente.",
        "Ao atualizar o Angular para uma nova versão, você precisa verificar se as bibliotecas que você está usando estão atualizadas, se as bibliotecas tiverem interdependências, talvez seja necessário atualizá-las em uma ordem específica."
      ],
      "Escopo Global em Tempo de Execução":[
        "Bibliotecas JavaScript herdadas que não são importadas para um aplicativo podem ser adicionadas ao escopo global do tempo de execução e carregadas como se estivessem em uma tag de script.",
        "Configure a CLI para fazer isso no momento da construção, usando as opções 'scripts' e 'styles' do destino da construção no arquivo de configuração da CLI, angular.json.",
        "Depois de importar uma biblioteca usando a matriz 'scripts', você NÃO DEVE importá-la usando uma instrução de importação no seu código TypeScript (como import * as $ from 'jquery';).",
        "Se você utilizar comando de importação tendo configurado sua biblioteca via matriz de 'scripts', você terá duas cópias diferentes da biblioteca: uma importada como uma biblioteca global e outra importada como um módulo.",
        "Isso é especialmente ruim para bibliotecas com plug-ins, como o JQuery, porque cada cópia terá plug-ins diferentes.",
        "Em vez disso, faça o download das digitações para sua biblioteca (npm install @ types / jquery) e siga as etapas de instalação da biblioteca. Isso fornece acesso às variáveis ​​globais expostas por essa biblioteca.",
        "Se a biblioteca global que você precisa usar não possui tipografias globais, você pode declará-las manualmente como em 'src/typings.d.ts'."
      ],
      "Criação de Bibliotecas":{
        "Introdução": [
          "Você pode criar e publicar novas bibliotecas para estender a funcionalidade Angular.",
          "Se você achar que precisa resolver o mesmo problema em mais de um aplicativo (ou deseja compartilhar sua solução com outros desenvolvedores), você tem um candidato a uma biblioteca.",
          "Um exemplo simples pode ser um botão que envia usuários ao site da sua empresa, que seria incluído em todos os aplicativos criados por sua empresa."
        ],
        "Procedimentos":[
          "Use a CLI angular para gerar um novo esqueleto da biblioteca com o seguinte comando: 'ng new my-workspace --create-application=false', 'cd my-workspace', e 'ng generate library my-lib'.",
          "Isso cria a pasta 'projects/my-lib' no seu espaço de trabalho, que contém um componente e um serviço dentro de um NgModule. O arquivo de configuração da área de trabalho, angular.json, é atualizado com um projeto do tipo 'biblioteca'.",
          "Você pode rodar 'buil', 'test' e 'lint' no projeto com os comandos da CLI seguido pelo nome da biblioteca"
        ],
        "Considerações":[
          "O construtor ('builder') configurado para o projeto é diferente do construtor padrão para projetos de aplicativos.",
          "Esse construtor, entre outras coisas, garante que a biblioteca seja sempre criada com o compilador AOT, sem a necessidade de especificar o sinalizador --prod.",
          "Para tornar o código da biblioteca reutilizável, você deve definir uma API pública para ele, essa 'camada de usuário' define o que está disponível para os consumidores da sua biblioteca.",
          "Um usuário da sua biblioteca deve poder acessar a funcionalidade pública (como NgModules, provedores de serviços e funções de utilidade geral) através de um único caminho de importação.",
          "A API pública da sua biblioteca é mantida no arquivo public-api.ts na sua pasta da biblioteca, qualquer coisa exportada desse arquivo é tornada pública quando sua biblioteca é importada para um aplicativo - use um NgModule para expor serviços e componentes.",
          "Sua biblioteca deve fornecer documentação (normalmente um arquivo LEIA-ME) para instalação e manutenção."
        ],
        "Refatorando um App em uma Biblioteca":[
          "Para tornar sua solução reutilizável, é necessário ajustá-la para que não dependa do código específico do aplicativo.",
          "Declarações como componentes e tubulações devem ser projetadas como apátridas, o que significa que elas não dependem ou alteram variáveis ​​externas.",
          "Se você confiar no estado, precisará avaliar todos os casos e decidir se é o estado ou estado do aplicativo que a biblioteca gerenciaria.",
          "Quaisquer observáveis ​​assinados internamente pelos componentes devem ser limpos e descartados durante o ciclo de vida desses componentes.",
          "Os componentes devem expor suas interações por meio de entradas para fornecer contexto e saídas para comunicar eventos a outros componentes.",
          "Os serviços devem declarar seus próprios provedores (em vez de declarar provedores no NgModule ou em um componente), para que possam ser tremendos em árvore. Isso permite que o compilador deixe o serviço fora do pacote, se ele nunca for injetado no aplicativo que importa a biblioteca.",
          "Se você registrar provedores de serviços globais ou compartilhar provedores em vários NgModules, use os padrões forRoot() e forChild() fornecidos pelo RouterModule.",
          "Dependências Internas: para classes ou interfaces personalizadas usadas em componentes ou serviços, verifique se elas dependem de classes ou interfaces adicionais que também precisam ser migradas.",
          "Dependências Internas: se o código da sua biblioteca depender de um serviço, esse serviço precisará ser migrado.",
          "Dependências Internas: se o código da sua biblioteca ou seus modelos dependem de outras bibliotecas (como um Material Angular, por exemplo), você deve configurar sua biblioteca com essas dependências."
        ],
        "Código e Esquemas Reutilizáveis":[
          "A biblioteca geralmente inclui código reutilizável que define componentes, serviços e outros artefatos angulares (canais, diretivas etc.) que você simplesmente importa para um projeto.",
          "Uma biblioteca é empacotada em um pacote npm para publicação e compartilhamento, e este pacote também pode incluir esquemas que fornecem instruções para gerar ou transformar código diretamente em seu projeto, da mesma maneira que a CLI cria um aplicativo esqueleto genérico com o componente ng generate.",
          "Um esquema que é combinado com uma biblioteca pode, por exemplo, fornecer à CLI Angular as informações necessárias para gerar um componente específico definido nessa biblioteca.",
          "O que você inclui na sua biblioteca é determinado pelo tipo de tarefa que você está tentando realizar - por exemplo, se você quiser uma lista suspensa com alguns dados enlatados para mostrar como adicioná-los ao seu aplicativo, sua biblioteca poderá definir um esquema para criá-los.",
          "Para um componente como um menu suspenso que conteria valores passados ​​diferentes a cada vez, você poderia fornecê-lo como um componente em uma biblioteca compartilhada.",
          "Em geral, quanto mais complexa a personalização, mais útil é a abordagem esquemática."
        ],
        "Integrando com a CLI":[
          "Uma biblioteca pode incluir esquemas que permitem a integração com a CLI Angular.",
          "Pode incluir esquema de instalação para que ng add possa adicionar sua biblioteca a um projeto.",
          "Pode incluir esquemas de geração em sua biblioteca para que ng generate possa montar seus artefatos definidos (componentes, serviços, testes e assim por diante) em um projeto.",
          "Pode incluir esquema de atualização para que a atualização ng possa atualizar as dependências da sua biblioteca e fornecer migrações para interromper as alterações em novos lançamentos."
        ],
        "Publicando a Biblioteca":[
          "Comandos: 'ng build my-lib --prod', 'cd dist/my-lib, e 'npm publish'",
          "Não é recomendável publicar as bibliotecas Ivy nos repositórios do NPM.",
          "Use a CLI Angular e o gerenciador de pacotes npm para criar e publicar sua biblioteca como um pacote npm.",
          "Antes de publicar uma biblioteca no NPM, construa-a usando o sinalizador --prod que usará o compilador e o tempo de execução mais antigos, conhecidos como View Engine, em vez de Ivy."
        ],
        "Usando a Biblioteca em Apps": [
          "Você não precisa publicar sua biblioteca no gerenciador de pacotes npm para usá-la em seus próprios aplicativos, mas precisa construí-la primeiro.",
          "Construa a biblioteca. Você não pode usar uma biblioteca antes que ela seja criada: ng build my-lib.",
          "Em sua aplicação, importe da biblioteca pelo nome: import { myExport } from 'my-lib';"
        ]
      }
    }
  },
  "Configurações": {
    "Estrutura do Projeto": {
      "Informações Relevantes": [
        "Você desenvolve aplicativos no contexto de um espaço de trabalho Angular.",
        "Um espaço de trabalho contém os arquivos para um ou mais projetos.",
        "Um projeto é o conjunto de arquivos que compõem um aplicativo independente ou uma biblioteca compartilhável.",
        "Por padrão, ng new cria um aplicativo esqueleto inicial no nível raiz da área de trabalho, junto com seus testes de ponta a ponta.",
        "O esqueleto é para um aplicativo de boas-vindas simples, pronto para executar e fácil de modificar.",
        "O aplicativo no nível raiz tem o mesmo nome que a área de trabalho e os arquivos de origem residem na ./src/ subpasta da área de trabalho.",
        "Usuários iniciantes e intermediários são incentivados a usar o ng new para criar um espaço de trabalho separado para cada aplicativo.",
        "O Angular também suporta áreas de trabalho com vários projetos. Esse tipo de ambiente de desenvolvimento é adequado para usuários avançados que estão desenvolvendo bibliotecas compartilháveis ​​e para empresas que usam um estilo de desenvolvimento 'monorepo', com um repositório único e configuração global para todos os projetos Angular.",
        "Todos os projetos em um espaço de trabalho compartilham um contexto de configuração da CLI.",
        "O maior nível da área de trabalho contém arquivos de configuração para toda a área de trabalho, arquivos de configuração para o aplicativo no nível raiz e subpastas para os arquivos de origem e teste da aplicação no nível raiz.",
        "Por padrão, o comando 'new' da CLI gera um novo esqueleto de aplicativo em uma pasta ./src/ no nível superior da área de trabalho. Um aplicativo recém-gerado contém arquivos de origem para um módulo raiz, com um componente raiz e um modelo.",
        "Para uma área de trabalho de aplicativo único, a ./src/ subpasta da área de trabalho contém os arquivos de origem (lógica, dados e ativos  da aplicação ) para o aplicativo raiz - para uma área de trabalho com vários projetos, os projetos são adicionados na pasta ./projects/ que contêm uma subpasta ./project-name/src/ com a mesma estrutura.",
        "Arquivos no nível superior de ./src/ suportam os testes e executam sua aplicação, já as subpastas contêm o código da aplicação e configuração específica.",
        "Os arquivos de configuração específicos da aplicação para o aplicativo raiz residem no nível raiz do espaço de trabalho. Para uma área de trabalho com vários projetos, os arquivos de configuração específicos do projeto estão na raiz do projeto, em projects ./project-name/",
        "Os arquivos de configuração TypeScript específicos do projeto são herdados do tsconfig.json em todo o espaço de trabalho e os arquivos de configuração TSLint específicos do projeto são herdados do tslint.json em todo o espaço de trabalho.",
        "A pasta ./e2e/ no nível superior contém arquivos de origem para um conjunto de testes de ponta a ponta que correspondem ao aplicativo no nível raiz, junto com arquivos de configuração específicos de test - para uma área de trabalho de vários projetos, os testes de ponta a ponta específicos do aplicativo estão na raiz do projeto, em projects/nome do projeto/e2e /."
      ],
      "Workspace Configuration Files": {
        ".editorconfig": "Configuração para recursos pertinentes a editores de código.",
        ".gitignore": "Especifica arquivos intencionalmente não rastreados que o Git deve ignorar.",
        "README.md": "Documentação introdutória para o aplicativo raiz.",
        "angular.json": "Padrões de configuração da CLI para todos os projetos no espaço de trabalho, incluindo opções de configuração para ferramentas de compilação, serviços e teste que a CLI usa, como TSLint, Karma e Protractor.",
        "package.json": "Configura as dependências do pacote npm que estão disponíveis para todos os projetos no espaço de trabalho.",
        "package-lock.json": "Fornece informações de versão para todos os pacotes instalados no node_modules pelo cliente npm.",
        "./src/": "Contempla os arquivos de origem para o projeto de aplicativo no nível raiz.",
        "./node_modules/": "Fornece pacotes npm para todo o espaço de trabalho. As dependências node_modules em todo o espaço de trabalho são visíveis para todos os projetos.",
        "tsconfig.json": "Contém a configuração padrão do TypeScript para projetos na área de trabalho.",
        "tslint.json": "Contém a configuração padrão do TSLint para projetos na área de trabalho."
      },
      "Source Config Files": {
        "./src/app/": "Contém os arquivos de componentes nos quais a lógica e os dados da aplicação estão definidos.",
        "./src/assets/": "Contém arquivos de imagem e outros ativos a serem copiados como estão quando você cria seu aplicativo.",
        "./src/environments/": "Contém opções de configuração de compilação para ambientes de destino específicos. Por padrão, há um ambiente de desenvolvimento sem nome e um ambiente de produção ('prod'). Você pode definir configurações adicionais do ambiente de destino.",
        "./src/favicon.ico": "Um ícone a ser usado para este aplicativo na barra de favoritos.",
        "./src/index.html": "Aquivo HTML principal que é exibida quando alguém visita seu site, a CLI adiciona automaticamente todos os arquivos JavaScript e CSS ao criar seu aplicativo. Portanto, você normalmente não precisa adicionar nenhuma tag <script> ou <link> aqui manualmente.",
        "./src/main.ts": "Principal ponto de entrada para a sua aplicação, compila o aplicativo com o compilador JIT e inicializa o módulo raiz da aplicação (AppModule) para executar no navegador. Você também pode usar o compilador AOT sem alterar nenhum código anexando o sinalizador --aot aos comandos de compilação e exibição da CLI.",
        "./src/polyfills.ts": "Fornece scripts de polyfill para suporte a compatibilidade do Javascript em navegadores.",
        "./src/styles.sass": "Lista de arquivos CSS que fornecem estilos para um projeto, a extensão reflete o pré-processador de estilo que você configurou para o projeto.",
        "./src/test.ts": "Principal ponto de entrada para seus testes de unidade, com algumas configurações específicas do Angular. Você normalmente não precisa editar este arquivo."
      },
      "App-Specific Config Files": {
        "browserslist": "Configura o compartilhamento de navegadores de destino e versões do Node.js entre várias ferramentas de front-end.",
        "karma.conf.js": "Configura informações específicas do Karma da aplicação .",
        "tsconfig.app.json": "Configura informações específicas do TypeScript da aplicação, incluindo opções de compilador de modelo TypeScript e Angular.",
        "tsconfig.spec.json": "Configura informações dp TypeScript para os testes da aplicação.",
        "tslint.json": "Configura informações específicas do TSLint da aplicação."
      },
      "Appliation Files": {
        "./src/app/app.component.ts": "Define a lógica do componente raiz  da aplicação, chamado AppComponent, e a visualização associada a esse componente raiz se torna a raiz da hierarquia da visualização à medida que você adiciona componentes e serviços ao seu aplicativo.",
        "./src/app/app.component.html": "Define o modelo HTML associado ao AppComponent raiz.",
        "./src/app/app.module.ts": "Define o módulo raiz, chamado AppModule, que informa ao Angular como montar o aplicativo. Inicialmente declara apenas o AppComponent, a medida que você adiciona mais componentes ao aplicativo, eles devem ser declarados aqui.",
        "./src/app/app.component.spec.ts": "Define um teste de unidade para o AppComponent raiz.",
        "./src/app/app.component.css": "Define a folha de estilo CSS base para o AppComponent raiz."
      },
      "Library Source Files": {
        "../src/lib/": "Contém a lógica e os dados do seu projeto de biblioteca, um projeto de biblioteca pode conter componentes, serviços, módulos, diretivas e tubulações.",
        "../src/test.ts": "O principal ponto de entrada para seus testes de unidade, com algumas configurações específicas da biblioteca. Você normalmente não precisa editar este arquivo.",
        "../src/public-api.ts": "Especifica todos os arquivos que são exportados da sua biblioteca.",
        "../karma.conf.js": "Configuração de karma específica da biblioteca.",
        "../ng-package.json": "Arquivo de configuração usado pelo ng-packagr para construir sua biblioteca.",
        "../package.json": "Configura as dependências do pacote npm necessárias para esta biblioteca.",
        "../tsconfig.lib.json": "Configuração TypeScript específica da biblioteca, incluindo opções de compilador de modelo TypeScript e Angular.",
        "../tsconfig.spec.json": "Configuração TypeScript para os testes da biblioteca.",
        "../tslint.json": "Configuração TSLint específica da biblioteca."
      }
    },
    "Configuração da Workspace": {
      "Estrutura Geral JSON": {
        "Informações Relevantes": [
          "O arquivo angular.json no nível raiz de um espaço de trabalho Angular fornece padrões de configuração específicos do projeto e para todo o espaço de trabalho para ferramentas de construção e desenvolvimento fornecidas pela CLI Angular. Os valores do caminho fornecidos na configuração são relativos à pasta da área de trabalho raiz.",
          "No nível superior do angular.json, algumas propriedades configuram a área de trabalho e uma seção de projetos contém as opções de configuração restantes por projeto. Os padrões da CLI configurados no nível da área de trabalho podem ser substituídos pelos padrões configurados no nível do projeto e os padrões configurados no nível do projeto podem ser substituídos na linha de comandos.",
          "Cada aplicativo adicional que você cria ng generate possui um projeto de teste de ponta a ponta correspondente, com sua própria seção de configuração. Quando você cria um projeto de biblioteca com ng generate library, o projeto de biblioteca também é adicionado à seção de projetos.",
          ""
        ],
        "Propriedades de Configuração": {
          "version": "Contém a versão do arquivo de configuração.",
          "newProjectRoot": "Contempla o caminho onde novos projetos são criados, absoluto ou relativo à pasta da área de trabalho.",
          "defaultProject": "Nome do projeto padrão a ser usado em comandos, onde não é fornecido como argumento. Quando você usa ng new para criar um novo aplicativo em um novo espaço de trabalho, esse aplicativo é o projeto padrão do espaço de trabalho até que seja alterado.",
          "schematics": "Um conjunto de esquemas que personalizam os padrões da opção de subcomando ng generate para este espaço de trabalho. Consulte Esquemas de geração abaixo.",
          "projects": "Contém uma subseção para cada projeto (biblioteca ou aplicativo) na área de trabalho, com as opções de configuração por projeto."
        },
        "Opções de Configuração do Projeto": {
          "root": "A pasta raiz dos arquivos deste projeto, relativa à pasta da área de trabalho - vazio para o aplicativo inicial, que reside no nível superior da área de trabalho.",
          "sourceRoot": "A pasta raiz dos arquivos de código do projeto.",
          "projectType": "( Aplicativo ou Biblioteca ), sendo que um aplicativo pode ser executado independentemente em um navegador, enquanto uma biblioteca não.",
          "prefix": "Uma sequência que o Angular acrescenta aos seletores gerados - pode ser personalizado para identificar um aplicativo ou área de recursos.",
          "schematics": "Um conjunto de esquemas que personalizam os padrões da opção de subcomando ng generate para o projeto.",
          "architect": "Configuração padrão para arquitetura 'build' alvo do projeto."
        },
        "Schematics": [
          "Esquemas de geração angular são instruções para modificar um projeto adicionando arquivos ou modificando arquivos existentes.",
          "Os esquemas individuais para os subcomandos de geração de CLI angular padrão são coletados no pacote @angular. Especifique o nome do esquema para um subcomando no formato schematic-package: schematic-name; por exemplo, o esquema para gerar um componente é @angular: component.",
          "Os schemas JSON por padrão são usados ​​pela CLI para gerar projetos e partes de projetos são coletados no pacote @schematics/angular. O schemas descreve as opções disponíveis para a CLI para cada um dos subcomandos ng generate, como mostrado na saída --help.",
          "Os campos fornecidos no esquema correspondem aos valores e padrões de argumentos permitidos para as opções de subcomando da CLI. Você pode atualizar seu arquivo de esquema da área de trabalho para definir um padrão diferente para uma opção de subcomando."
        ],
        "Architect": {
          "Informações Relevantes": [
            "O Architect é a ferramenta que a CLI usa para executar tarefas complexas, como compilação e execução de testes.",
            "Architect é um shell que executa um construtor especificado para executar uma determinada tarefa, de acordo com uma configuração de destino.",
            "Você pode definir e configurar novos construtores e destinos para estender a CLI.",
            "Angular define construtores padrão para uso com comandos específicos da CLI ou com o comando geral ng run - os schemas JSON que definem as opções e os padrões para cada um desses construtores padrão são coletados no pacote @angular-devkit/build-angular.",
            "A seção architect do angular.json contém um conjunto de destinos da arquitetura - muitos dos destinos correspondem aos comandos da CLI que os executam - alguns destinos predefinidos adicionais podem ser executados usando o comando ng run, e você pode definir seus próprios destinos.",
            "Cada objeto de destino de construção especifica o construtor para esse destino, que é o pacote npm para a ferramenta que o Architect executa.",
            "Cada destino possui uma seção de opções que configura as opções padrão para o destino e uma seção de configurações que nomeia e especifica configurações alternativas para o destino."
          ],
          "Destinos de Construção": {
            "build": {
              "Conceito": "Configura os padrões para as opções do comando ng build. Consulte Criar destino abaixo para obter mais informações.",
              "Propriedades": {
                "builder": "Contém o pacote npm para a ferramenta de construção da aplicação - o construtor padrão para um aplicativo (ng build myApp) é @angular-devkit/build-angular: browser, que usa o empacotador de pacote webpack - observe que um construtor diferente é usado para construir uma biblioteca (ng build myLib).",
                "options": "Esta seção contém opções de destino de construção padrão, usadas quando nenhuma configuração alternativa nomeada é especificada.",
                "configurations": "Esta seção define e nomeia configurações alternativas para diferentes destinos pretendidos - ele contém uma seção para cada configuração nomeada, que define as opções padrão para o ambiente pretendido."
              }
            },
            "serve": "Substitui os padrões de construção e fornece padrões de serviço adicionais para o comando ng serve. Além das opções disponíveis para o comando ng build, ele adiciona opções relacionadas à veiculação do aplicativo.",
            "e2e": "Substitui os padrões de opção de construção para criar aplicativos de teste de ponta a ponta usando o comando ng e2e.",
            "test": "Substitui os padrões de opção de compilação para compilações de teste e fornece padrões adicionais de execução de teste para o comando ng test.",
            "lint": "Configura os padrões para as opções do comando ng lint, que executa a análise de código nos arquivos de origem do projeto. A ferramenta de linting padrão para Angular é TSLint.",
            "extract-i18n": "Configura os padrões para as opções da ferramenta ng-xi18n usada pelo comando ng xi18n, que extrai as seqüências de mensagens marcadas do código-fonte e gera arquivos de tradução.",
            "server": "Configura os padrões para a criação de um aplicativo Universal com renderização no servidor, usando o comando ng run <project>: server.",
            "app-shell": "Configura os padrões para a criação de um shell de aplicativo para um aplicativo Web progressivo (PWA), usando o comando ng run <project>: app-shell."
          },
          "Build Alterinativo": [
            "Por padrão, uma configuração de produção é definida e o comando ng build possui a opção --prod que é criada usando essa configuração.",
            "A configuração de produção define padrões que otimizam o aplicativo de várias maneiras, como agrupar arquivos, minimizar o espaço em branco em excesso, remover comentários e código morto e reescrever o código para usar nomes curtos e enigmáticos ('minification').",
            "Você pode definir e nomear configurações alternativas adicionais (como estágio, por exemplo) apropriadas ao seu processo de desenvolvimento.",
            "As opções configuráveis ​​para uma compilação padrão ou direcionada geralmente correspondem às opções disponíveis para os comandos ng build, ng serve e ng test."
          ]
        }
      }
    },
    "Dependências NPM": {
      "Informações Relevantes": [
        "O Angular Framework, o Angular CLI e os componentes usados ​​pelos aplicativos Angular são empacotados como pacotes npm e distribuídos pelo registro npm.",
        "É possível fazer o download e instalar esses pacotes npm usando o cliente CLI npm, que é instalado e executado como um aplicativo Node.js.",
        "Como alternativa, você pode usar o cliente yarn para baixar e instalar pacotes npm.",
        "O package.json está organizado em dois grupos de pacotes: (1) dependências são essenciais para a execução de aplicativos; (2) devDependencies são necessárias apenas para desenvolver aplicativos."
      ],
      "package.json": [
        "O npm e o yarn instalam os pacotes identificados em um arquivo package.json.",
        "O comando da CLI ng new cria um arquivo package.json quando cria o novo espaço de trabalho. Este package.json é usado por todos os projetos no espaço de trabalho, incluindo o projeto inicial do aplicativo criado pela CLI quando ele cria o espaço de trabalho.",
        "Inicialmente, o package.json inclui um conjunto inicial de pacotes, alguns dos quais são exigidos pelo Angular e outros que suportam cenários comuns de aplicativos. Você adiciona pacotes ao package.json à medida que seu aplicativo evolui, pondendo remove-los também."
      ],
      "Pacotes do Angular": {
        "@angular/animations": "A biblioteca de animações do Angular facilita a definição e a aplicação de efeitos de animação, como transições de página e lista.",
        "@angular/comum": "Os serviços, tubulações e diretrizes geralmente necessários, fornecidos pela equipe Angular. O HttpClientModule também está aqui, na subpasta @angular/common/http.",
        "@angular/compiler": "Compilador de modelos do Angular. Ele compreende modelos e pode convertê-los em código que faz com que o aplicativo seja executado e renderizado. Normalmente você não interage diretamente com o compilador; em vez disso, você o usa indiretamente via plataforma-dinâmica do navegador ao compilar o JIT no navegador.",
        "@angular/core": "Partes críticas do tempo de execução da estrutura necessárias para cada aplicativo. Inclui todos os decoradores de metadados, Componente, Diretiva, injeção de dependência e os ganchos do ciclo de vida do componente.",
        "@angular/forms": "Suporte para formulários orientados a modelos e reativos.",
        "@angular/platform‑browser": "Tudo relacionado ao DOM e ao navegador, especialmente as peças que ajudam a renderizar no DOM. Este pacote também inclui o método bootstrapModuleFactory() para aplicativos de auto-inicialização para compilações de produção que são pré-compiladas com o AOT.",
        "@angular/platform‑browser‑dynamic": "Inclui provedores e métodos para compilar e executar o aplicativo no cliente usando o compilador JIT.",
        "@angular/router": "O módulo roteador navega entre as páginas do aplicativo quando o URL do navegador é alterado. Para mais informações."
      },
      "Pacotes de Suporte": {
        "rxjs": "Muitas APIs do Angular retornam Observables - o RxJS é uma implementação da especificação proposta do Observables atualmente no comitê do TC39, que determina os padrões para a linguagem JavaScript.",
        "zone.js": "O Angular conta com o zone.js para executar os processos de detecção de alterações do Angular quando operações JavaScript nativas geram eventos. Zone.js é uma implementação de uma especificação atualmente perante o comitê do TC39 que determina padrões para a linguagem JavaScript.",
        "core.js": "Muitos navegadores não têm suporte nativo para alguns recursos nos mais recentes padrões HTML, recursos exigidos pelo Angular. Os polyfills podem emular os recursos ausentes. O guia Suporte ao navegador explica quais navegadores precisam de polyfills e como você pode adicioná-los. O core-js, preenche os recursos ausentes de vários navegadores populares."
      },
      "DevDependecies": {
        "@angular‑devkit/build-angular": "As ferramentas de construção do Angular.",
        "@angular/cli": "As ferramentas da CLI do Angular.",
        "@angular/compiler-cli": "O compilador do Angular, que é chamado pelos comandos ng build e ng serve da CLI Angular.",
        "@angular/language-service": "O serviço de linguagem Angular analisa modelos de componentes e fornece informações de tipo e erro que os editores compatíveis com TypeScript podem usar para melhorar a experiência do desenvolvedor. Por exemplo, consulte a extensão do serviço de idioma angular para o VS Code.",
        "@types/...": "Arquivos de definição TypeScript para bibliotecas de terceiros, como Jasmine e Node.js. codelyzer Um ponteiro para aplicativos Angular cujas regras estão em conformidade com o guia de estilo Angular.",
        "asmine/...": "Pacotes para suportar a biblioteca de testes Jasmine.",
        "karma/...": "Pacotes para apoiar o corredor de teste de karma.",
        "protractor": "Uma estrutura de ponta a ponta (e2e) para aplicativos angulares. Criado sobre o WebDriverJS.",
        "ts-node": "Ambiente de execução TypeScript do ts-node e REPL para Node.js.",
        "tslint": "Uma ferramenta   de análise estática que verifica o código TypeScript em busca de erros de legibilidade, manutenção e funcionalidade.",
        "typescript": "O servidor de linguagem TypeScript, incluindo o compilador tsc TypeScript."
      }
    }
  }
}