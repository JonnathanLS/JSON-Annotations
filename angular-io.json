{
    "Intrudoção":[
        "Um aplicativo Angular compreende uma árvore de componentes, na qual cada componente Angular tem uma finalidade e responsabilidade específicas."
    ],
    "Diretivas": [
        "As diretivas estruturais moldam ou remodelam a estrutura do DOM, geralmente adicionando, removendo e manipulando os elementos aos quais estão anexados. Diretivas com um asterisco *, são diretivas estruturais."
    ],
    "Indefinidos":[
        "A interpolação {{ }}permite renderizar o valor da propriedade como texto.",
        "A ligação de propriedade [ ] permite usar o valor da propriedade em uma expressão de modelo.",
        "A associação de eventos usa um conjunto de parênteses ( ) ao redor do evento.",
        "O HttpClientModule da Angular registra os provedores que seu aplicativo precisa para usar uma única instância do serviço HttpClient em todo o aplicativo."
    ],
    "Componentes":{
        "Conceito": "Definem áreas de responsabilidade na interface do usuário, ou na UI, que permitem reutilizar conjuntos de funcionalidades da UI.",
        "Estrutura de um Componente": {
            "Class": "Uma classe de componente que lida com dados e funcionalidade. Na seção anterior",
            "Template": "Um modelo HTML que determina a interface do usuário.",
            "Style": "Estilos específicos de componentes que definem a aparência."
        }
    },
    "Routeamento":[
        "O ActivatedRoute é específico para cada componente roteado que o roteador angular carrega. Ele contém informações sobre a rota, seus parâmetros e dados adicionais associados à rota.",
        "Ao injetar o ActivatedRoute, você está configurando o componente para usar um serviço."
    ],
    "Pipes":[
        "O async pipe retorna o valor mais recente de um fluxo de dados e continua a fazê-lo pela vida útil de um determinado componente. Quando o Angular destrói esse componente, o canal assíncrono para automaticamente."
    ],
    "Fundamentos": {
        "Conceitos":{
            "Conceitos Básicos":{
                "O que é": "Angular é uma plataforma e estrutura para criar aplicativos cliente de página única usando HTML e TypeScript. Angular é escrito em TypeScript.",
                "Arquitetura":{
                    "Contexto": "A arquitetura de um aplicativo Angular depende de certos conceitos fundamentais.",
                    "Conceitos":[
                        "Os blocos de construção básicos estão em NgModules, que fornecem um contexto de compilação para componentes.",
                        "Os NgModules coletam código relacionado em conjuntos funcionais;",
                        "Um aplicativo Angular é definido por um conjunto de NgModules.",
                        "Um aplicativo sempre possui pelo menos um módulo raiz que habilita a inicialização e, normalmente, possui muito mais módulos de recursos."        
                    ]
                },
                "Componentes":[
                    "Os componentes definem visualizações, que são conjuntos de elementos de tela que o Angular pode escolher e modificar de acordo com a lógica e os dados do programa.",
                    "Os componentes usam serviços, que fornecem funcionalidades específicas não diretamente relacionadas às visualizações.",
                    "Os fornecedores de serviços podem ser injetados nos componentes como dependências, tornando seu código modular, reutilizável e eficiente.",
                    "Tanto os componentes quanto os serviços são simplesmente classes, com decoradores que marcam seu tipo e fornecem metadados que informam ao Angular como usá-los.",
                    "Todo aplicativo Angular possui pelo menos um componente, o componente raiz que conecta uma hierarquia de componentes ao modelo de objeto de documento de página (DOM).",
                    "Cada componente define uma classe que contém dados e lógica do aplicativo e está associada a um modelo HTML que define uma exibição a ser exibida em um ambiente de destino.",
                    "O decorador @Component () identifica a classe imediatamente abaixo dela como um componente e fornece o modelo e os metadados específicos do componente relacionados."
                ],
                "Metadados":[
                    "Os metadados para uma classe de componente o associam a um modelo que define uma exibição.",
                    "Um modelo combina HTML comum com diretivas Angular e marcação de ligação que permitem que o Angular modifique o HTML antes de renderizá-lo para exibição.",
                    "Os metadados para uma classe de serviço fornecem as informações que o Angular precisa para disponibilizá-lo aos componentes por meio de injeção de dependência (DI)."
                ],
                "Roteador":[
                    "Os componentes de um aplicativo geralmente definem muitas visualizações, organizadas hierarquicamente.",
                    "Angular fornece o serviço Roteador para ajudá-lo a definir os caminhos de navegação entre as visualizações.",
                    "O roteador fornece recursos sofisticados de navegação no navegador."
                ],
                "Módulos": [
                    "Os NgModules do Angular diferem e complementam os módulos JavaScript (ES2015).",
                    "Um NgModule declara um contexto de compilação para um conjunto de componentes dedicado a um domínio de aplicativo, um fluxo de trabalho ou um conjunto de recursos intimamente relacionado.",
                    "Um NgModule pode associar seus componentes a códigos relacionados, como serviços, para formar unidades funcionais",
                    "Todo aplicativo Angular possui um módulo raiz, chamado AppModule, que fornece o mecanismo de inicialização que inicia o aplicativo.",
                    "Como os módulos JavaScript, o NgModules pode importar funcionalidades de outros NgModules e permitir que suas próprias funcionalidades sejam exportadas e usadas por outros NgModules.",
                    "Organizar seu código em módulos funcionais distintos ajuda no gerenciamento do desenvolvimento de aplicativos complexos e no design para reutilização.",
                    "A modularização  permite aproveitar o carregamento lento, ou seja, carregar módulos sob demanda, para minimizar a quantidade de código que precisa ser carregado na inicialização."
                ],
                "Decoradores": [
                    "Decoradores são funções que modificam as classes JavaScript.",
                    "Angular define vários decoradores que anexam tipos específicos de metadados às classes, para que o sistema saiba o que essas classes significam e como devem funcionar."
                ],
                "Modelos":[
                    "Conceitos pertinentes a Templates, directives, and data binding",
                    "Um modelo combina HTML com marcação angular que pode modificar elementos HTML antes de serem exibidos.",
                    "As diretivas de modelo fornecem lógica de programa e a marcação de ligação conecta os dados do aplicativo e o DOM.",
                    "A associação de eventos permite que seu aplicativo responda à entrada do usuário no ambiente de destino, atualizando os dados do aplicativo.",
                    "A associação de propriedades permite interpolar valores calculados a partir dos dados do aplicativo para o HTML.",
                    "Antes de uma 'view'' ser exibida, o Angular avalia as diretivas e resolve a sintaxe de ligação no modelo para modificar os elementos HTML e o DOM, de acordo com os dados e a lógica do programa.",
                    "O Angular suporta ligação de dados bidirecional, o que significa que alterações no DOM, como opções do usuário, também são refletidas nos dados do programa.",
                    "Seus modelos podem usar 'pipes' para melhorar a experiência do usuário, transformando valores para exibição.",
                    "O Angular fornece 'pipes' predefinidos para transformações comuns, e você também pode definir seus próprios 'pipes'."
                ],
                "Injeção de Dependência":[
                    "Para dados ou lógica que não estão associados a uma exibição específica e que você deseja compartilhar entre componentes, você cria uma classe de serviço.",
                    "Uma definição de classe de serviço é imediatamente precedida pelo decorador @Injectable ().",
                    "O decorador fornece os metadados que permitem que outros provedores sejam injetados como dependências em sua classe.",
                    "A injeção de dependência (DI) permite manter suas classes de componentes magras e eficientes, eles não buscam dados do servidor, validam a entrada do usuário ou fazem logon diretamente no console; eles delegam essas tarefas nos serviços."
                ],
                "Roteamento":[
                    "O NgModule do roteador angular fornece um serviço que permite definir um caminho de navegação entre os diferentes estados do aplicativo e exibir hierarquias no seu aplicativo, e ele é modelado nas convenções familiares de navegação do navegador.",
                    "O roteador mapeia caminhos semelhantes a URL para visualizações em vez de páginas, quando um usuário executa uma ação, como clicar em um link, que carregaria uma nova página no navegador, o roteador intercepta o comportamento do navegador e mostra ou oculta as hierarquias de exibição.",
                    "Se o roteador determinar que o estado atual do aplicativo requer funcionalidade específica e o módulo que o define não foi carregado, o roteador poderá carregar preguiçosamente o módulo sob demanda.",
                    "Você pode definir regras de navegação, associando os caminhos de navegação aos seus componentes."
                ],
                "Resumo": "https://angular.io/generated/images/guide/architecture/overview2.png"
            },
            "Módulos":{
                "Informações Relevantes":[
                    "Os aplicativos Angular são modulares, sendo que o Angular possui seu próprio sistema de modularidade chamado NgModules.",
                    "NgModules são contêineres para um bloco de código coeso dedicado a um domínio de aplicativo, um fluxo de trabalho ou um conjunto de recursos intimamente relacionados.",
                    "Os NgModules podem conter componentes, provedores de serviços e outros arquivos de código cujo escopo é definido pelo NgModule que contém.",
                    "Os NgModules podem importar a funcionalidade exportada de outros NgModules e exportar a funcionalidade selecionada para uso por outros NgModules.",
                    "Todo aplicativo Angular tem pelo menos uma classe NgModule, o módulo raiz, que é convencionalmente chamado AppModule e reside em um arquivo chamado app.module.ts. Você inicia seu aplicativo inicializando o NgModule raiz.",
                    "Um NgModule é definido por uma classe decorada com @NgModule (). O decorador @NgModule () é uma função que aceita um único objeto de metadados, cujas propriedades descrevem o módulo.",
                    "O sistema NgModule é diferente e não está relacionado ao sistema do módulo JavaScript (ES2015) para gerenciar coleções de objetos JavaScript. Estes são sistemas de módulos complementares que você pode usar juntos para escrever seus aplicativos."
                ],
                "Propriedades Importantes":{
                    "declarations": "Os componentes, diretivas e canais que pertencem a este NgModule.",
                    "exports": "O subconjunto de declarações que devem ser visíveis e utilizáveis ​​nos modelos de componentes de outros NgModules.",
                    "imports": "Outros módulos cujas classes exportadas são necessárias pelos modelos de componentes declarados neste NgModule.",
                    "providers": "Criadores de serviços com os quais este NgModule contribui para a coleção global de serviços; eles se tornam acessíveis em todas as partes do aplicativo. (Você também pode especificar provedores no nível do componente, o que geralmente é preferido.)",
                    "bootstrap": "A visualização principal do aplicativo, chamada componente raiz, que hospeda todas as outras visualizações do aplicativo. Somente o NgModule raiz deve definir a propriedade bootstrap."
                }
            },
            "Componentes":{
                "Informações Relevantes":[
                    "Um componente controla um pedaço de tela chamado 'view'.",
                    "Você define a lógica do aplicativo de um componente - o que ele faz para suportar a exibição - dentro de uma classe. A classe interage com a exibição por meio de uma API de propriedades e métodos.",
                    "Os metadados de um componente informam ao Angular onde obter os principais componentes necessários para criar e apresentar o componente e sua visualização. Em particular, associa um modelo ao componente, diretamente com o código embutido ou por referência."
                ],
                "Template Syntax":[
                    "Um sintaxe de modelo se parece com HTML comum, exceto que também contém a sintaxe do modelo angular, que altera o HTML com base na lógica do aplicativo e no estado dos dados do aplicativo e do DOM.",
                    "Um modelo pode usar a ligação de dados para coordenar o aplicativo e os dados do DOM, canalizar para transformar os dados antes que eles sejam exibidos e diretrizes para aplicar a lógica do aplicativo ao que é exibido."
                ],
                "Data Biding":[
                    "Angular suporta ligação de dados bidirecional, um mecanismo para coordenar as partes de um modelo com as partes de um componente. Adicione marcação de ligação ao HTML do modelo para informar ao Angular como conectar os dois lados.",
                    "Na ligação bidirecional, um valor de propriedade de dados flui para a caixa de entrada do componente, como na ligação de propriedade. As alterações do usuário também retornam ao componente, redefinindo a propriedade para o valor mais recente, como na ligação de eventos.",
                    "A ligação de dados desempenha um papel importante na comunicação entre um modelo e seu componente e também é importante na comunicação entre os componentes pai e filho.",
                    "Angular processa todas as ligações de dados uma vez para cada ciclo de eventos JavaScript, desde a raiz da árvore de componentes do aplicativo até todos os componentes filhos."
                ],
                "Pipes": [
                    "Pipes permitem declarar transformações de valor de exibição no HTML do seu modelo.",
                    "Uma classe com o decorador @Pipe define uma função que transforma valores de entrada em valores de saída para exibição em uma 'view'.",
                    "Você pode encadear tubos, enviando a saída de uma função de tubo para ser transformada por outra função de tubo. Um canal também pode receber argumentos que controlam como ele realiza sua transformação. Por exemplo, você pode passar o formato desejado para o canal de datas."
                ],
                "Diretivas":[
                    "Angular templates are dynamic. When Angular renders them, it transforms the DOM according to the instructions given by directives. A directive is a class with a @Directive() decorator.",
                    "Um componente é tecnicamente uma diretiva. No entanto, os componentes são tão distintos e centrais para aplicativos Angular que Angular define o decorador @Component (), que estende o decorador @Directive () com recursos orientados a modelo.",
                    "Além dos componentes, existem outros dois tipos de diretivas: estrutural e atributo. Angular define várias diretivas de ambos os tipos e você pode definir suas próprias usando o decorador @Directive ().",
                    "Os metadados de uma diretiva associam a classe decorada a um elemento seletor usado para inseri-lo no HTML. Nos modelos, as diretivas geralmente aparecem em uma tag de elemento como atributos, por nome ou como destino de uma atribuição ou ligação.",
                    "As diretivas estruturais alteram o layout adicionando, removendo e substituindo elementos no DOM.",
                    "As diretivas de atributo alteram a aparência ou o comportamento de um elemento existente. Nos modelos, eles se parecem com atributos HTML regulares, daí o nome."

                ],
                "Configurações Úteis":{
                    "selector": "Um seletor de CSS que informa ao Angular para criar e inserir uma instância desse componente sempre que encontrar a tag correspondente no HTML. Ex.: se no HTML conter a tag <app-test> </app-test>, o Angular inserirá uma instância da exibição TestComponent entre essas tags.",
                    "templateUrl": "O endereço relativo ao modelo HTML deste componente. Como alternativa, você pode fornecer o modelo HTML embutido, como o valor da propriedade do modelo. Este modelo define a visualização do host do componente.",
                    "providers": "Uma matriz de provedores de serviços que o componente requer."
                },
                "4 Formas de Data Binding": "https://angular.io/generated/images/guide/architecture/databinding.png"
            },
            "Serviço Injetável":{
                "Informações Relevantes":[
                    "Serviço é uma categoria ampla que abrange qualquer valor, função ou recurso que um aplicativo precise. Um serviço geralmente é uma classe com um objetivo estreito e bem definido. Deve fazer algo específico e fazê-lo bem.",
                    "Angular distingue componentes de serviços para aumentar a modularidade e a reutilização. Ao separar a funcionalidade relacionada à exibição de um componente de outros tipos de processamento, você pode tornar suas classes de componentes mais enxutas e eficientes.",
                    "Idealmente, o trabalho de um componente é permitir a experiência do usuário e nada mais. Um componente deve apresentar propriedades e métodos para ligação de dados, para mediar entre a visualização (renderizada pelo modelo) e a lógica do aplicativo (que geralmente inclui alguma noção de modelo).",
                    "Um componente pode delegar determinadas tarefas aos serviços, como buscar dados do servidor, validar a entrada do usuário ou efetuar logon diretamente no console. Ao definir essas tarefas de processamento em uma classe de serviço injetável, você disponibiliza essas tarefas para qualquer componente.",
                    "Angular não aplica esses princípios, mas sim ajuda a seguir tais princípios, facilitando a fatoração da lógica do aplicativo em serviços e disponibilizando esses serviços aos componentes por meio da injeção de dependência.",
                    "Para definir uma classe como um serviço no Angular, use o decorador @Injectable () para fornecer os metadados que permitem ao Angular injetá-lo em um componente como uma dependência.",
                    "O injetor é o mecanismo principal. Angular cria um injetor para todo o aplicativo durante o processo de inicialização e injetores adicionais, conforme necessário. Você não precisa criar injetores.",
                    "Um injetor cria dependências e mantém um contêiner de instâncias de dependência que reutiliza, se possível. Um provedor é um objeto que informa ao injetor como obter ou criar uma dependência.",
                    "Quando o Angular descobre que um componente depende de um serviço, ele primeiro verifica se o injetor possui alguma instância existente desse serviço. Se uma instância de serviço solicitada ainda não existir, o injetor fará uma usando o provedor registrado e a adicionará ao injetor antes de retornar o serviço à Angular.",
                    "Quando você fornece o serviço no nível raiz, o Angular cria uma instância única e compartilhada do HeroService e o injeta em qualquer classe que solicitar. O registro do provedor nos metadados @Injectable () também permite que o Angular otimize um aplicativo removendo o serviço do aplicativo compilado, se ele não for usado.",
                    "Quando você registra um provedor com um NgModule específico, a mesma instância de um serviço está disponível para todos os componentes nesse NgModule. Para se registrar nesse nível, use a propriedade provider do decorador @NgModule ().",
                    "Ao registrar um provedor no nível do componente, você obtém uma nova instância do serviço com cada nova instância desse componente."
                ]
            }
        },
        "Componentes e Modelos":{
            "Exibindo Dados": {
                "Informações Relevantes":[
                    "Componentes angulares formam a estrutura de dados do seu aplicativo. O modelo HTML associado a um componente fornece os meios para exibir esses dados no contexto de uma página da web. Juntos, a classe e o modelo de um componente formam uma visualização dos dados do aplicativo.",
                    "O processo de combinar valores de dados com sua representação na página é chamado de ligação de dados. Você exibe seus dados para um usuário (e coleta dados do usuário) vinculando controles no modelo HTML às propriedades de dados da classe de componente.",
                    "Você pode adicionar lógica ao modelo incluindo diretivas, que informam ao Angular como modificar a página conforme ela é renderizada.",
                    "Angular define uma linguagem de modelo que expande a notação HTML com sintaxe que permite definir vários tipos de ligação de dados e diretivas lógicas. Quando a página é renderizada, Angular interpreta a sintaxe do modelo para atualizar o HTML de acordo com sua lógica e estado atual dos dados."
                ]
            },
            "Sintaxe do Modelo":{
                "Introdução": [
                    "O aplicativo Angular gerencia o que o usuário vê e pode fazer, conseguindo isso através da interação de uma instância de classe de componente (o componente) e seu modelo voltado para o usuário.",
                    "Em Angular, o componente desempenha o papel do controlador, e o modelo (template) representa a visualização."
                ],
                "HTML como Modelo": "HTML é a linguagem do modelo Angular. Quase toda a sintaxe HTML é uma sintaxe de modelo válida. O elemento <script> é uma exceção notável; é proibido, eliminando o risco de ataques de injeção de script. Na prática, <script> é ignorado e um aviso aparece no console do navegador.",
                "Interpolação":[
                    "A interpolação permite incorporar seqüências de caracteres calculadas no texto entre as tags de elemento HTML e nas atribuições de atributo. Expressões de modelo são o que você usa para calcular essas strings.",
                    "Angular avalia todas as expressões entre chaves duplas, converte os resultados da expressão em seqüências de caracteres e as vincula a seqüências literais vizinhas. Por fim, atribui esse resultado interpolado composto a uma propriedade de elemento ou diretiva.",
                    "A interpolação é uma sintaxe especial que o Angular converte em uma ligação de propriedade."    
                ],
                "Expressão de Modelo": "Uma expressão de modelo produz um valor e aparece dentro das chaves duplas, {{}}. Angular executa a expressão e a atribui a uma propriedade de um destino de ligação; o destino pode ser um elemento HTML, um componente ou uma diretiva.",
                "Contexto de Exmpressão":[
                    "O contexto da expressão é geralmente a instância do componente.",
                    "Uma expressão também pode se referir a propriedades do contexto do modelo, como uma variável de entrada do modelo.",
                    "O contexto para termos em uma expressão é uma mistura das variáveis ​​do modelo, do objeto de contexto da diretiva (se houver) e dos membros do componente. Se você referenciar um nome que pertence a mais de um desses espaços para nome, o nome da variável do modelo terá precedência, seguido por um nome no contexto da diretiva e, por último, os nomes dos membros do componente."
                ],
                "Diretrizes de Expressão":{
                    "Simplicidade": "Embora seja possível escrever expressões de modelo complexas, é uma melhor prática evitá-las. Um nome de propriedade ou chamada de método deve ser a norma, mas uma negação booleana ocasional,!, Está OK. Caso contrário, restrinja a lógica de aplicativo e de negócios ao componente, onde é mais fácil desenvolver e testar.",
                    "Rápidas Execuções": [
                        "Angular executa expressões de modelo após cada ciclo de detecção de alterações. Os ciclos de detecção de alterações são acionados por muitas atividades assíncronas, como resoluções de promessas, resultados HTTP, eventos de timer, pressionamentos de teclas e movimentos do mouse.",
                        "As expressões devem terminar rapidamente ou a experiência do usuário pode se arrastar, especialmente em dispositivos mais lentos. Considere armazenar valores em cache quando o cálculo for caro."
                    ],
                    "Sem Efeitos Colaterais Visíveis": [
                        "Uma expressão de modelo não deve alterar nenhum estado de aplicativo que não seja o valor da propriedade de destino. Essa regra é essencial para a política de 'fluxo de dados unidirecional' do Angular.",
                        "Você nunca deve se preocupar que a leitura de um valor de componente possa alterar algum outro valor exibido.",
                        "A visualização deve ser estável ao longo de uma única passagem de renderização.",
                        "Uma expressão idempotente é ideal porque é livre de efeitos colaterais e melhora o desempenho da detecção de alterações do Angular.",
                        "Em termos do Angular, uma expressão idempotente sempre retorna exatamente a mesma coisa até que um de seus valores dependentes seja alterado.",
                        "Os valores dependentes não devem mudar durante uma única volta do loop de eventos.",
                        "Se uma expressão idempotente retornar uma sequência ou um número, ela retornará a mesma sequência ou número quando chamada duas vezes seguidas.",
                        "Se a expressão retornar um objeto, incluindo uma matriz, retornará a mesma referência de objeto quando chamada duas vezes seguidas."
                    ],
                    "Instruções de Modelo":[
                        "Uma instrução de modelo responde a um evento gerado por um destino de ligação, como um elemento, componente ou diretiva.",
                        "Uma declaração de modelo tem um efeito colateral. Esse é o objetivo de um evento. É assim que você atualiza o estado do aplicativo a partir da ação do usuário.",
                        "Responder a eventos é o outro lado do 'fluxo de dados unidirecional' da Angular. Você é livre para alterar qualquer coisa, em qualquer lugar, durante essa reviravolta do evento.",
                        "Como expressões de modelo, as instruções de modelo usam uma linguagem que se parece com JavaScript. O analisador de instrução de modelo difere do analisador de expressão de modelo e suporta especificamente a atribuição básica (=) e as expressões de encadeamento com ';'."
                    ],
                    "Contexto da Declaração":[
                        "Assim como nas expressões, as instruções podem se referir apenas ao conteúdo do contexto da instrução, como um método de manipulação de eventos da instância do componente.",
                        "O contexto da instrução geralmente é a instância do componente, ou seja, metodo() em (click)='metodo()'' é um método do componente vinculado a dados.",
                        "O contexto da instrução também pode se referir às propriedades do próprio contexto do modelo.",
                        "Os nomes de contexto do modelo têm precedência sobre os nomes de contexto do componente."
                    ],
                    "Diretrizes de Declaração":[
                        "As instruções do modelo não podem se referir a nada no espaço para nome global.",
                        "Eles não podem se referir a janela ou documento.",
                        "Eles não podem chamar console.log ou Math.max.",
                        "Como nas expressões, evite escrever instruções de modelo complexas.",
                        "Uma chamada de método ou atribuição simples de propriedade deve ser a norma."
                    ],
                    "Sintaxe de Ligação":[
                        "A ligação de dados é um mecanismo para coordenar o que os usuários veem, especificamente com os valores dos dados do aplicativo.",
                        "Embora você possa enviar valores e extrair valores do HTML, o aplicativo é mais fácil de escrever, ler e manter se você entregar essas tarefas para uma estrutura de ligação. Você simplesmente declara ligações entre fontes de ligação, direciona elementos HTML e deixa a estrutura fazer o resto.",
                        "Os tipos de ligação que não sejam interpolação têm um nome de destino à esquerda do sinal de igual, cercado por pontuação, [] ou () ou precedido por um prefixo: bind-, on-, bindon-."
                    ],
                    "Atributo HTML vs. Propriedade DOM":[
                        "A distinção entre um atributo HTML e uma propriedade DOM é fundamental para entender como funciona a ligação Angular. ",
                        "Os atributos são definidos por HTML e as propriedades são acessadas a partir dos nós DOM (Document Object Model).",
                        "É importante lembrar que o atributo HTML e a propriedade DOM são coisas diferentes, mesmo quando eles têm o mesmo nome.", 
                        "No Angular, a única função dos atributos HTML é inicializar o elemento e o estado da diretiva.", 
                        "A ligação de modelo funciona com propriedades e eventos, não atributos.", 
                        "Quando você escreve uma ligação de dados, está lidando exclusivamente com as propriedades e eventos do DOM do objeto de destino.",
                        "Esta regra geral pode ajudá-lo a construir um modelo mental de atributos e propriedades DOM: Os atributos inicializam as propriedades DOM e, então, elas são concluídas. Os valores da propriedade podem mudar; valores de atributo não podem. Há uma exceção a esta regra. Os atributos podem ser alterados por setAttribute (), que reinicializa a propriedade DOM correspondente"
                    ]
                }             
            }
        },
        "Formulários": {
            "Informações Relevantes":[
                "Angular fornece duas abordagens diferentes para lidar com a entrada do usuário por meio de formulários: reativo e orientado a modelo. Ambos capturam eventos de entrada do usuário a partir da visualização, validam a entrada do usuário, criam um modelo de formulário e um modelo de dados para atualizar e fornecem uma maneira de rastrear alterações",
                "Formulários reativos e controlados por modelo processam e gerenciam dados de formulário de maneira diferente. Cada um oferece vantagens diferentes.",
                "As formas reativas são mais robustas: são mais escaláveis, reutilizáveis ​​e testáveis. Se os formulários são uma parte essencial do seu aplicativo, ou você já está usando padrões reativos para criar seu aplicativo, use formulários reativos.",
                "Formulários controlados por modelo são úteis para adicionar um formulário simples a um aplicativo, como um formulário de inscrição na lista de e-mails. Eles são fáceis de adicionar a um aplicativo, mas não são dimensionados tão bem quanto em formas reativas. Se você possui requisitos e lógica de formulário muito básicos que podem ser gerenciados apenas no modelo, use formulários controlados por modelo"

            ],
            "Fluxo de Dados":[
                "Os formulários reativos e controlados por modelo seguem duas estratégias diferentes ao manipular a entrada de formulário.",
                "nas formas reativas, cada elemento do formulário na exibição é diretamente vinculado a um modelo de formulário (instância do FormControl). As atualizações da visualização para o modelo e do modelo para a visualização são síncronas e não dependem da interface do usuário renderizada.",
                "Nos formulários controlados por modelo, cada elemento do formulário está vinculado a uma diretiva que gerencia o modelo de formulário internamente."
            ],
            "Validação":[
                "O Angular fornece um conjunto de validadores internos, além da capacidade de criar validadores personalizados.",
                "Os formulários reativos definem validadores personalizados como funções que recebem um controle para validar.",
                "Os formulários controlados por modelo estão vinculados às diretivas de modelo e devem fornecer diretivas de validador personalizadas que agrupam as funções de validação."
            ],
            "Testes":[
                "O teste desempenha um papel importante em aplicativos complexos e uma estratégia de teste mais simples é útil ao validar se seus formulários funcionam corretamente.",
                "Formulários reativos e formulários controlados por modelo têm diferentes níveis de confiança na renderização da interface do usuário para executar asserções com base no controle de formulário e alterações no campo de formulário.",
                "Os formulários reativos fornecem uma estratégia de teste relativamente fácil, porque fornecem acesso síncrono ao formulário e aos modelos de dados e podem ser testados sem renderizar a interface do usuário. Nesses testes, status e dados são consultados e manipulados através do controle sem interagir com o ciclo de detecção de alterações.",
                "A gravação de testes com formulários orientados a modelos requer um conhecimento detalhado do processo de detecção de alterações e um entendimento de como as diretivas são executadas em cada ciclo para garantir que os elementos sejam consultados, testados ou alterados no momento correto."
            ],
            "Mutabilidade":{
                "Reativo":[
                    "Os formulários reativos mantêm o modelo de dados puro, fornecendo-o como uma estrutura de dados imutável.",
                    "Sempre que uma alteração é acionada no modelo de dados, a instância FormControl retorna um novo modelo de dados em vez de atualizar o modelo de dados existente.",
                    "Permite rastrear alterações exclusivas no modelo de dados através da observação do controle.",
                    "Fornece uma maneira de a detecção de alterações ser mais eficiente, porque ela só precisa atualizar as alterações exclusivas.",
                    "Segue padrões reativos que se integram aos operadores observáveis ​​para transformar dados.",
                    "Com formulários reativos, a instância FormControl sempre retorna um novo valor quando o valor do controle é atualizado."
                    ],
                "Orientado a Modelos":[
                    "Os formulários controlados por modelo dependem da mutabilidade com ligação de dados bidirecional para atualizar o modelo de dados no componente conforme as alterações são feitas no modelo.",
                    "Como não há alterações exclusivas a serem rastreadas no modelo de dados ao usar a ligação de dados bidirecional, a detecção de alterações é menos eficiente na determinação de quando são necessárias atualizações.",
                    "Com formulários controlados por modelo, a propriedade de cor favorita é sempre modificada para seu novo valor."
                ]
            },
            "Escalabilidade":[
                "Os formulários reativos fornecem acesso a APIs de baixo nível e acesso síncrono ao modelo de formulário, facilitando a criação de formulários em grande escala.",
                "Os formulários orientados a modelos concentram-se em cenários simples, não são tão reutilizáveis, abstraem as APIs de baixo nível e fornecem acesso assíncrono ao modelo de formulário.",
                "A abstração com formulários controlados por modelo também aparece no teste, onde o teste de formulários reativos requer menos configuração e nenhuma dependência do ciclo de detecção de alterações ao atualizar e validar o formulário e os modelos de dados durante o teste."
            ],
            "Considerações Relevantes":[
                "A escolha de uma estratégia começa com a compreensão dos pontos fortes e fracos das opções apresentadas.",
                "Acesso de API de baixo nível e modelo de formulário, previsibilidade, mutabilidade, estratégias diretas de validação e teste e escalabilidade são considerações importantes na escolha da infraestrutura que você usa para criar seus formulários no Angular.",
                "Os formulários controlados por modelo são semelhantes aos padrões no AngularJS, mas têm limitações, devido aos critérios de muitos aplicativos Angular modernos em grande escala.",
                "As formas reativas integram-se aos padrões reativos já presentes em outras áreas da arquitetura Angular e complementam bem esses requisitos."
            ]
        },
        "HttpClient":{
            "Informações Relevantes":[
                "A maioria dos aplicativos front-end se comunica com serviços de back-end pelo protocolo HTTP. Navegadores modernos suportam duas APIs diferentes para fazer solicitações HTTP: a interface XMLHttpRequest e a API fetch ().",
                "O HttpClient em @ angular / common / http oferece uma API HTTP do cliente simplificada para aplicativos Angular que repousa na interface XMLHttpRequest exposta pelos navegadores.",
                "Os benefícios adicionais do HttpClient incluem recursos de testabilidade, objetos de solicitação e resposta digitados, interceptação de solicitação e resposta, APIs observáveis ​​e tratamento de erros simplificado.",
                "É uma prática recomendada separar a apresentação dos dados do acesso a dados, encapsulando o acesso a dados em um serviço separado e delegando esse serviço no componente, mesmo em casos simples."
            ],
            "Observáveis ​​e Operadores":[
                "O RxJS é uma biblioteca para compor código assíncrono e baseado em retorno de chamada em um estilo funcional e reativo. Muitas APIs Angular, incluindo HttpClient, produzem e consomem Observáveis ​​RxJS.",
                "Embora você possa se familiarizar com o mínimo de conhecimento em RxJS, convém aumentar suas habilidades em RxJS ao longo do tempo para usar o HttpClient com eficiência.",
                "Um método HttpClient não inicia sua solicitação HTTP até você chamar subscribe () no observável retornado por esse método. Isso vale para todos os métodos HttpClient",
                "Todos os observáveis ​​retornados dos métodos HttpClient são congelados por padrão, a execução da solicitação HTTP é adiada, permitindo que você estenda o observável com operações adicionais, como tap e catchError antes que algo realmente aconteça.",
                "De fato, cada subscrever () inicia uma execução separada e independente do observável. A inscrição duas vezes resulta em duas solicitações HTTP."
            ],
            "Interceptadores":{
                "Informações Relevantes":[
                    "Com a interceptação, você declara interceptores que inspecionam e transformam solicitações HTTP do seu aplicativo no servidor. Os mesmos interceptadores também podem inspecionar e transformar as respostas do servidor no caminho de volta ao aplicativo. Vários interceptadores formam uma cadeia de manipuladores de solicitações / respostas para frente e para trás.",
                    "Os interceptadores podem executar uma variedade de tarefas implícitas, da autenticação ao log, de maneira rotineira e padrão, para cada solicitação / resposta HTTP.",
                    "Sem interceptação, os desenvolvedores teriam que implementar essas tarefas explicitamente para cada chamada de método HttpClient.",
                    "A maioria dos interceptadores inspeciona a solicitação no caminho e encaminha a solicitação (talvez alterada) para o método handle () do próximo objeto que implementa a interface HttpHandler.",
                    "Como intercept (), o método handle () transforma uma solicitação HTTP em um Observable of HttpEvents, que inclui a resposta do servidor. O método intercept () pode inspecionar esse observável e alterá-lo antes de devolvê-lo ao chamador.",
                    "O 'next' objeto representa o próximo interceptador na cadeia de interceptores. O 'next' final da cadeia é o manipulador de back-end HttpClient que envia a solicitação ao servidor e recebe a resposta do servidor.",
                    "A maioria dos interceptores chama next.handle () para que a solicitação flua para o próximo interceptador e, eventualmente, para o manipulador de back-end. Um interceptador pode pular a chamada next.handle (), causar um curto-circuito na cadeia e retornar seu próprio Observable com uma resposta artificial do servidor.",
                    "Como os interceptores são dependências (opcionais) do serviço HttpClient, você deve fornecê-los no mesmo injetor (ou pai do injetor) que fornece o HttpClient. Os interceptores fornecidos após o DI criar o HttpClient são ignorados."
                ],
                "Ordem dos Interceptadores":[
                    "Angular aplica interceptores na ordem em que você os fornece. Se você fornecer interceptores A, então B e C, as solicitações fluirão em A-> B-> C e as respostas fluirão C-> B-> A.",
                    "Você não pode alterar a ordem ou remover os interceptores posteriormente. Se você precisar habilitar e desabilitar um interceptor dinamicamente, precisará criar esse recurso no próprio interceptador.",
                    "Embora os interceptores sejam capazes de alterar solicitações e respostas, as propriedades da instância HttpRequest e HttpResponse são somente leitura, tornando-as imutáveis."
                ],
                "Imutabilidade":[
                    "Eles são imutáveis ​​por um bom motivo: o aplicativo pode repetir uma solicitação várias vezes antes de ser bem-sucedido, o que significa que a cadeia de interceptadores pode reprocessar a mesma solicitação várias vezes.",
                    "Se um interceptador pudesse modificar o objeto de solicitação original, a operação tentada novamente seria iniciada a partir da solicitação modificada, e não do original. A imutabilidade garante que os interceptadores vejam a mesma solicitação para cada tentativa.",
                    "O protetor de atribuição somente leitura não pode impedir atualizações profundas e, em particular, não pode impedir que você modifique uma propriedade de um objeto do corpo da solicitação. Se você deve alterar o corpo da solicitação, copie-o primeiro, altere a cópia, clone () a solicitação e defina o corpo do clone com o novo corpo",
                    "Às vezes, você precisa limpar o corpo da solicitação em vez de substituí-lo. Se você definir o corpo da solicitação clonada como indefinido, o Angular assumirá que pretende deixar o corpo como está. Não é isso que você quer. Se você definir o corpo da solicitação clonada como nulo, o Angular saberá que você deseja limpar o corpo da solicitação."
                ],
                "Registro": "Como os interceptores podem processar a solicitação e a resposta juntos, eles podem fazer coisas como tempo e registrar uma operação HTTP inteira.",
                "Cache":[
                    "Os interceptadores podem lidar com solicitações por si mesmos, sem encaminhar para next.handle ().",
                    "Você pode decidir armazenar em cache determinadas solicitações e respostas para melhorar o desempenho.",
                    "Você pode delegar o armazenamento em cache a um interceptador sem perturbar os serviços de dados existentes."
                ],
                "Progresso de Eventos":[
                    "Às vezes, os aplicativos transferem grandes quantidades de dados e essas transferências podem levar muito tempo, e os uploads de arquivos são um exemplo típico. Fornecer ao usuário feedback sobre o andamento dessas transferências, é uma ótima prática.",
                    "Para fazer uma solicitação com os eventos de progresso ativados, é possível criar uma instância do HttpRequest com a opção reportProgress configurada como true para ativar o rastreamento de eventos de progresso.",
                    "Todo evento de progresso aciona a detecção de alterações, portanto, somente ative-as se você realmente pretender relatar o progresso na interface do usuário. Ao usar HttpClient # request () com um método HTTP, configure com observe: 'events' para ver todos os eventos, incluindo o andamento das transferências."
                ],
                "Segurança: Proteção XSR": [
                    "A falsificação de solicitação entre sites (XSRF ou CSRF) é uma técnica de ataque pela qual o invasor pode induzir um usuário autenticado a executar ações inconscientemente no seu site.",
                    "O HttpClient suporta um mecanismo comum usado para impedir ataques XSRF.",
                    "Ao executar solicitações HTTP, um interceptador lê um token de um cookie, por padrão, XSRF-TOKEN, e o define como um cabeçalho HTTP, X-XSRF-TOKEN. Como apenas o código executado em seu domínio pode ler o cookie, o back-end pode ter certeza de que a solicitação HTTP veio do aplicativo cliente e não de um invasor.",
                    "Por padrão, um interceptador envia esse cabeçalho em todas as solicitações mutantes (como POST) para URLs relativos, mas não em solicitações GET / HEAD ou em solicitações com uma URL absoluta.",
                    "Seu servidor precisa definir um token em um cookie de sessão legível por JavaScript chamado XSRF-TOKEN no carregamento da página ou na primeira solicitação GET, de modo que, em solicitações subsequentes, o servidor pode verificar se o cookie corresponde ao cabeçalho HTTP X-XSRF-TOKEN e, portanto, verificar se apenas o código em execução no seu domínio pode ter enviado a solicitação.",
                    "O token deve ser exclusivo para cada usuário e deve ser verificável pelo servidor; isso impede que o cliente crie seus próprios tokens.",
                    "Definir o token como um resumo do cookie de autenticação do seu site como um extra, para aumentar a segurança."
                ]
            }   
        }
    }
}
